<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生若梦</title>
  
  <subtitle>而浮生若梦，为欢几何？</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-22T04:31:18.134Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Charlotte</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2025-09-20T10:29:28.000Z</published>
    <updated>2025-09-22T04:31:18.134Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 (Array)"></a>1. 数组 (Array)</h1><p><strong>特点</strong>：连续内存，随机访问 O(1)，插入&#x2F;删除 O(n)。</p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找（线性查找）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insert(<span class="type">int</span>[] arr, <span class="type">int</span> pos, <span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) newArr[i] = val;</span><br><span class="line">        <span class="keyword">else</span> newArr[i] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] delete(<span class="type">int</span>[] arr, <span class="type">int</span> pos) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) <span class="keyword">continue</span>;</span><br><span class="line">        newArr[j++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-链表-Linked-List"><a href="#2-链表-Linked-List" class="headerlink" title="2. 链表 (Linked List)"></a>2. 链表 (Linked List)</h1><p><strong>特点</strong>：动态存储，插入&#x2F;删除 O(1)，随机访问 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next)</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（头插）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">insertHead</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    node.next = head;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定节点后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(ListNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = node.next;</span><br><span class="line">    node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（按值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">delete</span><span class="params">(ListNode head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.val == target) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.val == target) &#123;</span><br><span class="line">            p.next = p.next.next; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-栈-Stack"><a href="#3-栈-Stack" class="headerlink" title="3. 栈 (Stack)"></a>3. 栈 (Stack)</h1><p><strong>特点</strong>：LIFO，常用数组或链表实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeLast(); &#125;   <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getLast(); &#125;     <span class="comment">// 查看栈顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4. 队列 (Queue)"></a>4. 队列 (Queue)</h1><p><strong>特点</strong>：FIFO，可以用链表或循环数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeFirst(); &#125; <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getFirst(); &#125;       <span class="comment">// 查看队首</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双端队列 Deque</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">deque.addFirst(<span class="number">1</span>); <span class="comment">// 头插</span></span><br><span class="line">deque.addLast(<span class="number">2</span>);  <span class="comment">// 尾插</span></span><br><span class="line">deque.removeFirst();</span><br><span class="line">deque.removeLast();</span><br></pre></td></tr></table></figure><hr><h1 id="5-树-Tree"><a href="#5-树-Tree" class="headerlink" title="5. 树 (Tree)"></a>5. 树 (Tree)</h1><p>以 <strong>二叉树</strong> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历 (根-左-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (左-根-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 (左-右-根)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left);</span><br><span class="line">    postorder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历 (BFS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.add(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆-Heap"><a href="#6-堆-Heap" class="headerlink" title="6. 堆 (Heap)"></a>6. 堆 (Heap)</h1><p>常用 <strong>最小堆 &#x2F; 最大堆</strong>，一般用数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">minHeap.add(<span class="number">3</span>);</span><br><span class="line">minHeap.add(<span class="number">1</span>);</span><br><span class="line">minHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(minHeap.poll()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">maxHeap.add(<span class="number">3</span>);</span><br><span class="line">maxHeap.add(<span class="number">1</span>);</span><br><span class="line">maxHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(maxHeap.poll()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h1 id="7-图-Graph"><a href="#7-图-Graph" class="headerlink" title="7. 图 (Graph)"></a>7. 图 (Graph)</h1><p>常见表示：<strong>邻接表</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.computeIfAbsent(u, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(v);</span><br><span class="line">        adj.computeIfAbsent(v, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(u); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                    visited.add(nei);</span><br><span class="line">                    q.add(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        dfsHelper(start, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsHelper</span><span class="params">(<span class="type">int</span> node, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            dfsHelper(nei, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-数组-Array&quot;&gt;&lt;a href=&quot;#1-数组-Array&quot; class=&quot;headerlink&quot; title=&quot;1. 数组 (Array)&quot;&gt;&lt;/a&gt;1. 数组 (Array)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：连续内存，随机</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-16T05:17:13.884Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p><h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul><li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul><li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li><li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li></ul></li><li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul><li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li><li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li></ul></li><li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul><li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li><li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li></ul></li><li><strong>API 网关 (API Gateway): Zuul</strong><ul><li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li><li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li></ul></li></ul><hr><h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p><ul><li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul><li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul><li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li><li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li><li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li><li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li></ol></li></ul></li><li><strong>熔断、降级与流量控制: Sentinel</strong><ul><li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li><li><strong>核心概念</strong>:<ul><li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li><li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li><li>配置 Sentinel 控制台地址。</li><li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li></ol></li></ul></li><li><strong>分布式事务解决方案: Seata</strong><ul><li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li><li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li></ul></li></ul><hr><h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p><ul><li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li><li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li><li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li><li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li><li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li><li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li><li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li></ul><h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p><p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p><ul><li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li><li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li><li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li><li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li></ul><hr><h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p><h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul><li><strong>用户 (User)</strong>: 系统操作的主体。</li><li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li><li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li></ul><h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p><p>一个基础的 RBAC 模型至少需要五张表：</p><ul><li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul><li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li></ul></li><li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul><li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li></ul></li><li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul><li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li></ul></li><li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul><li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li></ul></li><li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul><li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li></ul></li></ul><hr><h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul><li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li><li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li><li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li><li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li></ul><h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul><li><strong>缓存穿透</strong>:<ul><li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li><li><strong>解决</strong>:<ol><li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li></ol></li></ul></li><li><strong>缓存击穿</strong>:<ul><li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li><li><strong>解决</strong>:<ol><li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li><li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>:<ul><li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li><li><strong>解决</strong>:<ol><li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li><li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li><li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li></ol></li></ul></li></ul><hr><h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul><li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li><li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li><li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li></ul><h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p><ul><li><strong>消息丢失 (Message Loss)</strong>:<ul><li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li><li><strong>解决</strong>:<ol><li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li><li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li><li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li></ol></li></ul></li><li><strong>重复消费 (Duplicate Consumption)</strong>:<ul><li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li><li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol><li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li><li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li></ol></li></ul></li><li><strong>消息堆积 (Message Backlog)</strong>:<ul><li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li><li><strong>解决</strong>:<ol><li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li><li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li><li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li><li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li></ol></li></ul></li></ul><hr><h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p><h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>基于数据库</strong></td><td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td><td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td><td>并发度不高的简单场景。</td></tr><tr><td><strong>基于 ZooKeeper</strong></td><td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td><td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td><td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td></tr><tr><td><strong>基于 Redis</strong></td><td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td><td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td><td>互联网高并发、对性能要求高的绝大多数场景。</td></tr></tbody></table><h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul><li><p>加锁的正确姿势:</p><p>使用 SET key value NX EX time 命令。</p><ul><li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p></li><li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p></li><li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p><p>这三个参数必须在一个命令中执行，保证原子性。</p></li></ul></li><li><p><strong>解锁的正确姿势：Lua 脚本</strong></p><ul><li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p></li><li><p><strong>Lua 脚本示例</strong>:</p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p></li><li><p><strong>Redis 乐观锁：WATCH 命令</strong></p><ul><li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p></li><li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p></li><li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p><ol><li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p></li><li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p></li><li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p></li><li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p></li><li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p></li><li><p>EXEC &#x2F;&#x2F; 执行事务</p><p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p></li></ol></li></ul></li></ul><h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p><p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p><ul><li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li><li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul><li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li><li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li></ul></li></ul><hr><h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p><h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul><li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul><li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li><li><strong>流程 (2PC)</strong>:<ol><li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li><li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li></ol></li><li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li></ul></li><li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul><li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li><li><strong>流程</strong>:<ol><li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li><li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li><li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li></ol></li><li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li></ul></li><li><strong>Saga 模式</strong>: 长事务解决方案。<ul><li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li><li><strong>流程</strong>:<ul><li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li><li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li></ul></li><li><strong>与 TCC 对比</strong>:<ul><li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li><li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li></ul></li><li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li></ul></li><li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul><li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li><li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li><li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul><li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li><li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li></ul></li><li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li></ul></li></ul><h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p><p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p><h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul><li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li><li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li><li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li></ul><h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p><p>EVAL script numkeys key [key …] arg [arg …]</p><ul><li><code>script</code>: 要执行的 Lua 脚本字符串。</li><li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li><li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li><li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li></ul><p><strong>示例：实现一个安全的库存扣减</strong></p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span><br><span class="line">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span><br><span class="line">-- ARGV[1]: 本次要扣减的数量</span><br><span class="line"></span><br><span class="line">local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]))</span><br><span class="line">local quantity = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">if stock &gt;= quantity then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], quantity)</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p><hr><h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p><p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p><ul><li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li><li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li><li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li></ul><h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol><li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li><li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li><li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li><li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li><li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li><li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li><li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul><li>验证签名是否正确，确保 Token 未被篡改。</li><li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li><li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li><li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li></ul></li></ol><h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p><p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p><table><thead><tr><th>特性对比</th><th>Session 机制</th><th>Token 机制</th><th>优势说明</th></tr></thead><tbody><tr><td><strong>状态存储</strong></td><td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td><td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td><td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td></tr><tr><td><strong>可扩展性</strong></td><td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td><td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td><td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td></tr><tr><td><strong>跨域支持</strong></td><td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td><td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td><td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td></tr><tr><td><strong>安全性</strong></td><td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td><td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td><td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td></tr><tr><td><strong>适用性</strong></td><td>适合传统的、一体化的 Web 应用。</td><td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td><td>Token 更具通用性和前瞻性。</td></tr></tbody></table><h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul><li><strong>Q: 为什么不用单个 Token？</strong><ul><li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li><li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li></ul></li><li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul><li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li><li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li></ul></li><li><strong>双令牌工作流程（静默刷新）</strong><ol><li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li><li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li><li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li><li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li><li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li><li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li><li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li><li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li></ol></li></ul><h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul><li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>localStorage&#x2F;sessionStorage</strong>:<ul><li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li><li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li></ul></li><li><strong>Cookie (HttpOnly)</strong>:<ul><li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li><li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li></ul></li><li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul><li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li><li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li></ul></li></ul></li></ul></li><li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>对于无状态的 JWT</strong>: 由于所有信息都在 Token 自身，服务端无法主动让其失效。因此，“退出登录”主要是一个<strong>客户端行为</strong>。<ul><li><strong>客户端</strong>: 只需从 <code>localStorage</code> 或其他存储位置清除 Token 即可。用户将无法再发起认证请求。</li></ul></li><li><strong>如何实现服务端强制下线？</strong>: 如果需要实现“踢人下线”或“修改密码后所有设备强制下线”的功能，就必须打破纯粹的无状态。<ul><li><strong>黑名单机制</strong>: 服务端可以建立一个 Token 黑名单（例如，使用 Redis Set）。当用户退出登录时，将该 Token 的 <code>jti</code> (JWT ID) 或整个 Token 放入黑名单，并设置与 Token 剩余有效期相同的过期时间。在每次验证 Token 时，除了常规验证，还需检查该 Token 是否在黑名单中。</li><li><strong>基于 Refresh Token</strong>: 在双令牌模式下，退出登录时只需让服务端的 <code>Refresh Token</code> 失效（例如，从 Redis 中删除）。这样用户就无法再获取新的 <code>Access Token</code>，当旧的 <code>Access Token</code> 过期后，自然就下线了。</li></ul></li></ul></li></ul></li><li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul><li><strong>回答要点</strong>:<ul><li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li><li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li><li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li><li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li><li><strong>流程</strong>:<ol><li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li><li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li><li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li><li>API 网关拦截请求，验证 <code>Access Token</code>。</li><li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li></ol></li><li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li></ul></li></ul></li></ul><h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p><p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p><p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p><p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p><p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p><h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p><p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p><ul><li>文件事件：处理客户端连接、读写请求</li><li>时间事件：处理定时任务，如过期键删除、持久化等</li></ul><p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p><h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p><p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p><ul><li>缓存：存储用户会话、配置信息</li><li>计数器：网站访问量、点赞数（INCR原子性保证）</li><li>分布式锁：SET key value NX EX seconds</li><li>限流：结合EXPIRE实现滑动窗口限流</li></ul><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p><p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p><ul><li>存储用户信息：HSET user:1001 name “张三” age 25</li><li>购物车：HSET cart:1001 product:123 2</li><li>配置管理：分类存储不同模块的配置</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p><p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p><ul><li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li><li>最新列表：朋友圈动态、商品评论</li><li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p><p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p><ul><li>去重：统计网站独立访客</li><li>社交关系：共同好友、推荐用户</li><li>标签系统：用户标签、文章分类</li><li>抽奖系统：SRANDMEMBER随机抽取</li></ul><h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p><p><strong>应用场景</strong>：</p><ul><li>排行榜：游戏积分、热搜榜</li><li>延时队列：分数为执行时间戳</li><li>范围查询：按时间、按分数范围获取数据</li></ul><h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p><p><strong>优点</strong>：</p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复速度快</li><li>对Redis性能影响小（子进程操作）</li></ul><p><strong>缺点</strong>：</p><ul><li>数据丢失风险：两次快照间的数据可能丢失</li><li>fork过程会阻塞主进程</li><li>大数据集fork耗时较长</li></ul><p><strong>触发条件</strong>：</p><ul><li>手动执行SAVE或BGSAVE命令</li><li>配置自动触发：save 900 1（900秒内至少1个键改变）</li><li>主从复制时自动生成RDB</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p><p><strong>写入时机</strong>：</p><ul><li>always：每个写命令立即同步，安全但性能低</li><li>everysec：每秒同步一次，平衡安全性和性能</li><li>no：由操作系统决定同步时机，性能高但安全性低</li></ul><p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p><ul><li>遍历内存数据，用最少命令重建AOF文件</li><li>重写期间的新命令写入AOF重写缓冲区</li><li>原子性替换旧AOF文件</li></ul><p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p><h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (data == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;null&quot;);  // 缓存空值60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 1000000, 0.01);</span><br><span class="line">// 查询前先检查布隆过滤器</span><br><span class="line">if (!filter.mightContain(key)) &#123;</span><br><span class="line">    return null;  // 一定不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>参数校验</strong>：在API层面进行参数合法性校验</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p><p><strong>解决方案</strong>：</p><ol><li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">    String data = redis.get(key);</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">        String lockKey = &quot;lock:&quot; + key;</span><br><span class="line">        if (redis.setnx(lockKey, &quot;1&quot;, 10)) &#123;  // 获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">                data = database.query(key);  // 查询数据库</span><br><span class="line">                redis.setex(key, 3600, data);  // 重建缓存</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                redis.del(lockKey);  // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(50);  // 等待其他线程重建缓存</span><br><span class="line">            return getData(key);  // 递归重试</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li><li><strong>预热机制</strong>：系统启动时预先加载热点数据</li><li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>：避免同时过期</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 基础时间+随机时间</span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure><ol><li><strong>多级缓存架构</strong>：<ul><li>L1：本地缓存（如Caffeine）</li><li>L2：Redis分布式缓存</li><li>L3：数据库</li></ul></li><li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li><li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p><p><strong>实现方式</strong>：</p><ol><li><strong>定时任务预热</strong>：凌晨低峰期执行</li><li><strong>手动预热</strong>：管理后台触发预热任务</li><li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li></ol><h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p><p><strong>读操作</strong>：</p><ol><li>先读缓存，命中则返回</li><li>缓存不命中，查询数据库</li><li>将数据写入缓存并返回</li></ol><p><strong>写操作</strong>：</p><ol><li>先更新数据库</li><li>删除缓存（让下次读取时重新加载）</li></ol><p><strong>为什么是删除而不是更新缓存？</strong></p><ul><li>更新缓存可能存在并发问题</li><li>复杂查询的缓存更新成本高</li><li>删除缓存更简单可靠</li></ul><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p><p><strong>实现步骤</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void updateData(String key, Object data) &#123;</span><br><span class="line">    // 1. 删除缓存</span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    // 2. 更新数据库</span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    // 3. 延时删除缓存（异步）</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);  // 延时500ms</span><br><span class="line">            redis.del(key);     // 再次删除缓存</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;延时删除缓存失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p><h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p><p><strong>实现流程</strong>：</p><ol><li>更新数据库，发送消息到队列</li><li>消息消费者删除相关缓存</li><li>消费失败时重试，保证最终一致性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 发送缓存删除消息</span><br><span class="line">@Transactional</span><br><span class="line">public void updateUser(User user) &#123;</span><br><span class="line">    userDao.update(user);  // 更新数据库</span><br><span class="line">    </span><br><span class="line">    // 发送缓存删除消息（事务提交后发送）</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        new TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterCommit() &#123;</span><br><span class="line">                cacheDeleteMQ.send(&quot;user:&quot; + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p><p><strong>2PC（两阶段提交）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否准备好</li><li>提交阶段：所有参与者都准备好则提交，否则回滚</li></ul><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：确认提交</li><li>Cancel：取消执行，释放资源</li></ul><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDistributedLock &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    public boolean tryLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</span><br><span class="line">        return &quot;OK&quot;.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        return &quot;1&quot;.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = &quot;lock:user:1001&quot;;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p><p><strong>算法步骤</strong>：</p><ol><li>获取当前时间戳</li><li>依次向N个Redis实例申请锁</li><li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li><li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li><li>释放锁时，向所有Redis实例发送释放命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Redlock &#123;</span><br><span class="line">    private List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    public boolean lock(String resource, int ttl) &#123;</span><br><span class="line">        int quorum = jedisInstances.size() / 2 + 1;</span><br><span class="line">        int successCount = 0;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        for (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            if (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        if (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unlock(resource);  // 释放已获取的锁</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p><p><strong>解决方案</strong>：</p><ol><li><strong>看门狗机制</strong>：定时续期锁的过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WatchDog &#123;</span><br><span class="line">    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);</span><br><span class="line">    </span><br><span class="line">    public void startWatchDog(String lockKey, String requestId) &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            // 续期锁</span><br><span class="line">            String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                           &quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, &quot;30&quot;));</span><br><span class="line">        &#125;, 10, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li></ol><p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分段锁</strong>：将资源分段，减少锁竞争</li><li><strong>队列锁</strong>：使用List实现公平锁</li><li><strong>自旋锁优化</strong>：适当的退避算法</li></ol><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p><p><strong>Redis实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用Redis分布式锁实现悲观锁</span><br><span class="line">public void updateWithPessimisticLock(String userId, int amount) &#123;</span><br><span class="line">    String lockKey = &quot;lock:account:&quot; + userId;</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询账户余额</span><br><span class="line">            int balance = getBalance(userId);</span><br><span class="line">            if (balance &gt;= amount) &#123;</span><br><span class="line">                // 扣减余额</span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InsufficientBalanceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new LockAcquisitionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p><p><strong>基于版本号的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateWithOptimisticLock(String userId, int amount, int expectedVersion) &#123;</span><br><span class="line">    // 使用Lua脚本保证原子性</span><br><span class="line">    String script = </span><br><span class="line">        &quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot; +</span><br><span class="line">        &quot;if current[2] == ARGV[2] then &quot; +</span><br><span class="line">        &quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot; +</span><br><span class="line">        &quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot; +</span><br><span class="line">        &quot;    return 1 &quot; +</span><br><span class="line">        &quot;  else &quot; +</span><br><span class="line">        &quot;    return -1 &quot; +  // 余额不足</span><br><span class="line">        &quot;  end &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +     // 版本号不匹配</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    String key = &quot;account:&quot; + userId;</span><br><span class="line">    Object result = jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    int code = ((Long) result).intValue();</span><br><span class="line">    if (code == 1) &#123;</span><br><span class="line">        return true;  // 更新成功</span><br><span class="line">    &#125; else if (code == 0) &#123;</span><br><span class="line">        throw new OptimisticLockException(&quot;数据已被修改&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientBalanceException(&quot;余额不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于CAS的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateWithCAS(String key, Function&lt;String, String&gt; updater) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 1. 获取当前值</span><br><span class="line">        String currentValue = redis.get(key);</span><br><span class="line">        </span><br><span class="line">        // 2. 计算新值</span><br><span class="line">        String newValue = updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        // 3. CAS更新</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;;</span><br><span class="line">        Object result = redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            break;  // 更新成功</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新失败，重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p><ul><li>写操作频繁，冲突概率高</li><li>业务逻辑复杂，重试成本高</li><li>对数据一致性要求严格</li></ul><p><strong>乐观锁适用场景</strong>：</p><ul><li>读多写少，冲突概率低</li><li>业务逻辑简单，重试成本低</li><li>对性能要求高</li></ul><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p><p><strong>复制原理</strong>：</p><ol><li>Slave向Master发送PSYNC命令</li><li>Master执行BGSAVE生成RDB文件</li><li>Master将RDB文件发送给Slave</li><li>Slave载入RDB文件</li><li>Master将缓冲区的写命令发送给Slave</li><li>后续写命令实时同步</li></ol><p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p><h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p><p><strong>哨兵职责</strong>：</p><ul><li>监控：定期ping Master和Slave</li><li>通知：故障时通知管理员和客户端</li><li>故障转移：自动将Slave提升为新Master</li><li>配置管理：为客户端提供服务发现</li></ul><p><strong>故障转移流程</strong>：</p><ol><li>哨兵发现Master下线（主观下线）</li><li>多个哨兵确认Master下线（客观下线）</li><li>选举领导哨兵执行故障转移</li><li>选择合适的Slave作为新Master</li><li>修改其他Slave的配置指向新Master</li><li>通知客户端Master地址变更</li></ol><h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p><p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p><p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p><p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p><p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p><h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p><p><strong>配置参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 10000  # 超过10毫秒记录</span><br><span class="line">slowlog-max-len 128           # 最多保存128条记录</span><br></pre></td></tr></table></figure><p><strong>查看慢查询</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         # 查看key占用内存</span><br><span class="line">MEMORY STATS            # 查看内存统计信息</span><br><span class="line">MEMORY DOCTOR           # 内存使用建议</span><br></pre></td></tr></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p><ul><li>单个key的value不要超过10KB</li><li>集合类型元素数量控制在合理范围</li><li>使用SCAN代替KEYS命令</li></ul><p><strong>合理使用数据结构</strong>：</p><ul><li>小对象使用Hash而不是多个String</li><li>合理设置ziplist等压缩结构的阈值</li><li>使用位图(bitmap)存储布尔类型大数据集</li></ul><p><strong>网络优化</strong>：</p><ul><li>使用Pipeline批量操作</li><li>合理设置客户端连接池</li><li>启用TCP_NODELAY选项</li></ul><p><strong>持久化优化</strong>：</p><ul><li>根据业务需求选择RDB或AOF</li><li>合理配置自动保存条件</li><li>在从节点上进行持久化操作</li></ul><p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p><h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p><p><strong>8种淘汰策略</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 针对所有key</span><br><span class="line">noeviction          # 不淘汰，写入返回错误</span><br><span class="line">allkeys-lru         # 所有key中淘汰最近最少使用</span><br><span class="line">allkeys-lfu         # 所有key中淘汰最少频率使用</span><br><span class="line">allkeys-random      # 所有key中随机淘汰</span><br><span class="line"></span><br><span class="line"># 针对设置了过期时间的key</span><br><span class="line">volatile-lru        # 过期key中淘汰最近最少使用</span><br><span class="line">volatile-lfu        # 过期key中淘汰最少频率使用</span><br><span class="line">volatile-random     # 过期key中随机淘汰</span><br><span class="line">volatile-ttl        # 过期key中淘汰即将过期的</span><br></pre></td></tr></table></figure><p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p><ul><li>每个key都有24位的时钟字段记录访问时间</li><li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li></ul><p>LFU算法维护访问频率：</p><ul><li>高16位存储上次访问时间</li><li>低8位存储访问频率计数器</li><li>计数器采用概率性递增，避免频率无限增长</li></ul><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p><ul><li>频繁的数据更新导致内存分配&#x2F;释放</li><li>Redis使用jemalloc内存分配器，存在内存对齐</li><li>删除大key后留下内存空洞</li></ul><p><strong>检测方法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注 mem_fragmentation_ratio 指标</span><br><span class="line"># 比值 &gt; 1.5 表示碎片较多</span><br><span class="line"># 比值 &lt; 1 表示使用了swap，性能严重下降</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ol><li><strong>内存整理</strong>（Redis 4.0+）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag yes        # 开启自动整理</span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  # 碎片率超过10%启动</span><br><span class="line">MEMORY PURGE                       # 手动触发整理</span><br></pre></td></tr></table></figure><ol><li><strong>重启Redis</strong>：最彻底但影响服务可用性</li><li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li></ol><h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p><ul><li>优点：及时释放内存</li><li>缺点：消耗CPU资源创建和管理定时器</li></ul><p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p><ul><li>优点：CPU友好，只在必要时删除</li><li>缺点：内存不友好，过期key可能长期占用内存</li></ul><p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p><ul><li>Redis的实际策略，平衡CPU和内存使用</li></ul><h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 简化的过期删除逻辑</span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    static int current_db = 0;</span><br><span class="line">    static int timelimit_exit = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        int iteration = 0;</span><br><span class="line">        while (iteration &lt; 20) &#123;  // 最多检查20个key</span><br><span class="line">            long sampled = 0, expired = 0;</span><br><span class="line">            </span><br><span class="line">            // 随机选择key检查过期</span><br><span class="line">            for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                if (de == NULL) break;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                if (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果过期比例超过25%，继续下轮检查</span><br><span class="line">            if (expired &gt; 5) iteration++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p><p><strong>ZipList问题</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ZipList结构导致的级联更新</span><br><span class="line">// 当插入元素导致某个entry的长度改变时</span><br><span class="line">// 可能引起后续所有entry的重新编码</span><br></pre></td></tr></table></figure><p><strong>ListPack优势</strong>：</p><ul><li>每个元素独立编码，避免级联更新</li><li>支持从尾部遍历，提高某些操作效率</li></ul><h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 渐进式rehash实现</span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n * 10;</span><br><span class="line">    </span><br><span class="line">    if (!dictIsRehashing(d)) return 0;</span><br><span class="line">    </span><br><span class="line">    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</span><br><span class="line">        // 跳过空桶</span><br><span class="line">        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            if (--empty_visits == 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 迁移桶中所有元素</span><br><span class="line">        dictEntry *de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br><span class="line">        while (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned int h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[1].table[h];</span><br><span class="line">            d-&gt;ht[1].table[h] = de;</span><br><span class="line">            d-&gt;ht[0].used--;</span><br><span class="line">            d-&gt;ht[1].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 多线程I/O处理流程</span><br><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 等待主线程分配任务</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        while (io_threads_list[id] &amp;&amp; io_threads_pending[id] == 0) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理读写任务</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        while ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            if (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, 0);</span><br><span class="line">            &#125; else if (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Jedis连接池配置</span><br><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(200);                    // 最大连接数</span><br><span class="line">config.setMaxIdle(50);                      // 最大空闲连接</span><br><span class="line">config.setMinIdle(10);                      // 最小空闲连接</span><br><span class="line">config.setTestOnBorrow(true);               // 获取连接时测试</span><br><span class="line">config.setTestOnReturn(true);               // 归还连接时测试</span><br><span class="line">config.setTestWhileIdle(true);              // 空闲时测试</span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(30000);  // 检查间隔</span><br><span class="line">config.setNumTestsPerEvictionRun(10);       // 每次检查连接数</span><br><span class="line">config.setMinEvictableIdleTimeMillis(60000);     // 最小空闲时间</span><br><span class="line"></span><br><span class="line">JedisPool pool = new JedisPool(config, &quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure><p><strong>Pipeline优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pipeline批量操作</span><br><span class="line">public void batchSet(Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        // 处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p><p><strong>实现原理</strong>：</p><ul><li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li><li>使用调和平均数减少误差</li><li>适用于UV统计等场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 网站UV统计</span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    # 获取UV数量</span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  # 合并多日数据</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis布隆过滤器模块</span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       # 创建过滤器，误报率0.01%，预期元素100万</span><br><span class="line">BF.ADD myfilter &quot;user123&quot;              # 添加元素</span><br><span class="line">BF.EXISTS myfilter &quot;user123&quot;           # 检查元素是否存在</span><br><span class="line">BF.MADD myfilter item1 item2 item3     # 批量添加</span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  # 批量检查</span><br></pre></td></tr></table></figure><h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加地理位置</span><br><span class="line">GEOADD cities 116.397128 39.916527 &quot;北京&quot; 121.473701 31.230416 &quot;上海&quot;</span><br><span class="line"></span><br><span class="line"># 计算距离</span><br><span class="line">GEODIST cities &quot;北京&quot; &quot;上海&quot; km</span><br><span class="line"></span><br><span class="line"># 范围查询</span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"># 根据成员查询</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;北京&quot; 1000 km</span><br></pre></td></tr></table></figure><h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法：直接拼接用户输入</span><br><span class="line">String key = &quot;user:&quot; + userInput;  // userInput可能包含恶意命令</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot; + key + &quot;&#x27;)&quot;, 0);</span><br><span class="line"></span><br><span class="line">// 正确做法：使用参数化查询</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;, 1, key);</span><br></pre></td></tr></table></figure><p><strong>未授权访问</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf安全配置</span><br><span class="line">bind 127.0.0.1                        # 绑定指定IP</span><br><span class="line">requirepass your_password              # 设置密码</span><br><span class="line">protected-mode yes                     # 开启保护模式</span><br><span class="line">port 0                                # 禁用默认端口</span><br><span class="line">port 6380                             # 使用非标准端口</span><br></pre></td></tr></table></figure><p><strong>危险命令禁用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重命名危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;             # 禁用FLUSHDB</span><br><span class="line">rename-command FLUSHALL &quot;&quot;            # 禁用FLUSHALL</span><br><span class="line">rename-command SHUTDOWN &quot;REDIS_SHUTDOWN&quot;  # 重命名SHUTDOWN</span><br><span class="line">rename-command CONFIG &quot;REDIS_CONFIG&quot;   # 重命名CONFIG</span><br></pre></td></tr></table></figure><h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +set</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"># 检查权限</span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure><h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过INFO命令获取</span><br><span class="line">INFO stats</span><br><span class="line"># 关注指标：</span><br><span class="line"># - instantaneous_ops_per_sec: QPS</span><br><span class="line"># - keyspace_hits/keyspace_misses: 命中率</span><br><span class="line"># - used_cpu_sys/used_cpu_user: CPU使用率</span><br><span class="line"># - connected_clients: 连接数</span><br><span class="line"># - blocked_clients: 阻塞连接数</span><br></pre></td></tr></table></figure><p><strong>内存指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注指标：</span><br><span class="line"># - used_memory: 已使用内存</span><br><span class="line"># - used_memory_rss: 物理内存占用</span><br><span class="line"># - mem_fragmentation_ratio: 内存碎片率</span><br><span class="line"># - used_memory_peak: 内存使用峰值</span><br></pre></td></tr></table></figure><p><strong>持久化指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"># 关注指标：</span><br><span class="line"># - rdb_last_save_time: 最后RDB保存时间</span><br><span class="line"># - aof_last_rewrite_time_sec: AOF重写耗时</span><br><span class="line"># - aof_current_size: AOF文件大小</span><br></pre></td></tr></table></figure><h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接信息</span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"># 慢查询分析</span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"># 大key查找</span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"># 热点key分析</span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"># 延迟监控</span><br><span class="line">LATENCY HISTORY command</span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure><h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRateLimiter &#123;</span><br><span class="line">    public boolean isAllowed(String key, int limit, int window) &#123;</span><br><span class="line">        long current = System.currentTimeMillis() / 1000 / window;</span><br><span class="line">        String windowKey = key + &quot;:&quot; + current;</span><br><span class="line">        </span><br><span class="line">        String script = </span><br><span class="line">            &quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot; +</span><br><span class="line">            &quot;if count == 1 then &quot; +</span><br><span class="line">            &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot; +</span><br><span class="line">            &quot;end &quot; +</span><br><span class="line">            &quot;return count&quot;;</span><br><span class="line">            </span><br><span class="line">        Long count = (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        return count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean slidingWindowLimit(String key, int limit, int window) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long windowStart = now - window * 1000;</span><br><span class="line">    </span><br><span class="line">    String script = </span><br><span class="line">        &quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">        &quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;if count &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot; +</span><br><span class="line">        &quot;  return 1 &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    Long result = (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    return result == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisSessionManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public void createSession(String sessionId, String userId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = new HashMap&lt;&gt;();</span><br><span class="line">        sessionData.put(&quot;userId&quot;, userId);</span><br><span class="line">        sessionData.put(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isValidSession(String sessionId) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void renewSession(String sessionId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        if (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedisQueue &#123;</span><br><span class="line">    // 生产者</span><br><span class="line">    public void produce(String queue, String message) &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者（阻塞式）</span><br><span class="line">    public String consume(String queue, int timeout) &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        return result != null ? result.get(1) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生产消息</span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line"># 创建消费者组</span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"># 确认消息</span><br><span class="line">XACK mystream mygroup message_id</span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDelayQueue &#123;</span><br><span class="line">    </span><br><span class="line">    public void addDelayTask(String task, long delayTime) &#123;</span><br><span class="line">        long executeTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(&quot;delay_queue&quot;, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; getReadyTasks() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(&quot;delay_queue&quot;, 0, now);</span><br><span class="line">        </span><br><span class="line">        if (!tasks.isEmpty()) &#123;</span><br><span class="line">            // 原子性删除已获取的任务</span><br><span class="line">            String script = </span><br><span class="line">                &quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;if #tasks &gt; 0 then &quot; +</span><br><span class="line">                &quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;end &quot; +</span><br><span class="line">                &quot;return tasks&quot;;</span><br><span class="line">            </span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(&quot;delay_queue&quot;), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐：为每个用户字段单独设置key</span><br><span class="line">jedis.set(&quot;user:1001:name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:email&quot;, &quot;zhang@example.com&quot;);</span><br><span class="line"></span><br><span class="line">// 推荐：使用Hash存储</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;email&quot;, &quot;zhang@example.com&quot;);</span><br></pre></td></tr></table></figure><p><strong>合理设置过期时间</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免同时过期导致雪崩</span><br><span class="line">int baseExpire = 3600;  // 1小时</span><br><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 增加0-5分钟随机时间</span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用Pipeline</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    pipeline.set(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line">// 或使用原生批量命令</span><br><span class="line">Map&lt;String, String&gt; batch = new HashMap&lt;&gt;();</span><br><span class="line">// ... 填充数据</span><br><span class="line">jedis.mset(flattenMap(batch));</span><br></pre></td></tr></table></figure><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="line">if current == false then</span><br><span class="line">    return -1  -- key不存在</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">current = tonumber(current)</span><br><span class="line">if current &gt;= tonumber(ARGV[1]) then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span><br><span class="line">    return current - tonumber(ARGV[1])</span><br><span class="line">else</span><br><span class="line">    return -2  -- 库存不足</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>你好，我很乐意为你详细讲解 Redis。</p><p>Redis 是一个开源的、基于内存的、高性能的键值存储系统。它通常被用作数据库、缓存和消息中间件。Redis 支持多种数据结构，如字符串、哈希、列表、集合和有序集合，这使得它在各种应用场景中都非常灵活。</p><h3 id="Redis-的核心特点"><a href="#Redis-的核心特点" class="headerlink" title="Redis 的核心特点"></a>Redis 的核心特点</h3><hr><ul><li><strong>高性能</strong>: Redis 的所有数据都存储在内存中，因此读写速度非常快。通常，单个 Redis 实例每秒能处理超过 10 万次读写操作。</li><li><strong>丰富的数据结构</strong>: Redis 不仅仅是简单的键值存储，它支持多种复杂的数据结构，这让它能满足更广泛的应用需求。</li><li><strong>持久化</strong>: 虽然 Redis 是基于内存的，但它提供了两种不同的持久化方式，可以将数据从内存中保存到磁盘上，以防止服务器重启后数据丢失。</li><li><strong>原子性</strong>: Redis 的所有操作都是原子性的。这意味着一个命令要么完全执行，要么根本不执行，中间不会被打断，这在多客户端并发访问时尤其重要。</li><li><strong>主从复制</strong>: Redis 支持主从复制，可以将数据从一个主节点（Master）同步到一个或多个从节点（Slave），从而实现数据的备份和读写分离，提高系统的可用性和扩展性。</li><li><strong>高可用性与集群</strong>: Redis 提供了 Sentinel（哨兵）和 Cluster（集群）两种方案，来保证系统的高可用性和扩展性。</li></ul><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr><p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul><li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li><li><strong>常用命令</strong>:<ul><li><code>SET key value</code>: 设置键值对。</li><li><code>GET key</code>: 获取键对应的值。</li><li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li><li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li><li><code>MGET key1 key2</code>: 同时获取多个键的值。</li></ul></li><li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li></ul><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul><li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li><li><strong>常用命令</strong>:<ul><li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li><li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li><li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li><li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li><li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li></ul></li><li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li></ul><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul><li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li><li><strong>常用命令</strong>:<ul><li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li><li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li><li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li><li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li><li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li></ul></li><li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul><li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li><li><strong>常用命令</strong>:<ul><li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li><li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li><li><code>SINTER key1 key2</code>: 求两个集合的交集。</li><li><code>SUNION key1 key2</code>: 求两个集合的并集。</li></ul></li><li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li></ul><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul><li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li><li><strong>常用命令</strong>:<ul><li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li><li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li><li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li><li><code>ZSCORE key member</code>: 获取一个成员的分数。</li><li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li></ul></li><li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li></ul><h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr><p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p><h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul><li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li><li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li><li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li></ul><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul><li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li><li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li><li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li></ul><p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p><h3 id="Redis-的高可用性"><a href="#Redis-的高可用性" class="headerlink" title="Redis 的高可用性"></a>Redis 的高可用性</h3><hr><h4 id="1-主从复制-Replication"><a href="#1-主从复制-Replication" class="headerlink" title="1. 主从复制 (Replication)"></a>1. 主从复制 (Replication)</h4><ul><li><strong>基本原理</strong>: 将一个 Redis 实例（主节点）的数据复制到一个或多个其他实例（从节点）。从节点的数据是主节点的完整副本。</li><li><strong>作用</strong>:<ul><li><strong>数据备份</strong>: 从节点可以作为数据的热备份。</li><li><strong>读写分离</strong>: 大多数读操作可以分流到从节点上，减轻主节点的压力。</li></ul></li></ul><h4 id="2-Sentinel-哨兵"><a href="#2-Sentinel-哨兵" class="headerlink" title="2. Sentinel (哨兵)"></a>2. Sentinel (哨兵)</h4><ul><li><strong>作用</strong>: 自动化管理主从复制集群。它是一个监控系统，可以监控主节点和从节点是否正常运行。</li><li><strong>核心功能</strong>:<ul><li><strong>监控</strong>: 不断检查主从节点是否正常工作。</li><li><strong>通知</strong>: 当某个 Redis 实例出现问题时，会发送通知。</li><li><strong>故障转移</strong>: 如果主节点发生故障，Sentinel 会自动从剩下的从节点中选举一个新的主节点，并让其他从节点切换到这个新的主节点上，从而实现高可用。</li></ul></li></ul><h4 id="3-Redis-Cluster-集群"><a href="#3-Redis-Cluster-集群" class="headerlink" title="3. Redis Cluster (集群)"></a>3. Redis Cluster (集群)</h4><ul><li><strong>作用</strong>: 解决 Redis 单机内存容量和并发量的瓶颈问题。它将数据分散到多个节点上，每个节点只负责存储部分数据。</li><li><strong>核心功能</strong>:<ul><li><strong>数据分片</strong>: 自动将数据分布在多个节点上。</li><li><strong>高可用性</strong>: 即使部分节点宕机，集群也能继续正常工作。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-Spring-Cloud-体系&quot;&gt;&lt;a href=&quot;#1-Spring-Cloud-体系&quot; class=&quot;headerlink&quot; title=&quot;1. Spring Cloud 体系&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. Spring Cloud 体系&lt;/strong</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="分布式微服务" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>命令大全</title>
    <link href="http://example.com/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-16T05:22:31.602Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="📌-一、Linux-常见命令大全"><a href="#📌-一、Linux-常见命令大全" class="headerlink" title="📌 一、Linux 常见命令大全"></a>📌 一、Linux 常见命令大全</h1><h3 id="🔹-文件与目录操作"><a href="#🔹-文件与目录操作" class="headerlink" title="🔹 文件与目录操作"></a>🔹 文件与目录操作</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td><td><code>ls -al</code> 显示隐藏文件和详细信息</td></tr><tr><td><code>pwd</code></td><td>显示当前目录</td><td><code>pwd</code></td></tr><tr><td><code>cd</code></td><td>切换目录</td><td><code>cd /usr/local</code></td></tr><tr><td><code>mkdir</code></td><td>创建目录</td><td><code>mkdir -p /data/logs</code></td></tr><tr><td><code>rmdir</code></td><td>删除空目录</td><td><code>rmdir old</code></td></tr><tr><td><code>rm</code></td><td>删除文件&#x2F;目录</td><td><code>rm -rf /tmp/test</code></td></tr><tr><td><code>cp</code></td><td>复制文件&#x2F;目录</td><td><code>cp a.txt /tmp/</code>，<code>cp -r dir1 dir2</code></td></tr><tr><td><code>mv</code></td><td>移动&#x2F;重命名</td><td><code>mv old.txt new.txt</code></td></tr><tr><td><code>find</code></td><td>查找文件</td><td><code>find / -name &quot;*.log&quot;</code></td></tr><tr><td><code>locate</code></td><td>快速查找文件（需 <code>updatedb</code>）</td><td><code>locate nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-文件查看与编辑"><a href="#🔹-文件查看与编辑" class="headerlink" title="🔹 文件查看与编辑"></a>🔹 文件查看与编辑</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>cat</code></td><td>查看文件内容</td><td><code>cat file.txt</code></td></tr><tr><td><code>tac</code></td><td>反向输出</td><td><code>tac file.txt</code></td></tr><tr><td><code>less</code></td><td>分页查看</td><td><code>less /var/log/syslog</code></td></tr><tr><td><code>head</code></td><td>查看前 N 行</td><td><code>head -n 20 file.log</code></td></tr><tr><td><code>tail</code></td><td>查看末尾 N 行</td><td><code>tail -f app.log</code> 实时跟踪</td></tr><tr><td><code>wc</code></td><td>统计行、字数、字符数</td><td><code>wc -l file.txt</code></td></tr><tr><td><code>nano/vim</code></td><td>编辑文件</td><td><code>vim nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-用户与权限"><a href="#🔹-用户与权限" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>whoami</code></td><td>当前用户</td><td><code>whoami</code></td></tr><tr><td><code>id</code></td><td>用户 ID 和组 ID</td><td><code>id root</code></td></tr><tr><td><code>useradd</code></td><td>新建用户</td><td><code>useradd -m testuser</code></td></tr><tr><td><code>passwd</code></td><td>修改密码</td><td><code>passwd testuser</code></td></tr><tr><td><code>su</code></td><td>切换用户</td><td><code>su - testuser</code></td></tr><tr><td><code>sudo</code></td><td>以 root 权限执行</td><td><code>sudo apt update</code></td></tr><tr><td><code>chmod</code></td><td>修改权限</td><td><code>chmod 755 file.sh</code></td></tr><tr><td><code>chown</code></td><td>修改属主</td><td><code>chown user:group file.txt</code></td></tr></tbody></table><hr><h3 id="🔹-系统管理"><a href="#🔹-系统管理" class="headerlink" title="🔹 系统管理"></a>🔹 系统管理</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程</td><td>&#96;ps -ef</td></tr><tr><td><code>top</code></td><td>实时查看进程</td><td><code>top</code></td></tr><tr><td><code>htop</code></td><td>高级 top（需安装）</td><td><code>htop</code></td></tr><tr><td><code>kill</code></td><td>杀进程</td><td><code>kill -9 1234</code></td></tr><tr><td><code>df -h</code></td><td>查看磁盘使用</td><td><code>df -h</code></td></tr><tr><td><code>du -sh</code></td><td>查看目录大小</td><td><code>du -sh /var/log</code></td></tr><tr><td><code>free -h</code></td><td>查看内存使用</td><td><code>free -h</code></td></tr><tr><td><code>uptime</code></td><td>系统运行时长</td><td><code>uptime</code></td></tr><tr><td><code>uname -a</code></td><td>系统信息</td><td><code>uname -a</code></td></tr><tr><td><code>shutdown -h now</code></td><td>立刻关机</td><td><code>shutdown -r now</code> 重启</td></tr></tbody></table><hr><h3 id="🔹-网络相关"><a href="#🔹-网络相关" class="headerlink" title="🔹 网络相关"></a>🔹 网络相关</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试网络连通</td><td><code>ping www.baidu.com</code></td></tr><tr><td><code>curl</code></td><td>请求 URL</td><td><code>curl -I https://www.baidu.com</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget http://example.com/file.zip</code></td></tr><tr><td><code>netstat -tulnp</code></td><td>查看端口占用</td><td>&#96;netstat -tulnp</td></tr><tr><td><code>ss -lntp</code></td><td>更快的端口查询</td><td><code>ss -lntp</code></td></tr><tr><td><code>scp</code></td><td>远程拷贝文件</td><td><code>scp file.txt user@host:/path/</code></td></tr><tr><td><code>ssh</code></td><td>登录远程主机</td><td><code>ssh user@192.168.1.1</code></td></tr></tbody></table><hr><h1 id="📌-二、MySQL-常见命令大全"><a href="#📌-二、MySQL-常见命令大全" class="headerlink" title="📌 二、MySQL 常见命令大全"></a>📌 二、MySQL 常见命令大全</h1><h3 id="🔹-登录与基本操作"><a href="#🔹-登录与基本操作" class="headerlink" title="🔹 登录与基本操作"></a>🔹 登录与基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p               <span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p   <span class="comment"># 指定地址端口</span></span><br><span class="line"><span class="built_in">exit</span>;                          <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据库操作"><a href="#🔹-数据库操作" class="headerlink" title="🔹 数据库操作"></a>🔹 数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;                <span class="comment">-- 查看所有数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE testdb;        <span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE testdb;          <span class="comment">-- 删除数据库</span></span><br><span class="line">USE testdb;                    <span class="comment">-- 切换数据库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-表操作"><a href="#🔹-表操作" class="headerlink" title="🔹 表操作"></a>🔹 表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;                               <span class="comment">-- 查看表</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> users;                            <span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);                                         <span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;                          <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> email <span class="type">VARCHAR</span>(<span class="number">100</span>);  <span class="comment">-- 增加列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;       <span class="comment">-- 删除列</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据操作-CRUD"><a href="#🔹-数据操作-CRUD" class="headerlink" title="🔹 数据操作 (CRUD)"></a>🔹 数据操作 (CRUD)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users(name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>);  <span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;                             <span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;      <span class="comment">-- 条件查询</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;    <span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;            <span class="comment">-- 删除</span></span><br></pre></td></tr></table></figure><h3 id="🔹-用户与权限-1"><a href="#🔹-用户与权限-1" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;       <span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;      <span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;   <span class="comment">-- 回收权限</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;                                <span class="comment">-- 删除用户</span></span><br><span class="line">FLUSH PRIVILEGES;                                    <span class="comment">-- 刷新权限</span></span><br></pre></td></tr></table></figure><h3 id="🔹-备份与恢复"><a href="#🔹-备份与恢复" class="headerlink" title="🔹 备份与恢复"></a>🔹 备份与恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p testdb &gt; testdb.sql     <span class="comment"># 导出数据库</span></span><br><span class="line">mysqldump -u root -p --all-databases &gt; all.sql</span><br><span class="line">mysql -u root -p testdb &lt; testdb.sql         <span class="comment"># 导入数据库</span></span><br></pre></td></tr></table></figure><hr><h1 id="📌-三、Git-常见命令大全"><a href="#📌-三、Git-常见命令大全" class="headerlink" title="📌 三、Git 常见命令大全"></a>📌 三、Git 常见命令大全</h1><h3 id="🔹-基础配置"><a href="#🔹-基础配置" class="headerlink" title="🔹 基础配置"></a>🔹 基础配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;YourName&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --list       <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure><h3 id="🔹-仓库操作"><a href="#🔹-仓库操作" class="headerlink" title="🔹 仓库操作"></a>🔹 仓库操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init                          <span class="comment"># 初始化仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xxx.git  <span class="comment"># 克隆仓库</span></span><br><span class="line">git remote -v                     <span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote add origin git@github.com:xxx.git  <span class="comment"># 添加远程仓库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-文件操作"><a href="#🔹-文件操作" class="headerlink" title="🔹 文件操作"></a>🔹 文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status        <span class="comment"># 查看状态</span></span><br><span class="line">git add file.txt  <span class="comment"># 添加文件</span></span><br><span class="line">git add .         <span class="comment"># 添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;描述&quot;</span>   <span class="comment"># 提交</span></span><br><span class="line">git diff          <span class="comment"># 查看修改</span></span><br><span class="line">git <span class="built_in">log</span>           <span class="comment"># 查看提交历史</span></span><br><span class="line">git reset --hard HEAD^   <span class="comment"># 回退上一个版本</span></span><br></pre></td></tr></table></figure><h3 id="🔹-分支操作"><a href="#🔹-分支操作" class="headerlink" title="🔹 分支操作"></a>🔹 分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                  <span class="comment"># 查看分支</span></span><br><span class="line">git branch new-feature      <span class="comment"># 新建分支</span></span><br><span class="line">git checkout new-feature    <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b dev         <span class="comment"># 新建并切换</span></span><br><span class="line">git merge dev               <span class="comment"># 合并分支</span></span><br><span class="line">git branch -d dev           <span class="comment"># 删除分支</span></span><br></pre></td></tr></table></figure><h3 id="🔹-远程仓库"><a href="#🔹-远程仓库" class="headerlink" title="🔹 远程仓库"></a>🔹 远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main        <span class="comment"># 拉取代码</span></span><br><span class="line">git push origin main        <span class="comment"># 推送代码</span></span><br><span class="line">git push -u origin main     <span class="comment"># 关联远程分支并推送</span></span><br><span class="line">git fetch origin            <span class="comment"># 获取最新分支信息</span></span><br></pre></td></tr></table></figure><h3 id="🔹-标签管理"><a href="#🔹-标签管理" class="headerlink" title="🔹 标签管理"></a>🔹 标签管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0                        <span class="comment"># 打标签</span></span><br><span class="line">git tag                             <span class="comment"># 查看标签</span></span><br><span class="line">git push origin v1.0                <span class="comment"># 推送标签</span></span><br><span class="line">git push origin --tags              <span class="comment"># 推送所有标签</span></span><br><span class="line">git tag -d v1.0                     <span class="comment"># 删除本地标签</span></span><br><span class="line">git push origin :refs/tags/v1.0     <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;📌-一、Linux-常见命令大全&quot;&gt;&lt;a href=&quot;#📌-一、Linux-常见命令大全&quot; class=&quot;headerlink&quot; title=&quot;📌 一、Linux 常见命令大全&quot;&gt;&lt;/a&gt;📌 一、Linux 常见命令大全&lt;/h1&gt;&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="命令" scheme="http://example.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>手写答案</title>
    <link href="http://example.com/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/"/>
    <id>http://example.com/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-16T05:19:43.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-实现单例模式-Singleton-Pattern"><a href="#1-实现单例模式-Singleton-Pattern" class="headerlink" title="1.实现单例模式 (Singleton Pattern)"></a>1.实现单例模式 (Singleton Pattern)</h3><h4 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h4><p>使用<strong>双重检查锁定 (DCL)</strong> 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接 new 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个全局访问点，使用 DCL 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果实例已经存在，直接返回，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次检查失败，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：在同步块内部再次检查，防止多个线程同时通过第一次检查，</span></span><br><span class="line">                <span class="comment">// 导致创建多个实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的懒汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 在类加载时就创建静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的饿汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-继承与多态-Inheritance-and-Polymorphism"><a href="#2-继承与多态-Inheritance-and-Polymorphism" class="headerlink" title="2.继承与多态 (Inheritance and Polymorphism)"></a>2.继承与多态 (Inheritance and Polymorphism)</h3><p>设计一个 <code>Animal</code> 抽象类，并创建 <code>Dog</code> 和 <code>Cat</code> 类来展示继承和多态。&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Animal 抽象类，定义通用行为</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Dog 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗正在吃骨头。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Cat 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫正在吃鱼。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 展示多态的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，这就是多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相同的方法，但由于指向不同的子类实例，执行不同的行为</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出: 狗正在吃骨头。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出: 猫正在吃鱼。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals() 和 hashCode()"></a><code>equals()</code> 和 <code>hashCode()</code></h3><p>编写 <code>Student</code> 类，并重写 <code>equals()</code> 和 <code>hashCode()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals() 方法，根据 id 和 name 判断两个 Student 对象是否相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 检查对象是否为 null 或类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 类型转换</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 4. 比较关键字段 (id 和 name)</span></span><br><span class="line">        <span class="keyword">return</span> id == student.id &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，为相等的对象生成相同的哈希码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 方法生成哈希码，它会为多个字段生成一个组合哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为什么需要两者一起重写？</span></span><br><span class="line"><span class="comment">* 1. 它们之间存在约定：如果两个对象通过 equals() 方法比较是相等的，那么它们的 hashCode() 方法返回的值也必须相等。</span></span><br><span class="line"><span class="comment">* 反之则不一定，不相等的对象可以有相同的哈希码（哈希冲突）。</span></span><br><span class="line"><span class="comment">* 2. 哈希表类（如 HashSet, HashMap）依赖于这个约定：当将对象存入哈希表时，</span></span><br><span class="line"><span class="comment">* 它会先调用 hashCode() 确定存储位置，再调用 equals() 来确认是否存在相同的对象。</span></span><br><span class="line"><span class="comment">* 3. 如果只重写 equals() 但不重写 hashCode()，可能导致两个逻辑上相等的对象被存储在不同的哈希位置，</span></span><br><span class="line"><span class="comment">* 从而无法正确查找和去重。例如，在 HashSet 中，即使两个 Student 对象 id 和 name 相同，</span></span><br><span class="line"><span class="comment">* 也会被认为是不同的对象而重复添加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="接口与实现-Interfaces-and-Implementation"><a href="#接口与实现-Interfaces-and-Implementation" class="headerlink" title="接口与实现 (Interfaces and Implementation)"></a>接口与实现 (Interfaces and Implementation)</h3><p>设计 <code>Drawable</code> 接口，并由 <code>Circle</code> 和 <code>Rectangle</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Drawable 接口，包含一个抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Circle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个圆形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Rectangle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个矩形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理 (Exception Handling)"></a>异常处理 (Exception Handling)</h3><p>使用 <code>try-catch-finally</code> 结构处理 <code>FileNotFoundException</code> 并确保资源关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 在 try 块外部声明，以便在 finally 块中访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，finally 块都会执行</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保文件流被关闭，防止资源泄露</span></span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件流已在 finally 块中关闭。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>使用 <code>try-with-resources</code> 重写上一个题目，展示其简化优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryWithResourcesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFileWithResources</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// try-with-resources 语句，自动管理实现了 AutoCloseable 接口的资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件关闭时可能发生的异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要单独的 finally 块来关闭资源，JVM 会自动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件流已在 try-with-resources 语句中自动关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try-with-resources 的优势：</span></span><br><span class="line"><span class="comment">* 1. 简化代码：不再需要显式的 finally 块来关闭资源，代码更简洁。</span></span><br><span class="line"><span class="comment">* 2. 避免资源泄露：无论 try 块是否正常完成或抛出异常，资源都会被自动关闭，</span></span><br><span class="line"><span class="comment">* 有效防止了因忘记关闭资源而导致的内存和文件句柄泄露。</span></span><br><span class="line"><span class="comment">* 3. 更好的异常处理：如果 try 块和资源关闭时都抛出异常，try-with-resources 会</span></span><br><span class="line"><span class="comment">* 将资源关闭时抛出的异常作为被抑制（suppressed）的异常，主异常保持不变，</span></span><br><span class="line"><span class="comment">* 便于调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 外层循环控制比较轮数，共进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 优化：如果在某一轮没有发生交换，说明数组已经有序</span></span><br><span class="line">            <span class="comment">// 内层循环负责每轮比较和交换，将最大元素“冒”到数组末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换元素</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果没有发生交换，提前结束排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找到基准元素的正确位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            <span class="comment">// 递归地对左子数组进行排序</span></span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归地对右子数组进行排序</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (low - <span class="number">1</span>); <span class="comment">// i 指向小于等于基准的元素的最后一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 (Binary Search)"></a>二分查找 (Binary Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止整数溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 找到目标，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标在右半部分，更新左边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标在左半部分，更新右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 没有找到目标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表反转-Reverse-Linked-List"><a href="#链表反转-Reverse-Linked-List" class="headerlink" title="链表反转 (Reverse Linked List)"></a>链表反转 (Reverse Linked List)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head; <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            current.next = prev; <span class="comment">// 将当前节点的指针指向前一个节点</span></span><br><span class="line">            prev = current; <span class="comment">// 前一个节点向前移动</span></span><br><span class="line">            current = nextTemp; <span class="comment">// 当前节点向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 最终会是新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表中间节点-Middle-of-Linked-List"><a href="#链表中间节点-Middle-of-Linked-List" class="headerlink" title="链表中间节点 (Middle of Linked List)"></a>链表中间节点 (Middle of Linked List)</h3><p>使用<strong>快慢指针</strong>，快指针每次走两步，慢指针每次走一步。当快指针到达链表末尾时，慢指针正好在中间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findMiddleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head; <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; <span class="comment">// 快指针，每次走两步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当快指针到达末尾时，慢指针正好在中间</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="移除重复元素-Remove-Duplicates"><a href="#移除重复元素-Remove-Duplicates" class="headerlink" title="移除重复元素 (Remove Duplicates)"></a>移除重复元素 (Remove Duplicates)</h3><p>不使用 <code>Set</code>，通过双层循环或排序后遍历实现。这里使用排序后遍历的方法，因为它更高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeDuplicates</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list); <span class="comment">// 先排序，使得重复元素相邻</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历，移除重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).equals(list.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                list.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串反转-Reverse-String"><a href="#字符串反转-Reverse-String" class="headerlink" title="字符串反转 (Reverse String)"></a>字符串反转 (Reverse String)</h3><p>不使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 的 <code>reverse()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 交换首尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[left];</span><br><span class="line">            charArray[left] = charArray[right];</span><br><span class="line">            charArray[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="回文字符串-Palindrome-String"><a href="#回文字符串-Palindrome-String" class="headerlink" title="回文字符串 (Palindrome String)"></a>回文字符串 (Palindrome String)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将字符串转换为小写并移除非字母数字字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cleanedStr</span> <span class="operator">=</span> str.toLowerCase().replaceAll(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cleanedStr.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanedStr.charAt(left) != cleanedStr.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="计算阶乘-Factorial-Calculation"><a href="#计算阶乘-Factorial-Calculation" class="headerlink" title="计算阶乘 (Factorial Calculation)"></a>计算阶乘 (Factorial Calculation)</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorialRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factorial is not defined for negative numbers.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorialRecursive(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MathProblems &#123;</span><br><span class="line">    public static long factorialIterative(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Factorial is not defined for negative numbers.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        long result = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="斐波那契数列-Fibonacci-Sequence"><a href="#斐波那契数列-Fibonacci-Sequence" class="headerlink" title="斐波那契数列 (Fibonacci Sequence)"></a>斐波那契数列 (Fibonacci Sequence)</h3><h4 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciRecursive(n - <span class="number">1</span>) + fibonacciRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciIterative</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串中字符计数-Character-Count"><a href="#字符串中字符计数-Character-Count" class="headerlink" title="字符串中字符计数 (Character Count)"></a>字符串中字符计数 (Character Count)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">countCharacters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> charCountMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            charCountMap.put(c, charCountMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charCountMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 (Two Sum)"></a>两数之和 (Two Sum)</h3><p>使用 <code>HashMap</code> 将值和索引存储起来，实现一次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (numMap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numMap.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组中最大-小值-Max-Min-in-Array"><a href="#数组中最大-小值-Max-Min-in-Array" class="headerlink" title="数组中最大&#x2F;小值 (Max&#x2F;Min in Array)"></a>数组中最大&#x2F;小值 (Max&#x2F;Min in Array)</h3><p>一次遍历找到最大值和最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxMin(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array cannot be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;max, min&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="质数判断-Prime-Number"><a href="#质数判断-Prime-Number" class="headerlink" title="质数判断 (Prime Number)"></a>质数判断 (Prime Number)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 和更小的数都不是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只需要检查到 n 的平方根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="集合交集-List-Intersection"><a href="#集合交集-List-Intersection" class="headerlink" title="集合交集 (List Intersection)"></a>集合交集 (List Intersection)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">intersection</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> &#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历第一个列表，检查元素是否在第二个列表中</span></span><br><span class="line">        <span class="keyword">for</span> (T element : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list2.contains(element) &amp;&amp; !result.contains(element)) &#123;</span><br><span class="line">                result.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组合并-Merge-Sorted-Arrays"><a href="#数组合并-Merge-Sorted-Arrays" class="headerlink" title="数组合并 (Merge Sorted Arrays)"></a>数组合并 (Merge Sorted Arrays)</h3><p>将两个已排序的数组合并为一个新的已排序数组，使用<strong>双指针</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSortedArrays(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">                merged[k++] = arr1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged[k++] = arr2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length) &#123;</span><br><span class="line">            merged[k++] = arr1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr2.length) &#123;</span><br><span class="line">            merged[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断回文数-Palindrome-Number"><a href="#判断回文数-Palindrome-Number" class="headerlink" title="判断回文数 (Palindrome Number)"></a>判断回文数 (Palindrome Number)</h3><p>不使用 <code>String</code> 转换，通过数学方法反转一半数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindromeNumber</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 负数和以 0 结尾的非 0 数字都不是回文</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">reversedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; reversedNumber) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastDigit</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            reversedNumber = reversedNumber * <span class="number">10</span> + lastDigit;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数位数字时，x 等于 reversedNumber</span></span><br><span class="line">        <span class="comment">// 奇数位数字时，x 等于 reversedNumber 除以 10</span></span><br><span class="line">        <span class="keyword">return</span> x == reversedNumber || x == reversedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="罗马数字转整数-Roman-to-Integer"><a href="#罗马数字转整数-Roman-to-Integer" class="headerlink" title="罗马数字转整数 (Roman to Integer)"></a>罗马数字转整数 (Roman to Integer)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; romanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        romanMap.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVal</span> <span class="operator">=</span> romanMap.get(s.charAt(i));</span><br><span class="line">            <span class="comment">// 如果当前字符的值小于下一个字符的值，则需要减去当前值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.length() - <span class="number">1</span> &amp;&amp; currentVal &lt; romanMap.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                result -= currentVal;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += currentVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="爬楼梯-Climbing-Stairs"><a href="#爬楼梯-Climbing-Stairs" class="headerlink" title="爬楼梯 (Climbing Stairs)"></a>爬楼梯 (Climbing Stairs)</h3><p>这是经典的<strong>动态规划</strong>问题。</p><h4 id="动态规划方式-非递归"><a href="#动态规划方式-非递归" class="headerlink" title="动态规划方式 (非递归)"></a>动态规划方式 (非递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 爬 1 级台阶，有 1 种方法</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 爬 2 级台阶，有 2 种方法 (1+1, 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 到达第 i 级台阶的方法数 = (从 i-1 级爬 1 级的方法数) + (从 i-2 级爬 2 级的方法数)</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是基于  语言的线程基础与同步的实现，并附带详细注释。</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 <code>Thread</code> 类</h4><p>通过继承 <code>java.lang.Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用继承 Thread 类的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 <code>Runnable</code> 接口</h4><p>通过实现 <code>java.lang.Runnable</code> 接口并将其作为参数传递给 <code>Thread</code> 类的构造函数来创建线程。这种方式更灵活，推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用实现 Runnable 接口的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a><code>sleep()</code> 与 <code>yield()</code></h3><p><code>sleep()</code> 和 <code>yield()</code> 都是线程调度的方法，但它们的作用和效果不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepYieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 sleep() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep() 使线程暂停指定时间，进入 WAITING 状态，但不会释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 准备睡眠 2 秒...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 睡眠结束，继续执行。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 yield() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B: 正在执行 &quot;</span> + i);</span><br><span class="line">                <span class="comment">// yield() 提示线程调度器让出 CPU 时间，但不保证一定生效</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 执行完毕。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>sleep()</strong>: 使当前线程<strong>暂停执行指定的时间</strong>，进入 <strong>TIMED_WAITING</strong> 状态。它会<strong>释放 CPU 资源</strong>，但<strong>不释放锁</strong>。</li><li><strong>yield()</strong>: 提示线程调度器，当前线程愿意<strong>让出当前 CPU 时间片</strong>。线程会从 <strong>RUNNING</strong> 状态转换为 <strong>RUNNABLE</strong> 状态，与其他线程竞争 CPU，但<strong>不保证</strong>其他线程能立即获得执行。它主要用于优化线程调度，通常在多线程程序中<strong>不应依赖</strong>其行为来保证正确性。</li></ul><hr><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a><code>join()</code> 方法</h3><p><code>join()</code> 方法允许一个线程等待另一个线程执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 正在执行...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 执行完毕。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 join() 方法，主线程进入等待状态，直到 workerThread 执行完毕</span></span><br><span class="line">        workerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 子线程已执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="非线程安全计数器"><a href="#非线程安全计数器" class="headerlink" title="非线程安全计数器"></a>非线程安全计数器</h3><p>在多线程环境下，多个线程同时对共享资源进行读写操作，可能导致数据不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 这一行代码并非原子操作，它包含三个步骤：读、加 1、写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafetyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">UnsafeCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果不一定是 100 * 10000 = 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;非线程安全计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h3><p>使用 <code>synchronized</code> 关键字可以保证同一时刻只有一个线程访问共享资源，从而解决线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字修饰方法，锁住整个对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-块与方法"><a href="#synchronized-块与方法" class="headerlink" title="synchronized 块与方法"></a><code>synchronized</code> 块与方法</h3><ul><li><strong>synchronized 方法</strong>: 锁定的是当前对象实例 (<code>this</code>)。</li><li><strong>synchronized 块</strong>: 提供了更细粒度的控制，可以指定锁定的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 方法，锁定当前对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 synchronized 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开 synchronized 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 块，锁定指定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock1...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock1。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock1。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock2...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock2。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock2。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 区别与适用场景:</span></span><br><span class="line"><span class="comment"> * - synchronized 方法: 简单易用，但锁定范围大，可能导致性能问题。当需要同步整个方法时使用。</span></span><br><span class="line"><span class="comment"> * - synchronized 块: 锁定范围小，可以只同步需要保护的代码段，提高并发性能。当只需要同步部分代码时使用。</span></span><br><span class="line"><span class="comment"> * 同时，可以通过锁定不同的对象来避免不必要的阻塞，实现更高的并发度。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h3><p><code>volatile</code> 关键字保证了变量在多线程间的<strong>可见性</strong>，但不保证<strong>原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 保证所有线程看到的是该变量的最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 正在等待标志位变为 true。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 空循环，等待 ready 变为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 标志位已变为 true，循环结束。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保线程 A 先运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 正在将标志位设置为 true。&quot;</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为什么 volatile 不能保证原子性?</span></span><br><span class="line"><span class="comment"> * - 原子性是指一个操作是不可中断的，要么全部执行，要么都不执行。</span></span><br><span class="line"><span class="comment"> * - volatile 只能保证变量的读写操作是原子的，但像 `count++` 这样的复合操作（读、加、写）</span></span><br><span class="line"><span class="comment"> * 依然不是原子的。多个线程可能同时读到旧值，导致最终结果不正确。</span></span><br><span class="line"><span class="comment"> * - volatile 主要用于一写多读的场景，或者用于控制线程执行流程的标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><code>AtomicInteger</code></h3><p><code>AtomicInteger</code> 是一个原子类，它使用 CAS (Compare-and-Swap) 机制来保证操作的原子性，从而实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 替代 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 这是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现两个线程交替打印奇数和偶数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumbers</span> <span class="variable">pn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumbers</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printOdd, <span class="string">&quot;奇数线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printEven, <span class="string">&quot;偶数线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是  中高级并发编程的实现，并附带详细注释。</p><h3 id="生产者-消费者模式-使用-wait-和-notifyAll"><a href="#生产者-消费者模式-使用-wait-和-notifyAll" class="headerlink" title="生产者-消费者模式 (使用 wait() 和 notifyAll())"></a>生产者-消费者模式 (使用 <code>wait()</code> 和 <code>notifyAll()</code>)</h3><p>这是一个经典的线程协作问题。生产者生产数据，放入共享队列；消费者从队列中取出数据进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerClassic</span> &#123;</span><br><span class="line">    <span class="comment">// 共享队列，使用 LinkedList 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括消费者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括生产者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="生产者-消费者模式-使用-BlockingQueue"><a href="#生产者-消费者模式-使用-BlockingQueue" class="headerlink" title="生产者-消费者模式 (使用 BlockingQueue)"></a>生产者-消费者模式 (使用 <code>BlockingQueue</code>)</h3><p><code>java.util.concurrent.BlockingQueue</code> 接口提供了线程安全的队列操作，简化了生产者-消费者模型的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockingQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BlockingQueue，它内部已经处理了线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// put() 方法在队列满时会自动阻塞</span></span><br><span class="line">            queue.put(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// take() 方法在队列空时会自动阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>使用 <code>ReentrantLock</code> 实现线程安全计数器，并解释其与 <code>synchronized</code> 的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++; <span class="comment">// 在 try 块中执行需要同步的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 在 finally 块中释放锁，确保锁总是被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ReentrantLock 与 synchronized 的区别:</span></span><br><span class="line"><span class="comment">* 1. 语法层面: `synchronized` 是 JVM 的内置关键字，而 `ReentrantLock` 是一个类。</span></span><br><span class="line"><span class="comment">* 2. 灵活性: `ReentrantLock` 提供了更灵活的锁定控制。例如，它支持公平锁（按请求顺序获取锁），</span></span><br><span class="line"><span class="comment">* 可以尝试非阻塞地获取锁（`tryLock()`），以及支持中断（`lockInterruptibly()`）。</span></span><br><span class="line"><span class="comment">* 3. 性能: 在早期版本中，`ReentrantLock` 通常性能更好。但随着  对 `synchronized` 优化（偏向锁、轻量级锁），</span></span><br><span class="line"><span class="comment">* 两者性能已非常接近。在简单场景下，`synchronized` 更简洁。</span></span><br><span class="line"><span class="comment">* 4. 协作: `ReentrantLock` 必须配合 `Condition` 接口才能实现线程间的等待/唤醒机制，而 `synchronized` 直接</span></span><br><span class="line"><span class="comment">* 使用 `Object` 的 `wait()` 和 `notify()`。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock-与-Condition"><a href="#ReentrantLock-与-Condition" class="headerlink" title="ReentrantLock 与 Condition"></a><code>ReentrantLock</code> 与 <code>Condition</code></h3><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 重新实现生产者-消费者模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 创建两个 Condition 实例，分别用于生产者和消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    producerCondition.await(); <span class="comment">// 生产者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                consumerCondition.signalAll(); <span class="comment">// 唤醒所有消费者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    consumerCondition.await(); <span class="comment">// 消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                producerCondition.signalAll(); <span class="comment">// 唤醒所有生产者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>创建一个固定大小的线程池，并向其提交多个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorServiceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为 3 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务，已提交的任务会继续执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a><code>Callable</code> 与 <code>Future</code></h3><p>使用 <code>Callable</code> 提交任务，并使用 <code>Future</code> 获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Callable 任务，它会返回一个字符串</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获得 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 任务已提交，继续执行其他操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// get() 方法会阻塞，直到任务完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 获得任务结果 -&gt; &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个或多个线程等待直到在其他线程中执行的一组操作完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 计数器，当计数器减到 0 时，主线程会被唤醒</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程相互等待，直到所有线程都到达一个共同的屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partySize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 当 3 个线程都到达屏障时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(partySize, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有线程已到达屏障点！继续执行下一阶段。\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(partySize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partySize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第一阶段任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 第一阶段任务完成，到达屏障。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第二阶段任务...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 允许 3 个线程同时访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在访问资源...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟资源访问时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 访问资源完毕。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.accessResource(threadId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="1-死锁演示"><a href="#1-死锁演示" class="headerlink" title="1. 死锁演示"></a>1. 死锁演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock2，尝试获取 lock1...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock1。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 死锁产生条件:</span></span><br><span class="line"><span class="comment">* 1. 互斥条件: 资源是独占的，一个线程在使用时，其他线程无法使用。</span></span><br><span class="line"><span class="comment">* 2. 请求与保持条件: 线程已经持有至少一个资源，但又请求其他资源，同时又保持对已有资源的占有。</span></span><br><span class="line"><span class="comment">* 3. 不可剥夺条件: 资源只能在持有它的线程完成任务后由它自己释放。</span></span><br><span class="line"><span class="comment">* 4. 循环等待条件: 存在一个线程资源的循环链，每个线程都在等待下一个线程所持有的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>通过打破死锁的四个必要条件之一来预防死锁。这里通过<strong>资源有序分配</strong>来打破<strong>循环等待</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 B 也按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序获取锁，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了一个独立的变量副本，实现了线程间的数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置线程本地变量</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="comment">// 获取并打印当前线程的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理和作用:</span></span><br><span class="line"><span class="comment">* 原理: ThreadLocal 内部有一个 `ThreadLocalMap`，每个线程都有一个独立的 `ThreadLocalMap`。</span></span><br><span class="line"><span class="comment">* 当我们调用 `set()` 方法时，实际上是将值存储到了当前线程的 `ThreadLocalMap` 中，</span></span><br><span class="line"><span class="comment">* 键为 `ThreadLocal` 实例本身。</span></span><br><span class="line"><span class="comment">* 作用:</span></span><br><span class="line"><span class="comment">* 1. 数据隔离: 解决了多线程访问共享变量的线程安全问题，但其本质不是同步，而是通过“以空间换时间”的方式，</span></span><br><span class="line"><span class="comment">* 为每个线程提供独立副本，避免了竞争。</span></span><br><span class="line"><span class="comment">* 2. 传递参数: 在整个方法调用链中，无需层层传递参数，可以方便地在任何地方获取当前线程的上下文信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="线程安全单例-静态内部类"><a href="#线程安全单例-静态内部类" class="headerlink" title="线程安全单例 (静态内部类)"></a>线程安全单例 (静态内部类)</h3><p>静态内部类方式是实现线程安全的懒汉式单例的最佳实践之一。它利用了 JVM 类加载机制的线程安全特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonThreadSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadSafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，它只在 SingletonThreadSafe 被首次调用时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态成员变量，在类加载时初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonThreadSafe</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonThreadSafe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 优点:</span></span><br><span class="line"><span class="comment">* 1. 线程安全: 类的加载是线程安全的，因此 INSTANCE 的初始化是原子的。</span></span><br><span class="line"><span class="comment">* 2. 懒加载: 只有在调用 getInstance() 方法时，SingletonHolder 类才会被加载，</span></span><br><span class="line"><span class="comment">* 从而实现懒加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 适用于读多写少的场景，它允许多个线程同时进行读操作，但写操作必须是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) sharedData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// sharedData = newData; // 实际更新数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p><code>ExecutorService</code> 的两种关闭方式：<code>shutdown()</code> 和 <code>shutdownNow()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShutdownDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 5 个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown() vs shutdownNow()</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 优雅关闭</span></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 暴力关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 区别:</span></span><br><span class="line"><span class="comment">* - shutdown(): 优雅关闭。不再接受新的任务，但会等待已提交的任务（包括正在执行和在队列中的）全部执行完毕。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 返回 false，直到所有任务完成。</span></span><br><span class="line"><span class="comment">* - shutdownNow(): 暴力关闭。立即停止所有正在执行的任务，并返回在队列中等待执行的任务列表。</span></span><br><span class="line"><span class="comment">* 它会向所有线程发送 interrupt() 中断信号。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 立即返回 true。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 return 退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送中断信号</span></span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子数组求和-Subarray-Sum"><a href="#子数组求和-Subarray-Sum" class="headerlink" title="子数组求和 (Subarray Sum)"></a>子数组求和 (Subarray Sum)</h3><p>使用<strong>滑动窗口</strong>或<strong>前缀和 + 哈希表</strong>两种方式解决。这里演示前缀和 + 哈希表，它能处理负数情况且时间复杂度更优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出和等于目标值的连续子数组。</span></span><br><span class="line"><span class="comment">     * 使用前缀和与哈希表的方式，时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，返回子数组的起始和结束索引；否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findSubarraySum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 前缀和, value: 出现该前缀和的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSumMap.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 初始化，处理从数组开头开始的子数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentSum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否存在 (currentSum - target) 这样的前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumMap.containsKey(currentSum - target)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> prefixSumMap.get(currentSum - target) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prefixSumMap.put(currentSum, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串去重-Remove-Duplicates-from-String"><a href="#字符串去重-Remove-Duplicates-from-String" class="headerlink" title="字符串去重 (Remove Duplicates from String)"></a>字符串去重 (Remove Duplicates from String)</h3><p>使用 <code>LinkedHashSet</code> 保持相对顺序或手动遍历。这里手动遍历实现，避免使用额外数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个字符串进行去重，并保持原有字符的相对顺序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待去重的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去重后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicates</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span>[] charSet = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>]; <span class="comment">// 假设为 ASCII 字符集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!charSet[c]) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                charSet[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长不重复子串-Longest-Substring-Without-Repeating-Characters"><a href="#最长不重复子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="最长不重复子串 (Longest Substring Without Repeating Characters)"></a>最长不重复子串 (Longest Substring Without Repeating Characters)</h3><p>使用<strong>滑动窗口</strong>加<strong>哈希表</strong>或<strong>数组</strong>来高效解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出最长不重复子串的长度。</span></span><br><span class="line"><span class="comment">     * 使用滑动窗口（双指针）和哈希表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长不重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 字符, value: 字符的最新索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; charIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符已在窗口内，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (charIndexMap.containsKey(currentChar)) &#123;</span><br><span class="line">                left = Math.max(left, charIndexMap.get(currentChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            charIndexMap.put(currentChar, right);</span><br><span class="line">            maxLength = Math.max(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串转整数-String-to-Integer-atoi"><a href="#字符串转整数-String-to-Integer-atoi" class="headerlink" title="字符串转整数 (String to Integer - atoi)"></a>字符串转整数 (String to Integer - atoi)</h3><p>实现 <code>atoi</code> 函数，需要考虑各种边界情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 atoi 函数，将字符串转换为整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.trim(); <span class="comment">// 1. 去掉前导空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2. 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(index);</span><br><span class="line">            <span class="comment">// 3. 检查是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; result &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (result * sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断子串-Substring-Check"><a href="#判断子串-Substring-Check" class="headerlink" title="判断子串 (Substring Check)"></a>判断子串 (Substring Check)</h3><p>使用 <code>String.indexOf()</code> 是最直接的方式。如果不能使用内置方法，可以通过双指针或 KMP 算法实现。这里提供双指针的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否是另一个字符串的子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mainStr 主字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subStr  子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果 subStr 是 mainStr 的子串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubstring</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainStr == <span class="literal">null</span> || subStr == <span class="literal">null</span> || mainStr.length() &lt; subStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subStr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= mainStr.length() - subStr.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subStr.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mainStr.charAt(i + j) != subStr.charAt(j)) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组旋转-Array-Rotation"><a href="#数组旋转-Array-Rotation" class="headerlink" title="数组旋转 (Array Rotation)"></a>数组旋转 (Array Rotation)</h3><p>向右旋转 <code>k</code> 步，可以通过三次反转或使用额外数组实现。这里使用空间复杂度为 <code>O(1)</code> 的三次反转方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个整数数组向右旋转 k 步。</span></span><br><span class="line"><span class="comment">     * 使用三次反转的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    旋转步数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k %= nums.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 反转整个数组</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 反转前 k 个元素</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 反转剩下的元素</span></span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="交错字符串-Interleaving-String"><a href="#交错字符串-Interleaving-String" class="headerlink" title="交错字符串 (Interleaving String)"></a>交错字符串 (Interleaving String)</h3><p>判断 <code>s3</code> 是否由 <code>s1</code> 和 <code>s2</code> 交错而成，可以使用<strong>动态规划</strong>解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个字符串交错形成的字符串是否等于第三个字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 字符串1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 字符串2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3 字符串3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是交错字符串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否交错组成 s3 的前 i+j 个字符</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行 (s1 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列 (s2 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 DP 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>)) ||</span><br><span class="line">                           (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长公共前缀-Longest-Common-Prefix"><a href="#最长公共前缀-Longest-Common-Prefix" class="headerlink" title="最长公共前缀 (Longest Common Prefix)"></a>最长公共前缀 (Longest Common Prefix)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长公共前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 循环比较，直到找到子串</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次缩短 prefix</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串压缩-String-Compression"><a href="#字符串压缩-String-Compression" class="headerlink" title="字符串压缩 (String Compression)"></a>字符串压缩 (String Compression)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现基本的字符串压缩，例如 aabcccccaaa 压缩为 a2b1c5a3。</span></span><br><span class="line"><span class="comment">     * 如果压缩后的字符串没有变短，则返回原字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待压缩的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">compressString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">compressed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length() &amp;&amp; str.charAt(i) == str.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                compressed.append(str.charAt(i - <span class="number">1</span>)).append(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compressed.length() &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str; <span class="comment">// 如果压缩后没有变短，返回原字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compressed.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="寻找重复数-Find-the-Duplicate-Number"><a href="#寻找重复数-Find-the-Duplicate-Number" class="headerlink" title="寻找重复数 (Find the Duplicate Number)"></a>寻找重复数 (Find the Duplicate Number)</h3><p>给定一个包含 <code>n+1</code> 个整数的数组，数字都在 <code>1</code> 到 <code>n</code> 的范围内。找出这个重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用**快慢指针**（类似于检测链表环）来寻找重复数。</span></span><br><span class="line"><span class="comment">     * 假设数组是一个链表，索引 `i` 指向 `nums[i]`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 包含 n+1 个整数的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 重复的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 寻找环的入口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 找到环后，从头开始，快慢指针以相同速度前进，相遇点即为环的入口（重复数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = nums[p1];</span><br><span class="line">            p2 = nums[p2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表、栈与队列"><a href="#链表、栈与队列" class="headerlink" title="链表、栈与队列"></a>链表、栈与队列</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>使用<strong>双指针</strong>方法，创建一个新的链表，遍历两个输入链表，比较节点值并依次添加到新链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哑节点，简化操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的节点添加到新链表末尾</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h4><p>使用<strong>快慢指针</strong>，只遍历一次。快指针先走 <code>k</code> 步，然后快慢指针同时前进，当快指针到达末尾时，慢指针正好在倒数第 <code>k</code> 个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针先走 k 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 链表长度小于 k</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时前进，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除重复节点"><a href="#删除重复节点" class="headerlink" title="删除重复节点"></a>删除重复节点</h4><p>给定一个已排序的链表，删除所有重复的节点，使得每个元素只出现一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.val == current.next.val) &#123;</span><br><span class="line">                current.next = current.next.next; <span class="comment">// 删除下一个重复节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next; <span class="comment">// 前进到下一个不重复的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>使用<strong>快慢指针</strong>。如果链表有环，快指针最终会追上慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经到达末尾，没有环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h4><p>两个非负整数由链表表示，每个节点包含一个数字。计算它们的和。这里假设链表按<strong>逆序</strong>存储数字（个位在前）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h4><p>使用两个栈，一个用于入队 (<code>inStack</code>)，一个用于出队 (<code>outStack</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h4><p>使用两个队列，一个用于入栈 (<code>q1</code>)，一个用于辅助 (<code>q2</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> q1.poll();</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pop();</span><br><span class="line">        q1.offer(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><p>使用一个<strong>栈</strong>来检查括号是否匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树与递归"><a href="#树与递归" class="headerlink" title="树与递归"></a>树与递归</h3><p>定义一个简单的二叉树节点类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树前序遍历-Preorder-Traversal"><a href="#二叉树前序遍历-Preorder-Traversal" class="headerlink" title="二叉树前序遍历 (Preorder Traversal)"></a>二叉树前序遍历 (Preorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorder(node.left, list);</span><br><span class="line">        preorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 先压入右子节点，再压入左子节点，保证弹出时先处理左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序遍历-Inorder-Traversal"><a href="#二叉树中序遍历-Inorder-Traversal" class="headerlink" title="二叉树中序遍历 (Inorder Traversal)"></a>二叉树中序遍历 (Inorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将所有左子节点压入栈</span></span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出栈顶节点，并处理其右子树</span></span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树后序遍历-Postorder-Traversal"><a href="#二叉树后序遍历-Postorder-Traversal" class="headerlink" title="二叉树后序遍历 (Postorder Traversal)"></a>二叉树后序遍历 (Postorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, list);</span><br><span class="line">        postorder(node.right, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 倒序插入</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result); <span class="comment">// 将结果反转</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树层序遍历-Level-Order-Traversal"><a href="#二叉树层序遍历-Level-Order-Traversal" class="headerlink" title="二叉树层序遍历 (Level Order Traversal)"></a>二叉树层序遍历 (Level Order Traversal)</h4><p>使用<strong>队列</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对称二叉树-Symmetric-Tree"><a href="#对称二叉树-Symmetric-Tree" class="headerlink" title="对称二叉树 (Symmetric Tree)"></a>对称二叉树 (Symmetric Tree)</h4><p>使用<strong>递归</strong>，检查根节点的左右子树是否是镜像对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大深度-Maximum-Depth-of-Binary-Tree"><a href="#最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="最大深度 (Maximum Depth of Binary Tree)"></a>最大深度 (Maximum Depth of Binary Tree)</h4><p>使用<strong>递归</strong>（深度优先搜索）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="验证二叉搜索树 (Validate Binary Search Tree)"></a>验证二叉搜索树 (Validate Binary Search Tree)</h4><p>使用<strong>递归</strong>或<strong>中序遍历</strong>。二叉搜索树的中序遍历结果是升序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查当前节点的值是否在有效范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查左右子树，并缩小有效范围</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="最大子数组和-Maximum-Subarray-Sum"><a href="#最大子数组和-Maximum-Subarray-Sum" class="headerlink" title="最大子数组和 (Maximum Subarray Sum)"></a>最大子数组和 (Maximum Subarray Sum)</h4><p>使用<strong>动态规划</strong> (Kadane’s algorithm)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSoFar</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 迄今为止的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEndingHere</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 以当前位置结尾的最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// maxEndingHere 的值是：(当前元素) 或 (当前元素 + 之前的最大和)</span></span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两数相加-Large-Number-Addition"><a href="#两数相加-Large-Number-Addition" class="headerlink" title="两数相加 (Large Number Addition)"></a>两数相加 (Large Number Addition)</h4><p>将两个超长正整数字符串相加，模拟小学加法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit1</span> <span class="operator">=</span> (i &gt;= <span class="number">0</span>) ? num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit2</span> <span class="operator">=</span> (j &gt;= <span class="number">0</span>) ? num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> digit1 + digit2 + carry;</span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算实现加法-Addition-with-Bitwise-Operators"><a href="#位运算实现加法-Addition-with-Bitwise-Operators" class="headerlink" title="位运算实现加法 (Addition with Bitwise Operators)"></a>位运算实现加法 (Addition with Bitwise Operators)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="type">int</span> carry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算无进位的和（异或）</span></span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            <span class="comment">// 计算进位（与&amp;左移）</span></span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列-Permutations"><a href="#全排列-Permutations" class="headerlink" title="全排列 (Permutations)"></a>全排列 (Permutations)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackPermute(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackPermute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackPermute(result, tempList, nums, used);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集-Subsets"><a href="#子集-Subsets" class="headerlink" title="子集 (Subsets)"></a>子集 (Subsets)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackSubsets(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackSubsets</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackSubsets(result, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳台阶-Climbing-Stairs"><a href="#跳台阶-Climbing-Stairs" class="headerlink" title="跳台阶 (Climbing Stairs)"></a>跳台阶 (Climbing Stairs)</h4><p>这是经典的<strong>动态规划</strong>问题，与斐波那契数列类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现一个简单的-Trie-前缀树"><a href="#实现一个简单的-Trie-前缀树" class="headerlink" title="实现一个简单的 Trie (前缀树)"></a>实现一个简单的 Trie (前缀树)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            current = current.children.computeIfAbsent(c, k -&gt; <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表-II-Reverse-Linked-List-II"><a href="#反转链表-II-Reverse-Linked-List-II" class="headerlink" title="反转链表 II (Reverse Linked List II)"></a>反转链表 II (Reverse Linked List II)</h4><p>反转链表从位置 <code>m</code> 到 <code>n</code> 的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next; <span class="comment">// 移动到反转部分的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next; <span class="comment">// 反转部分的起始节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">then</span> <span class="operator">=</span> start.next; <span class="comment">// 待反转的第二个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存-LRU-Cache"><a href="#LRU-缓存-LRU-Cache" class="headerlink" title="LRU 缓存 (LRU Cache)"></a>LRU 缓存 (LRU Cache)</h4><p>使用 <code>LinkedHashMap</code> 可以非常方便地实现 LRU 缓存，因为它本身就维护了插入顺序或访问顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// true 表示按访问顺序排序</span></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当容量超过限制时，自动移除最老的（最久未访问的）条目</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断回文链表-Palindrome-Linked-List"><a href="#判断回文链表-Palindrome-Linked-List" class="headerlink" title="判断回文链表 (Palindrome Linked List)"></a>判断回文链表 (Palindrome Linked List)</h4><p>可以使用快慢指针找到中点，然后反转后半部分，最后比较两部分是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较前半部分和反转后的后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstHalf</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (secondHalf != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstHalf.val != secondHalf.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHalf = firstHalf.next;</span><br><span class="line">            secondHalf = secondHalf.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock-1"><a href="#ReadWriteLock-1" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 允许多个线程同时进行读操作，但只允许一个线程进行写操作，从而提高读多写少的场景下的并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：允许多个线程同时访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：同一时刻只能有一个线程访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个线程等待，直到其他线程都完成了某项工作。它就像一个倒计时器，一旦计数为零，等待的线程就会被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个计数器，初始值为 5</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：启动 &quot;</span> + workerCount + <span class="string">&quot; 个工作线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程在到达一个共同的屏障点后，再一起继续执行。它就像赛跑的起跑线，所有选手都准备好后，发令枪才响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 创建一个屏障，当 3 个线程都到达时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(runnerCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有赛跑者都已就位，发令枪响！\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(runnerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runnerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 正在走向起跑线...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟准备时间</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 到达起跑线，准备就绪。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待，直到所有线程都到达</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 开始跑步！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对某个资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 停车场最多允许 3 辆车停放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">int</span> carId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 正在寻找车位...&quot;</span>);</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 成功进入停车场。&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟停车时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 离开停车场。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 10 辆车</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.park(carId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防-按锁顺序"><a href="#死锁预防-按锁顺序" class="headerlink" title="死锁预防 (按锁顺序)"></a>死锁预防 (按锁顺序)</h3><p>通过<strong>资源有序分配</strong>来打破死锁的<strong>循环等待</strong>条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序（先 A 后 B）获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadOne, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadTwo, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池异常"><a href="#线程池异常" class="headerlink" title="线程池异常"></a>线程池异常</h3><p>使用 <code>Future.get()</code> 或在任务中捕获异常来处理线程池中任务抛出的异常。<code>execute()</code> 方法无法直接捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个会抛出运行时异常的任务</span></span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个模拟的任务执行异常。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取任务结果来捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;捕获到任务执行异常：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute() 提交任务，异常会被吞掉，除非自定义 UncaughtExceptionHandler</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;另一个任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;这个异常会被吞掉。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了独立的变量副本，实现了数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        threadLocal.set(value); <span class="comment">// 设置当前线程的变量副本</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a><code>LockSupport</code></h3><p><code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 提供了更灵活的线程阻塞和唤醒机制，类似于 <code>wait()</code> 和 <code>notify()</code>，但不需要依赖锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 任务准备就绪，即将阻塞...&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 被唤醒，继续执行。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 确保工作线程已执行 park()</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 唤醒工作线程。&quot;</span>);</span><br><span class="line">        LockSupport.unpark(workerThread); <span class="comment">// 唤醒指定线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信-按顺序打印"><a href="#线程通信-按顺序打印" class="headerlink" title="线程通信 (按顺序打印)"></a>线程通信 (按顺序打印)</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现三个线程按顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 0: A, 1: B, 2: C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String letter, <span class="type">int</span> expectedState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state != expectedState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(letter);</span><br><span class="line">                state = (state + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个状态</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SequentialPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printC);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n打印完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="ThreadPoolExecutor-的七个参数"><a href="#ThreadPoolExecutor-的七个参数" class="headerlink" title="ThreadPoolExecutor 的七个参数"></a><code>ThreadPoolExecutor</code> 的七个参数</h4><ol><li><code>corePoolSize</code>: 核心线程数。线程池中常驻的线程数量，即使空闲也不会被销毁。</li><li><code>maximumPoolSize</code>: 最大线程数。当工作队列已满，且任务量继续增加时，线程池可以创建的最大线程数。</li><li><code>keepAliveTime</code>: 空闲线程存活时间。当线程数大于 <code>corePoolSize</code> 时，非核心线程的空闲存活时间。</li><li><code>unit</code>: <code>keepAliveTime</code> 的时间单位。</li><li><code>workQueue</code>: 工作队列。用于存放等待执行的任务，常用的有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li><li><code>threadFactory</code>: 线程工厂。用于创建新线程，可以自定义线程的名称、优先级等。</li><li><code>handler</code>: 拒绝策略。当线程池和工作队列都已满时，用于处理新来的任务，例如抛出异常、由调用者执行等。</li></ol><h4 id="手写一个自定义线程池"><a href="#手写一个自定义线程池" class="headerlink" title="手写一个自定义线程池"></a>手写一个自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 工作队列容量为 10</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由调用者线程执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>使用 <code>AtomicBoolean</code> 或 <code>AtomicReference</code> 解决并发问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicBooleanDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 确保只有一个线程执行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 initialized 为 false 时，才将其设置为 true 并执行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 开始执行初始化操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化已被其他线程执行，跳过。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(AtomicBooleanDemo::initialize, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a><code>volatile</code> 内存语义</h3><p><code>volatile</code> 确保了<strong>可见性</strong>和<strong>有序性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileMemorySemantics</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 可见性：当一个线程修改了 ready 的值，其他线程能立即看到最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            number = <span class="number">42</span>; <span class="comment">// 修改 number</span></span><br><span class="line">            ready = <span class="literal">true</span>; <span class="comment">// 修改 ready</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 等待 ready 变为 true</span></span><br><span class="line">                <span class="comment">// 如果没有 volatile，这里可能会陷入死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 有序性：写 volatile 变量（ready = true）之前的操作（number = 42）</span></span><br><span class="line">            <span class="comment">// 对其他线程都是可见的。保证了 number 的值是 42。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的 number 值: &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriterThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中断机制-1"><a href="#中断机制-1" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptibleThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断，即将退出...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 break 或 return 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已优雅地退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 发送中断信号。&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 的并发原理是**分段锁（ 7）**或 <strong>CAS + Synchronized（ 8）</strong>，只对操作的桶进行锁定，大大提高了并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 10 个线程，每个线程向 map 中添加 1000 个键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + (threadId * <span class="number">1000</span> + j);</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终 map 的大小: &quot;</span> + map.size()); <span class="comment">// 期望值为 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h3><p><code>ForkJoinPool</code> 是一个用于分治任务的线程池，<code>RecursiveTask</code> 是可返回结果的分治任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 任务分解的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务规模小于等于阈值，则直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将任务分解成两个子任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            leftTask.fork(); <span class="comment">// 提交左子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 同步计算右子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 等待左子任务结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;大数组的和为: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.  语言基础"></a>1.  语言基础</h3><h4 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h4><p> 的基本数据类型决定了变量可以存储的数据范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypesDetailed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数类型：默认为 int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 占用 1 字节，-128 到 127</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 占用 2 字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 占用 4 字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10000000000L</span>; <span class="comment">// 占用 8 字节，需要 L 或 l 后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点类型：默认为 double</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>; <span class="comment">// 占用 4 字节，需要 f 或 F 后缀</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926535</span>; <span class="comment">// 占用 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单个字符，占用 2 字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">65</span>; <span class="comment">// 也可以使用 ASCII 码或 Unicode</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 和 c2 是否相等？ &quot;</span> + (c1 == c2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;学Java有趣吗？&quot;</span> + isFun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p> 中，从小范围类型向大范围类型转换是<strong>自动</strong>的（隐式转换）；从大范围向小范围转换需要<strong>强制</strong>转换（显式转换），可能造成数据丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCasting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式转换：int -&gt; long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">myLong</span> <span class="operator">=</span> myInt;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式转换后的 long 类型: &quot;</span> + myLong);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式转换：double -&gt; int</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myInteger</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 强制转换，小数部分被丢弃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显式转换后的 int 类型: &quot;</span> + myInteger); <span class="comment">// 输出 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是存储<strong>固定大小</strong>同类型元素的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明并初始化一个整数数组</span></span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为 5 的数组</span></span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明、初始化并赋值</span></span><br><span class="line">        String[] fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有水果:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123; <span class="comment">// 增强 for 循环</span></span><br><span class="line">            System.out.println(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2. 面向对象编程 (OOP)"></a>2. 面向对象编程 (OOP)</h3><h4 id="构造方法与方法重载"><a href="#构造方法与方法重载" class="headerlink" title="构造方法与方法重载"></a>构造方法与方法重载</h4><p><strong>构造方法</strong>是一种特殊方法，用于创建对象时初始化。<strong>方法重载</strong>是指在同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序）的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 调用本类的三参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重载: 计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承、多态与抽象"><a href="#继承、多态与抽象" class="headerlink" title="继承、多态与抽象"></a>继承、多态与抽象</h4><p>继承实现代码复用，多态实现行为多样化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String brand; <span class="comment">// 子类可以访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;品牌是: &quot;</span> + brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车正在路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自行车正在骑行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>); <span class="comment">// 多态引用</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myBicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>(<span class="string">&quot;Giant&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个方法调用，不同行为</span></span><br><span class="line">        myCar.run(); <span class="comment">// 输出 &quot;汽车正在路上行驶...&quot;</span></span><br><span class="line">        myBicycle.run(); <span class="comment">// 输出 &quot;自行车正在骑行...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-核心类库"><a href="#3-核心类库" class="headerlink" title="3.  核心类库"></a>3.  核心类库</h3><p>好的，这次我们将把<strong>各种方法的使用代码</strong>直接嵌入到每个知识点的解释中，让您在学习概念的同时，就能看到具体的代码实现和效果。我们将专注于<strong>数组、字符串和集合</strong>这三大核心部分，把它们的创建、遍历、和各种常用方法的代码示例都清晰地展示出来。</p><hr><h3 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h3><p>数组是一种固定大小的、用于存储同类型元素的容器。</p><h4 id="创建和遍历"><a href="#创建和遍历" class="headerlink" title="创建和遍历"></a>创建和遍历</h4><p>这里展示两种最常见的创建数组的方式，并使用两种循环进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：声明并分配空间，系统赋默认值</span></span><br><span class="line">        <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 创建一个包含3个整数的数组，默认值都是0</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组 intArray 的第一个元素是: &quot;</span> + intArray[<span class="number">0</span>]); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：声明并直接初始化</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方式一：使用 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringArray.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stringArray[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + stringArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历方式二：使用增强 for 循环（更简洁）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用增强 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringArray) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素: &quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Arrays-类的常用方法"><a href="#Arrays-类的常用方法" class="headerlink" title="Arrays 类的常用方法"></a><code>Arrays</code> 类的常用方法</h4><p><code>java.util.Arrays</code> 类提供了很多静态方法，方便我们对数组进行操作，比如排序、查找、复制等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序：Arrays.sort()</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(numbers)); <span class="comment">// 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找：Arrays.binarySearch() (必须先排序)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 6 的索引是: &quot;</span> + index); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充：Arrays.fill()</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(newArray, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后: &quot;</span> + Arrays.toString(newArray)); <span class="comment">// 输出: [99, 99, 99, 99, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 复制：Arrays.copyOf()</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(numbers, <span class="number">3</span>); <span class="comment">// 复制前3个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制前3个元素: &quot;</span> + Arrays.toString(copiedArray)); <span class="comment">// 输出: [1, 2, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 比较：Arrays.equals()</span></span><br><span class="line">        <span class="type">int</span>[] anotherArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数组是否相等: &quot;</span> + Arrays.equals(numbers, anotherArray)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2. 字符串（String）"></a>2. 字符串（String）</h3><p><code>String</code> 是一个不可变的字符序列，这意味着一旦创建，它的内容就不能被修改。所有修改操作都会返回一个新的 <code>String</code> 对象。</p><h4 id="创建和常用方法"><a href="#创建和常用方法" class="headerlink" title="创建和常用方法"></a>创建和常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;  Java is a great language. &quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java is a great language.&quot;</span>); <span class="comment">// 使用 new 关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">// 1. 获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length); <span class="comment">// 输出: 29</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 访问字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str1.charAt(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个字符是: &quot;</span> + firstChar); <span class="comment">// 输出: J</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 截取子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str1.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取子串: &quot;</span> + sub); <span class="comment">// 输出: is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查找位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;great&#x27; 的索引: &quot;</span> + index); <span class="comment">// 输出: 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> str1.contains(<span class="string">&quot;language&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;language&#x27;: &quot;</span> + contains); <span class="comment">// 输出: true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startsWith</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;  Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否以 &#x27;  Java&#x27; 开头: &quot;</span> + startsWith); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedStr</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;great&quot;</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + replacedStr); <span class="comment">// 输出:   Java is a wonderful language. </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 大小写转换和去空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trimmedStr</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;去除首尾空格: &#x27;&quot;</span> + trimmedStr + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 输出: &#x27;Java is a great language.&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;转为大写: &quot;</span> + trimmedStr.toUpperCase());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 分割和连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分割后: &quot;</span> + Arrays.toString(fruits)); <span class="comment">// 输出: [apple, banana, orange]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> String.join(<span class="string">&quot; - &quot;</span>, fruits);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接后: &quot;</span> + joinedString); <span class="comment">// 输出: apple - banana - orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><code>StringBuilder</code> 和 <code>StringBuffer</code></h4><p>对于需要频繁修改字符串的场景，应使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 以提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 追加内容</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;追加后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 插入内容</span></span><br><span class="line">        sb.insert(<span class="number">6</span>, <span class="string">&quot;Beautiful &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入后: &quot;</span> + sb); <span class="comment">// 输出: Hello Beautiful World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除内容</span></span><br><span class="line">        sb.delete(<span class="number">6</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-集合（Collections）"><a href="#3-集合（Collections）" class="headerlink" title="3. 集合（Collections）"></a>3. 集合（Collections）</h3><p>Java 集合框架提供了强大的数据结构来存储和操作对象。</p><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List</strong>（列表）</h4><p><code>List</code> 是一种有序、可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ArrayList（查询快）</span></span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表元素: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Banana, Apple]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + fruits.get(<span class="number">0</span>)); <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;列表大小: &quot;</span> + fruits.size());</span><br><span class="line"></span><br><span class="line">        fruits.set(<span class="number">1</span>, <span class="string">&quot;Grape&quot;</span>); <span class="comment">// 替换第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Grape, Apple]</span></span><br><span class="line"></span><br><span class="line">        fruits.remove(<span class="number">1</span>); <span class="comment">// 删除第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set（集）"><a href="#Set（集）" class="headerlink" title="Set（集）"></a><strong>Set</strong>（集）</h4><p><code>Set</code> 是一种无序、不可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashSet</span></span><br><span class="line">        Set&lt;String&gt; uniqueFruits = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加重复元素，会失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合元素: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple, Banana] (顺序不定)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsBanana</span> <span class="operator">=</span> uniqueFruits.contains(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;Banana&#x27;: &quot;</span> + containsBanana); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        uniqueFruits.remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a><strong>Map</strong>（映射）</h4><p><code>Map</code> 存储键值对，键是唯一的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; studentScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>); <span class="comment">// 添加键值对</span></span><br><span class="line">        studentScores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>); <span class="comment">// 键已存在，会覆盖旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice 的分数: &quot;</span> + studentScores.get(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: 100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 Map 的三种方式</span></span><br><span class="line">        <span class="comment">// 方式一：遍历键集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : studentScores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;, 分数: &quot;</span> + studentScores.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：遍历值集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历值集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer score : studentScores.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数: &quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：遍历键值对集 (Entry Set)，最常用且高效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键值对集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-实现单例模式-Singleton-Pattern&quot;&gt;&lt;a href=&quot;#1-实现单例模式-Singleton-Pattern&quot; class=&quot;headerlink&quot; title=&quot;1.实现单例模式 (Singleton Pattern)&quot;&gt;&lt;/a&gt;1.实现单例</summary>
      
    
    
    
    <category term="手写" scheme="http://example.com/categories/%E6%89%8B%E5%86%99/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="手写" scheme="http://example.com/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2025/09/11/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2025/09/11/%E7%AE%97%E6%B3%95/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-22T04:31:27.914Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="🔥-常见算法分类-Java实现"><a href="#🔥-常见算法分类-Java实现" class="headerlink" title="🔥 常见算法分类 + Java实现"></a>🔥 常见算法分类 + Java实现</h1><hr><h2 id="1-排序算法-Sorting"><a href="#1-排序算法-Sorting" class="headerlink" title="1. 排序算法 (Sorting)"></a>1. 排序算法 (Sorting)</h2><h3 id="1-1-冒泡排序-Bubble-Sort"><a href="#1-1-冒泡排序-Bubble-Sort" class="headerlink" title="1.1 冒泡排序 (Bubble Sort)"></a>1.1 冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-选择排序-Selection-Sort"><a href="#1-2-选择排序-Selection-Sort" class="headerlink" title="1.2 选择排序 (Selection Sort)"></a>1.2 选择排序 (Selection Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-插入排序-Insertion-Sort"><a href="#1-3-插入排序-Insertion-Sort" class="headerlink" title="1.3 插入排序 (Insertion Sort)"></a>1.3 插入排序 (Insertion Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-归并排序-Merge-Sort"><a href="#1-4-归并排序-Merge-Sort" class="headerlink" title="1.4 归并排序 (Merge Sort)"></a>1.4 归并排序 (Merge Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, l, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = (arr[i] &lt;= arr[j]) ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.length; i++) arr[l + i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-快速排序-Quick-Sort"><a href="#1-5-快速排序-Quick-Sort" class="headerlink" title="1.5 快速排序 (Quick Sort)"></a>1.5 快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line">    quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i+<span class="number">1</span>]; arr[i+<span class="number">1</span>] = arr[r]; arr[r] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-查找算法-Searching"><a href="#2-查找算法-Searching" class="headerlink" title="2. 查找算法 (Searching)"></a>2. 查找算法 (Searching)</h2><h3 id="2-1-顺序查找-Linear-Search"><a href="#2-1-顺序查找-Linear-Search" class="headerlink" title="2.1 顺序查找 (Linear Search)"></a>2.1 顺序查找 (Linear Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">linearSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-二分查找-Binary-Search-（数组有序）"><a href="#2-2-二分查找-Binary-Search-（数组有序）" class="headerlink" title="2.2 二分查找 (Binary Search)（数组有序）"></a>2.2 二分查找 (Binary Search)（数组有序）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-双指针算法-Two-Pointers"><a href="#3-双指针算法-Two-Pointers" class="headerlink" title="3. 双指针算法 (Two Pointers)"></a>3. 双指针算法 (Two Pointers)</h2><h3 id="3-1-反转数组"><a href="#3-1-反转数组" class="headerlink" title="3.1 反转数组"></a>3.1 反转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[l]; arr[l] = arr[r]; arr[r] = tmp;</span><br><span class="line">        l++; r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-三数之和-LeetCode-15"><a href="#3-2-三数之和-LeetCode-15" class="headerlink" title="3.2 三数之和 (LeetCode 15)"></a>3.2 三数之和 (LeetCode 15)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i+<span class="number">1</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>]) r--;</span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划-Dynamic-Programming"><a href="#4-动态规划-Dynamic-Programming" class="headerlink" title="4. 动态规划 (Dynamic Programming)"></a>4. 动态规划 (Dynamic Programming)</h2><h3 id="4-1-斐波那契数列"><a href="#4-1-斐波那契数列" class="headerlink" title="4.1 斐波那契数列"></a>4.1 斐波那契数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-爬楼梯-LeetCode-70"><a href="#4-2-爬楼梯-LeetCode-70" class="headerlink" title="4.2 爬楼梯 (LeetCode 70)"></a>4.2 爬楼梯 (LeetCode 70)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a + b;</span><br><span class="line">        a = b; b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长公共子序列-LCS"><a href="#4-3-最长公共子序列-LCS" class="headerlink" title="4.3 最长公共子序列 (LCS)"></a>4.3 最长公共子序列 (LCS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-贪心算法-Greedy"><a href="#5-贪心算法-Greedy" class="headerlink" title="5. 贪心算法 (Greedy)"></a>5. 贪心算法 (Greedy)</h2><h3 id="5-1-跳跃游戏-LeetCode-55"><a href="#5-1-跳跃游戏-LeetCode-55" class="headerlink" title="5.1 跳跃游戏 (LeetCode 55)"></a>5.1 跳跃游戏 (LeetCode 55)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-分治算法-Divide-Conquer"><a href="#6-分治算法-Divide-Conquer" class="headerlink" title="6. 分治算法 (Divide &amp; Conquer)"></a>6. 分治算法 (Divide &amp; Conquer)</h2><h3 id="6-1-归并排序-见上"><a href="#6-1-归并排序-见上" class="headerlink" title="6.1 归并排序 (见上)"></a>6.1 归并排序 (见上)</h3><h3 id="6-2-快速排序-见上"><a href="#6-2-快速排序-见上" class="headerlink" title="6.2 快速排序 (见上)"></a>6.2 快速排序 (见上)</h3><hr><h2 id="7-回溯算法-Backtracking"><a href="#7-回溯算法-Backtracking" class="headerlink" title="7. 回溯算法 (Backtracking)"></a>7. 回溯算法 (Backtracking)</h2><h3 id="7-1-全排列-LeetCode-46"><a href="#7-1-全排列-LeetCode-46" class="headerlink" title="7.1 全排列 (LeetCode 46)"></a>7.1 全排列 (LeetCode 46)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        backtrack(nums, used, path, res);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-图算法-Graph-Algorithms"><a href="#8-图算法-Graph-Algorithms" class="headerlink" title="8. 图算法 (Graph Algorithms)"></a>8. 图算法 (Graph Algorithms)</h2><h3 id="8-1-BFS（最短路径）"><a href="#8-1-BFS（最短路径）" class="headerlink" title="8.1 BFS（最短路径）"></a>8.1 BFS（最短路径）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    q.add(start); visited.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                visited.add(nei);</span><br><span class="line">                q.add(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-DFS"><a href="#8-2-DFS" class="headerlink" title="8.2 DFS"></a>8.2 DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.contains(start)) <span class="keyword">return</span>;</span><br><span class="line">    visited.add(start);</span><br><span class="line">    System.out.print(start + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(start, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">        dfs(graph, nei, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Dijkstra-最短路径"><a href="#8-3-Dijkstra-最短路径" class="headerlink" title="8.3 Dijkstra 最短路径"></a>8.3 Dijkstra 最短路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span>[][] graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; (u == -<span class="number">1</span> || dist[j] &lt; dist[u])) u = j;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;🔥-常见算法分类-Java实现&quot;&gt;&lt;a href=&quot;#🔥-常见算法分类-Java实现&quot; class=&quot;headerlink&quot; title=&quot;🔥 常见算法分类 + Java实现&quot;&gt;&lt;/a&gt;🔥 常见算法分类 + Java实现&lt;/h1&gt;&lt;hr&gt;
&lt;h2</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>web</title>
    <link href="http://example.com/2025/09/11/web/"/>
    <id>http://example.com/2025/09/11/web/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-16T05:16:12.451Z</updated>
    
    <content type="html"><![CDATA[<p>好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。</p><hr><h3 id="一、HTTP-协议概述"><a href="#一、HTTP-协议概述" class="headerlink" title="一、HTTP 协议概述"></a>一、HTTP 协议概述</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是<strong>无状态（Stateless）</strong>，这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。</p><hr><h3 id="二、HTTP-请求（Request）"><a href="#二、HTTP-请求（Request）" class="headerlink" title="二、HTTP 请求（Request）"></a>二、HTTP 请求（Request）</h3><p>一个完整的 HTTP 请求由四部分组成：</p><h4 id="1-请求行（Request-Line）"><a href="#1-请求行（Request-Line）" class="headerlink" title="1. 请求行（Request Line）"></a>1. 请求行（Request Line）</h4><p>这是请求的第一行，它定义了请求的基本信息。</p><ul><li><strong>请求方法（Method）</strong>：如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等，表示对资源的操作类型。</li><li><strong>请求 URL (URI)</strong>：资源的地址。</li><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>。</li></ul><p>示例：</p><p>GET &#x2F;index.html HTTP&#x2F;1.1</p><h4 id="2-请求头（Request-Headers）"><a href="#2-请求头（Request-Headers）" class="headerlink" title="2. 请求头（Request Headers）"></a>2. 请求头（Request Headers）</h4><p>请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。</p><ul><li><strong>Host</strong>：指定请求的目标服务器的域名和端口号。</li><li><strong>User-Agent</strong>：客户端的软件类型和版本，如浏览器信息。</li><li><strong>Accept</strong>：客户端能够处理的媒体类型，告诉服务器希望返回什么格式的数据（如 <code>application/json</code>, <code>text/html</code>）。</li><li><strong>Content-Type</strong>：<strong>请求体</strong>中的数据类型，只在有请求体时使用（如 <code>POST</code>）。常见的有：<ul><li><code>application/x-www-form-urlencoded</code>：默认编码，用于提交表单数据。</li><li><code>multipart/form-data</code>：用于上传文件。</li><li><code>application/json</code>：用于前后端分离，提交 JSON 数据。</li></ul></li><li><strong>Content-Length</strong>：请求体的长度（字节）。</li><li><strong>Cookie</strong>：客户端存储的 Cookie 信息，用于会话管理。</li><li><strong>Authorization</strong>：用于身份认证，如携带 Bearer Token。</li><li><strong>Referer</strong>：请求从哪个页面跳转而来。</li></ul><h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔请求头和请求体。</p><h4 id="4-请求体（Request-Body）"><a href="#4-请求体（Request-Body）" class="headerlink" title="4. 请求体（Request Body）"></a>4. 请求体（Request Body）</h4><p>请求体包含客户端提交给服务器的数据，通常用于 <code>POST</code>、<code>PUT</code> 等请求。GET 请求通常没有请求体。</p><hr><h3 id="三、HTTP-响应（Response）"><a href="#三、HTTP-响应（Response）" class="headerlink" title="三、HTTP 响应（Response）"></a>三、HTTP 响应（Response）</h3><p>一个完整的 HTTP 响应由三部分组成：</p><h4 id="1-状态行（Status-Line）"><a href="#1-状态行（Status-Line）" class="headerlink" title="1. 状态行（Status Line）"></a>1. 状态行（Status Line）</h4><p>这是响应的第一行，定义了响应的基本信息。</p><ul><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>。</li><li><strong>状态码（Status Code）</strong>：三位数字，表示请求结果。</li><li><strong>状态信息（Reason Phrase）</strong>：对状态码的简短描述。</li></ul><p>示例：</p><p>HTTP&#x2F;1.1 200 OK</p><h4 id="2-响应头（Response-Headers）"><a href="#2-响应头（Response-Headers）" class="headerlink" title="2. 响应头（Response Headers）"></a>2. 响应头（Response Headers）</h4><p>响应头提供了关于服务器、响应体和会话的元数据信息。</p><ul><li><strong>Content-Type</strong>：<strong>响应体</strong>的数据类型。</li><li><strong>Content-Length</strong>：响应体的长度。</li><li><strong>Set-Cookie</strong>：服务器向客户端发送 Cookie，用于存储会话 ID 等信息。</li><li><strong>Location</strong>：用于重定向，指定新的 URL。</li><li><strong>Cache-Control</strong>：控制浏览器缓存行为。</li></ul><h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔响应头和响应体。</p><h4 id="4-响应体（Response-Body）"><a href="#4-响应体（Response-Body）" class="headerlink" title="4. 响应体（Response Body）"></a>4. 响应体（Response Body）</h4><p>响应体包含了服务器返回给客户端的实际数据，如 HTML 网页内容、JSON 数据或图片等。</p><hr><h3 id="四、HTTP-方法的幂等性与安全性"><a href="#四、HTTP-方法的幂等性与安全性" class="headerlink" title="四、HTTP 方法的幂等性与安全性"></a>四、HTTP 方法的幂等性与安全性</h3><ul><li><strong>安全性</strong>：指请求方法不会对服务器上的资源状态产生修改。<code>GET</code> 和 <code>HEAD</code> 方法是安全的。</li><li><strong>幂等性</strong>：指请求方法重复执行多次，对服务器上的资源状态产生的影响与执行一次的影响相同。<ul><li><strong>幂等方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li><li><strong>非幂等方法</strong>：<code>POST</code>。</li></ul></li></ul><table><thead><tr><th>方法</th><th>安全性</th><th>幂等性</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>是</td><td>是</td><td>获取资源</td></tr><tr><td><strong>POST</strong></td><td>否</td><td>否</td><td>创建资源</td></tr><tr><td><strong>PUT</strong></td><td>否</td><td>是</td><td>更新或替换资源</td></tr><tr><td><strong>DELETE</strong></td><td>否</td><td>是</td><td>删除资源</td></tr></tbody></table><hr><h3 id="五、HTTP-的会话管理：Cookie"><a href="#五、HTTP-的会话管理：Cookie" class="headerlink" title="五、HTTP 的会话管理：Cookie"></a>五、HTTP 的会话管理：Cookie</h3><p>HTTP 本身是无状态的，但为了跟踪用户，引入了 Cookie。</p><ol><li><strong>创建</strong>：服务器通过响应头 <code>Set-Cookie</code> 向客户端发送一个 Cookie。</li><li><strong>存储</strong>：浏览器接收到 <code>Set-Cookie</code> 后，会将其存储在本地。</li><li><strong>携带</strong>：之后，每次对同一域名发起请求时，浏览器都会自动在请求头 <code>Cookie</code> 中带上这个 Cookie。</li></ol><p>通过在 Cookie 中存储一个 SessionID，服务器就可以在后续请求中找到对应的会话数据，从而实现状态管理。</p><hr><h3 id="六、HTTP-1-1-与-HTTP-2-的区别"><a href="#六、HTTP-1-1-与-HTTP-2-的区别" class="headerlink" title="六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别"></a>六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</h3><ul><li><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2 允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和响应，解决了 HTTP&#x2F;1.1 队头阻塞的问题，显著提高了性能。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法压缩请求和响应头，减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源时，主动推送其他它认为客户端可能需要的资源，减少了客户端的请求次数。</li><li><strong>二进制分帧（Binary Framing）</strong>：HTTP&#x2F;2 将所有传输信息分割成更小的消息和帧，并采用二进制编码，使得解析更高效。</li></ul><p>好的，我们来详细补充 <strong>HTTP&#x2F;1.0</strong> 的核心概念，并对整个 HTTP 协议族进行全面的对比和深入解析。</p><hr><h3 id="一、HTTP-协议族演变：从-1-0-到-2-0"><a href="#一、HTTP-协议族演变：从-1-0-到-2-0" class="headerlink" title="一、HTTP 协议族演变：从 1.0 到 2.0"></a>一、HTTP 协议族演变：从 1.0 到 2.0</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的早期版本，它的设计相对简单，主要用于满足基本的网页浏览需求。</p><ul><li><strong>核心特点：</strong><ul><li><strong>非持久连接（Non-persistent Connection）</strong>：这是 HTTP&#x2F;1.0 最显著的特点。每进行一次 HTTP 请求-响应，客户端和服务器之间就会建立一个新的 <strong>TCP 连接</strong>，并在请求完成后立即断开。<ul><li><strong>缺点</strong>：每次请求都需要经过 TCP 三次握手和四次挥手的过程，这带来了巨大的性能开销。如果一个网页包含多个图片、CSS 或 JavaScript 文件，浏览器需要为每个文件单独建立和断开连接，导致页面加载速度慢。</li></ul></li><li><strong>无主机头（No Host Header）</strong>：请求头中没有 <code>Host</code> 字段。这意味着一个 IP 地址只能对应一个域名。如果服务器上有多个网站，就无法通过 IP 地址来区分它们，这在虚拟主机时代是个大问题。</li><li><strong>不支持管线化（Pipelining）</strong>：客户端发送一个请求后，必须等待服务器的响应，才能发送下一个请求。</li></ul></li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>HTTP&#x2F;1.1 协议是对 1.0 的重大改进，解决了其大部分性能瓶颈。</p><ul><li><strong>核心特点：</strong><ul><li><strong>持久连接（Persistent Connection）</strong>：默认情况下，HTTP&#x2F;1.1 会在一次请求-响应之后<strong>保持 TCP 连接不断开</strong>。客户端可以继续在这个连接上发送后续请求。<ul><li><strong>优点</strong>：显著减少了 TCP 连接的建立和断开开销，提高了页面加载速度。这个特性也称为“Keep-Alive”。</li></ul></li><li><strong>支持主机头（Host Header）</strong>：请求头中引入了 <code>Host</code> 字段，允许在同一个 IP 地址上部署多个虚拟主机（域名）。</li><li><strong>支持管线化（Pipelining）</strong>：客户端可以在收到上一个响应之前，连续发送多个请求。<ul><li><strong>缺点</strong>：虽然提高了效率，但存在**队头阻塞（Head-of-Line Blocking）**问题。如果第一个请求处理时间很长，后面的请求即使已经处理完成，也必须等待它的响应，导致整个连接的效率降低。</li></ul></li><li><strong>引入缓存机制</strong>：通过 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等请求头，HTTP&#x2F;1.1 提供了更完善的缓存机制，减少了不必要的请求。</li></ul></li></ul><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0 是为了解决 HTTP&#x2F;1.1 在移动互联网和高并发场景下的性能问题而设计的。它不是对 HTTP&#x2F;1.1 的简单升级，而是对协议底层进行了重构。</p><ul><li><strong>核心特点：</strong><ul><li><strong>多路复用（Multiplexing）</strong>：这是 HTTP&#x2F;2 的核心。它允许在<strong>一个 TCP 连接</strong>上同时处理多个 HTTP 请求和响应。<ul><li><strong>如何实现？</strong>：HTTP&#x2F;2 将所有数据流（Stream）分割成更小的二进制帧（Frame），每个帧都带有唯一的标识符。这样，客户端和服务器可以在同一个连接上交错发送和接收帧，然后根据标识符重新组装，从而彻底解决了 HTTP&#x2F;1.1 的队头阻塞问题。</li></ul></li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法来压缩请求和响应头，尤其是对于重复发送的字段，大大减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源（如 HTML 页面）时，主动推送其他它认为客户端可能需要的资源（如 CSS 和 JS 文件），而无需客户端显式请求，进一步提高了加载速度。</li><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议，而不是文本协议，解析更高效、更不容易出错。</li></ul></li></ul><hr><h3 id="二、HTTP-协议版本对比总结"><a href="#二、HTTP-协议版本对比总结" class="headerlink" title="二、HTTP 协议版本对比总结"></a>二、HTTP 协议版本对比总结</h3><p>理解 HTTP 协议的演变历程，能让你更深刻地体会到 Web 性能优化的方向，以及现代 Web 框架如何利用这些底层协议特性来提供更高效的服务。</p><table><thead><tr><th>特性</th><th>HTTP&#x2F;1.0</th><th>HTTP&#x2F;1.1</th><th>HTTP&#x2F;2.0</th></tr></thead><tbody><tr><td><strong>TCP 连接</strong></td><td>非持久连接</td><td>默认持久连接</td><td>单个 TCP 连接多路复用</td></tr><tr><td><strong>性能瓶颈</strong></td><td>多次握手挥手开销</td><td>队头阻塞</td><td>无</td></tr><tr><td><strong>主机头</strong></td><td>不支持</td><td>支持 (<code>Host</code> Header)</td><td>支持</td></tr><tr><td><strong>并发请求</strong></td><td>串行（一个请求一个连接）</td><td>串行（一个连接一个请求）</td><td>并行（一个连接多个请求）</td></tr><tr><td><strong>数据格式</strong></td><td>文本协议</td><td>文本协议</td><td>二进制协议</td></tr><tr><td><strong>头部</strong></td><td>无压缩</td><td>无压缩</td><td>HPACK 算法压缩</td></tr><tr><td><strong>服务器推送</strong></td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>好的，让我们把所有关于 Servlet 的知识点整合在一起，进行一次最全面、最深入的剖析。我们将从基础概念开始，逐步深入到它的生命周期、配置、核心方法以及与 Servlet 规范相关的其他重要组件。</p><hr><h3 id="Servlet-概述：Java-Web-的核心基石"><a href="#Servlet-概述：Java-Web-的核心基石" class="headerlink" title="Servlet 概述：Java Web 的核心基石"></a>Servlet 概述：Java Web 的核心基石</h3><p><strong>Servlet</strong> 是 Java EE 规范中的一个核心组件，它是一个运行在服务器端的 Java 程序，用于处理 HTTP 请求和生成动态响应。你可以把它看作是所有 Java Web 框架（如 Spring MVC）的底层引擎。</p><p><strong>它的核心作用</strong>是作为客户端（浏览器）和 Java 应用程序之间的“桥梁”。Servlet 容器（如 Tomcat、Jetty）负责监听网络请求，然后将请求分发给相应的 Servlet 进行处理。</p><h3 id="Servlet-的生命周期：由容器严格管理"><a href="#Servlet-的生命周期：由容器严格管理" class="headerlink" title="Servlet 的生命周期：由容器严格管理"></a>Servlet 的生命周期：由容器严格管理</h3><p>一个 Servlet 的生命周期由 Servlet 容器严格管理，通常分为三个阶段：</p><ol><li><strong>初始化（Initialization）</strong><ul><li><strong>时机</strong>：当 Servlet 容器第一次加载 Servlet 类并创建其实例后，立即调用 <code>init()</code> 方法。</li><li><strong>特性</strong>：这个方法<strong>只执行一次</strong>，通常用于加载配置文件、建立数据库连接池等一次性、耗时的任务。如果 <code>init()</code> 方法抛出异常，Servlet 将无法提供服务。</li></ul></li><li><strong>服务（Servicing）</strong><ul><li><strong>时机</strong>：每当一个客户端请求到达时，容器会为该请求创建一个新的线程，并调用 <code>service()</code> 方法。</li><li><strong>特性</strong>：<code>service()</code> 方法是 Servlet 的核心，它会根据请求类型（如 GET、POST）自动调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。由于此方法会被多个线程并发调用，因此访问共享资源时必须注意<strong>线程安全</strong>。</li></ul></li><li><strong>销毁（Destruction）</strong><ul><li><strong>时机</strong>：当 Servlet 容器关闭或决定卸载某个 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><strong>特性</strong>：这个方法也<strong>只执行一次</strong>，用于释放资源，如关闭数据库连接或文件流。</li></ul></li></ol><h3 id="Servlet-的配置和部署：两种主要方式"><a href="#Servlet-的配置和部署：两种主要方式" class="headerlink" title="Servlet 的配置和部署：两种主要方式"></a>Servlet 的配置和部署：两种主要方式</h3><p>为了让容器知道如何加载和映射 Servlet，你需要进行配置。</p><ol><li><strong>web.xml 配置（传统方式）</strong><ul><li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 标签定义 Servlet 类，并使用 <code>&lt;servlet-mapping&gt;</code> 标签将它映射到一个 URL 路径。</li><li><strong>优点</strong>：配置集中，易于管理。</li><li><strong>缺点</strong>：如果 Servlet 很多，<code>web.xml</code> 文件会变得非常庞大。</li></ul></li><li><strong>注解配置（现代方式）</strong><ul><li>从 Servlet 3.0 规范开始，你可以使用 <code>@WebServlet</code> 注解来简化配置。只需在你的 Servlet 类上添加 <code>@WebServlet(&quot;/path&quot;)</code> 注解，容器就会自动识别和配置它。</li><li><strong>优点</strong>：配置简单，代码和配置在一起，提高了可读性。</li></ul></li></ol><h3 id="Servlet-的核心方法：处理请求和响应"><a href="#Servlet-的核心方法：处理请求和响应" class="headerlink" title="Servlet 的核心方法：处理请求和响应"></a>Servlet 的核心方法：处理请求和响应</h3><p>所有 Servlet 都应该实现 <code>javax.servlet.Servlet</code> 接口。通常，我们更常继承 <code>javax.servlet.http.HttpServlet</code>，因为它提供了更方便的 HTTP 请求处理方法。</p><ul><li><code>service(HttpServletRequest req, HttpServletResponse res)</code>：这是核心服务方法，由容器调用。它会根据请求的 HTTP 方法（GET、POST、PUT 等）来调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。</li><li><code>doGet(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 GET 请求。</li><li><code>doPost(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 POST 请求。</li><li><code>doPut(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 PUT 请求。</li><li><code>doDelete(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 DELETE 请求。</li></ul><p>在这些方法中，你可以通过 <code>req</code> (请求) 和 <code>res</code> (响应) 对象来与客户端进行交互。</p><h3 id="Servlet-的请求和响应处理：与客户端交互"><a href="#Servlet-的请求和响应处理：与客户端交互" class="headerlink" title="Servlet 的请求和响应处理：与客户端交互"></a>Servlet 的请求和响应处理：与客户端交互</h3><ul><li><strong>获取请求参数</strong><ul><li><code>req.getParameter(&quot;paramName&quot;)</code>：获取单个参数值。</li><li><code>req.getParameterValues(&quot;paramName&quot;)</code>：获取具有相同名称的多个参数值（如复选框）。</li></ul></li><li><strong>设置响应头</strong><ul><li><code>res.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>：设置响应的内容类型和字符编码。</li><li><code>res.setHeader(&quot;HeaderName&quot;, &quot;HeaderValue&quot;)</code>：设置自定义响应头。</li></ul></li><li><strong>写入响应内容</strong><ul><li><code>res.getWriter()</code>：获取一个 <code>PrintWriter</code>，用于向客户端发送文本响应。</li><li><code>res.getOutputStream()</code>：获取一个 <code>ServletOutputStream</code>，用于向客户端发送二进制响应（如图片、文件）。</li></ul></li></ul><h3 id="Servlet-的核心组件与作用域"><a href="#Servlet-的核心组件与作用域" class="headerlink" title="Servlet 的核心组件与作用域"></a>Servlet 的核心组件与作用域</h3><p>理解 Servlet 规范中的这些组件，能帮助你更合理地管理数据和资源。</p><ol><li><strong>ServletContext (应用上下文)</strong><ul><li><strong>作用</strong>：代表整个 Web 应用，它的生命周期与应用相同。</li><li><strong>作用域</strong>：数据在所有 Servlet、JSP 和 Filter 之间<strong>共享</strong>。</li><li><strong>用途</strong>：存储全局配置和共享数据。</li></ul></li><li><strong>ServletConfig (配置对象)</strong><ul><li><strong>作用</strong>：代表一个 Servlet 独有的配置。</li><li><strong>作用域</strong>：仅在它所关联的 Servlet 内部有效。</li><li><strong>用途</strong>：获取特定 Servlet 的初始化参数。</li></ul></li><li><strong>四大作用域</strong><ul><li><strong>PageContext (页面作用域)</strong>：仅在 JSP 页面内有效。</li><li><strong>HttpServletRequest (请求作用域)</strong>：在一次完整的请求-响应周期内有效，即使请求被转发，数据依然可见。</li><li><strong>HttpSession (会话作用域)</strong>：在同一个浏览器会话中有效，用于存储用户特定数据。</li><li><strong>ServletContext (应用作用域)</strong>：在整个 Web 应用中都有效，用于存储全局数据。</li></ul></li></ol><p>好的，我们来详细、深入地聊聊 Web 开发中至关重要的两个概念：Cookie 和 Session。它们是解决 HTTP 无状态问题的核心方案，但工作机制和应用场景却大不相同。</p><hr><h3 id="Cookie：客户端的“小纸条”"><a href="#Cookie：客户端的“小纸条”" class="headerlink" title="Cookie：客户端的“小纸条”"></a>Cookie：客户端的“小纸条”</h3><p><strong>Cookie</strong> 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时，会自动将该 Cookie 包含在请求中发送回去。</p><h4 id="核心工作机制"><a href="#核心工作机制" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Cookie：</p><p>当用户首次访问网站时，服务器在响应头（Response Header）中添加一个 Set-Cookie 字段。</p><p>比如：Set-Cookie: JSESSIONID&#x3D;abcde12345; Path&#x3D;&#x2F;; HttpOnly</p></li><li><p>浏览器保存 Cookie：</p><p>浏览器接收到响应后，会解析 Set-Cookie 头，并将该信息以键值对的形式存储在本地。</p></li><li><p>浏览器发送 Cookie：</p><p>在后续的请求中，只要请求的域名和路径与 Cookie 的设置相符，浏览器就会自动在请求头（Request Header）中添加 Cookie 字段，将存储的 Cookie 信息发送给服务器。</p><p>比如：Cookie: JSESSIONID&#x3D;abcde12345</p></li></ol><h4 id="Cookie-的优缺点"><a href="#Cookie-的优缺点" class="headerlink" title="Cookie 的优缺点"></a>Cookie 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>减轻服务器压力</strong>：数据存储在客户端，服务器不需要为每个用户维护状态，适用于大规模访问。</li><li><strong>可扩展性强</strong>：无状态，天然适合分布式架构。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>安全性差</strong>：数据以明文形式存储，容易被窃取和篡改。</li><li><strong>容量限制</strong>：单个 Cookie 的大小通常不超过 4KB，且一个域名下的 Cookie 总数也有限制。</li><li><strong>用户可禁用</strong>：如果用户禁用了浏览器 Cookie 功能，相关功能将无法使用。</li></ul></li></ul><hr><h3 id="Session：服务器的“个人档案”"><a href="#Session：服务器的“个人档案”" class="headerlink" title="Session：服务器的“个人档案”"></a>Session：服务器的“个人档案”</h3><p><strong>Session</strong> 是服务器为每个用户创建的一个对象，用于存储特定用户的会话数据。它将用户的状态信息保存在服务器端，并通过一个唯一的 <strong>Session ID</strong> 来识别不同的用户。</p><h4 id="核心工作机制-1"><a href="#核心工作机制-1" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Session：</p><p>当用户首次访问 Web 应用时，服务器会创建一个 HttpSession 对象，并为其分配一个唯一的 Session ID。</p></li><li><p>传递 Session ID：</p><p>服务器将这个 Session ID 以 Cookie 的形式发送给浏览器（这个 Cookie 通常叫 JSESSIONID）。</p><ul><li>如果浏览器禁用了 Cookie，服务器可以通过 <strong>URL 重写</strong>的方式，将 Session ID 附加到每个 URL 的末尾，例如：<code>.../index.jsp;jsessionid=abcde12345</code>。</li></ul></li><li><p>服务器维护 Session：</p><p>Session ID 传递到客户端后，服务器会在内存中或持久化存储中保存这个 HttpSession 对象及其数据。</p></li><li><p>识别用户：</p><p>后续的请求中，浏览器都会带着包含 Session ID 的 Cookie。服务器通过这个 ID 就能从内存中找到对应的 HttpSession 对象，从而获取该用户的状态信息。</p></li></ol><h4 id="Session-的优缺点"><a href="#Session-的优缺点" class="headerlink" title="Session 的优缺点"></a>Session 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>安全性高</strong>：核心数据存储在服务器，客户端只传递一个无法猜解的 ID。</li><li><strong>容量大</strong>：存储在服务器，理论上没有大小限制。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>占用服务器资源</strong>：每个活跃的 Session 都会占用服务器内存，在高并发场景下可能成为瓶颈。</li><li><strong>分布式挑战</strong>：在多台服务器组成的集群环境中，需要额外的机制（如 Session 共享或粘性会话）来确保用户的请求总是被转发到同一个 Session 所在的服务器，或者所有服务器都能访问到 Session 数据。</li></ul></li></ul><hr><h3 id="Cookie-与-Session-的对比总结"><a href="#Cookie-与-Session-的对比总结" class="headerlink" title="Cookie 与 Session 的对比总结"></a>Cookie 与 Session 的对比总结</h3><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td><strong>数据存储位置</strong></td><td>客户端（浏览器）</td><td>服务器端</td></tr><tr><td><strong>安全性</strong></td><td>较低，易被篡改</td><td>较高，数据安全</td></tr><tr><td><strong>数据容量</strong></td><td>较小（~4KB）</td><td>较大，无明显限制</td></tr><tr><td><strong>性能</strong></td><td>轻量，不占用服务器资源</td><td>占用服务器内存，可能影响性能</td></tr><tr><td><strong>可扩展性</strong></td><td>天然无状态，易于扩展</td><td>分布式环境下需要额外配置</td></tr><tr><td><strong>主要用途</strong></td><td>购物车、用户偏好、轻量级状态</td><td>登录状态、权限验证、敏感数据</td></tr></tbody></table><p>好的，我已将 GET 和 POST 请求的所有核心区别整理成一个简洁明了的表格，并补充了更多细节，使其更全面。</p><h3 id="GET-和-POST-请求的全面对比"><a href="#GET-和-POST-请求的全面对比" class="headerlink" title="GET 和 POST 请求的全面对比"></a>GET 和 POST 请求的全面对比</h3><table><thead><tr><th>特性</th><th>GET 请求</th><th>POST 请求</th><th>备注</th></tr></thead><tbody><tr><td><strong>基本作用</strong></td><td>从服务器<strong>获取</strong>资源</td><td>向服务器<strong>提交</strong>数据，通常用于<strong>创建</strong>资源。</td><td>语义不同是所有区别的根本。</td></tr><tr><td><strong>传参方式</strong></td><td>参数附加在 URL 中</td><td>参数放在请求体（Request Body）中</td><td>GET 参数可见，POST 参数隐藏。</td></tr><tr><td><strong>安全性</strong></td><td><strong>不安全</strong>，URL 暴露</td><td><strong>相对安全</strong>，参数隐藏在请求体中</td><td>这里的“安全”指数据不被暴露。</td></tr><tr><td><strong>幂等性</strong></td><td><strong>是</strong>（多次执行结果相同）</td><td><strong>否</strong>（多次执行可能产生新资源）</td><td>幂等性是 RESTful 设计的关键原则。</td></tr><tr><td><strong>浏览器行为</strong></td><td>回退无害，可被记录在历史、收藏为书签。</td><td>回退时通常会提示重新提交，不记录在历史、不可收藏。</td><td>防止意外提交导致数据重复。</td></tr><tr><td><strong>缓存</strong></td><td><strong>可以被缓存</strong></td><td><strong>不会被缓存</strong></td><td>缓存能提高性能，但仅限于只读操作。</td></tr><tr><td><strong>传输数据量</strong></td><td>有长度限制（URL长度限制）</td><td>无长度限制（取决于服务器配置）</td><td>GET 不适合传输大量数据。</td></tr><tr><td><strong>数据编码</strong></td><td>只支持 URL 编码</td><td>支持多种编码（如<code>application/json</code>）</td><td>POST 灵活性高，适合各种数据类型。</td></tr><tr><td><strong>发送文件</strong></td><td>不支持</td><td>支持 (<code>multipart/form-data</code>)</td><td>文件必须通过请求体传输。</td></tr><tr><td><strong>HTTP 报文</strong></td><td>无请求体</td><td>有请求体</td><td>GET 请求报文更小，更轻量。</td></tr><tr><td><strong>TCP&#x2F;IP 协议</strong></td><td>一次性发送所有数据包</td><td>浏览器通常会先发送请求头，服务器响应 100-continue 后再发送请求体</td><td>POST 的分步发送机制可以避免发送不必要的数据。</td></tr></tbody></table><p>好的，我们将以 Servlet 的详细剖析方式，全面、深入地介绍 WebSocket。我们将从它的概念、生命周期、核心 API，到它与 HTTP 的区别以及在现代 Web 中的应用，进行系统性的梳理。</p><hr><h3 id="WebSocket-概述：Web-通信的革命"><a href="#WebSocket-概述：Web-通信的革命" class="headerlink" title="WebSocket 概述：Web 通信的革命"></a>WebSocket 概述：Web 通信的革命</h3><p><strong>WebSocket</strong> 协议是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。与传统的 HTTP 协议不同，它打破了请求-响应的单向模式，使得客户端和服务器可以<strong>实时地双向自由传输数据</strong>。</p><p><strong>它的核心作用</strong>是解决 Web 应用中<strong>实时通信</strong>的需求，例如：聊天应用、在线游戏、股票行情、实时协作工具等。它极大地减少了网络开销，提高了通信效率。</p><h3 id="WebSocket-的核心工作原理"><a href="#WebSocket-的核心工作原理" class="headerlink" title="WebSocket 的核心工作原理"></a>WebSocket 的核心工作原理</h3><p>要理解 WebSocket，必须首先理解它与 HTTP 的关系。</p><ol><li><strong>基于 HTTP 的握手（Handshake）</strong>：<ul><li>WebSocket 的连接建立过程是基于 HTTP 协议的。</li><li>客户端发送一个特殊的 HTTP 请求，其中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 请求头，向服务器请求将 HTTP 协议升级到 WebSocket 协议。</li><li>这是一个**“握手”**过程。</li></ul></li><li><strong>协议升级与持久连接</strong>：<ul><li>如果服务器支持 WebSocket，它会返回一个特殊的 HTTP 响应（状态码 <code>101 Switching Protocols</code>）。</li><li>握手成功后，客户端和服务器之间的 TCP 连接将<strong>保持打开状态</strong>。</li><li>这时，协议就从 HTTP 升级到了 WebSocket，双方可以在这个<strong>持久的 TCP 连接</strong>上自由地双向发送数据，而无需再进行 HTTP 头部开销。</li></ul></li><li><strong>数据帧传输</strong>：<ul><li>WebSocket 协议定义了**数据帧（Data Frames）**的概念。它将数据分割成更小、更轻量级的帧，而不是像 HTTP 那样发送整个报文。</li><li>这样，即使传输少量数据，也不会有很大的协议开销，非常适合实时通信。</li></ul></li></ol><h3 id="WebSocket-的生命周期：事件驱动模型"><a href="#WebSocket-的生命周期：事件驱动模型" class="headerlink" title="WebSocket 的生命周期：事件驱动模型"></a>WebSocket 的生命周期：事件驱动模型</h3><p>WebSocket 的生命周期由客户端和服务器共同维护，由一系列事件驱动：</p><h4 id="1-连接建立（Connection-Establishment）"><a href="#1-连接建立（Connection-Establishment）" class="headerlink" title="1. 连接建立（Connection Establishment）"></a>1. 连接建立（Connection Establishment）</h4><ul><li><strong>客户端</strong>：通过 <code>new WebSocket(url)</code> 建立连接。</li><li><strong>服务器</strong>：当客户端发送握手请求后，服务器处理并接受连接，此时触发 <code>onopen</code> 事件。</li></ul><h4 id="2-数据传输（Data-Transmission）"><a href="#2-数据传输（Data-Transmission）" class="headerlink" title="2. 数据传输（Data Transmission）"></a>2. 数据传输（Data Transmission）</h4><ul><li><strong>发送</strong>：客户端和服务器都可以通过各自的 <code>send()</code> 方法向对方发送数据。</li><li><strong>接收</strong>：当一方接收到数据时，会触发 <code>onmessage</code> 事件。</li></ul><h4 id="3-连接关闭（Connection-Close）"><a href="#3-连接关闭（Connection-Close）" class="headerlink" title="3. 连接关闭（Connection Close）"></a>3. 连接关闭（Connection Close）</h4><ul><li><strong>主动关闭</strong>：客户端或服务器可以调用 <code>close()</code> 方法主动关闭连接。</li><li><strong>异常关闭</strong>：连接可能因网络故障、心跳超时等原因意外关闭。</li><li><strong>事件</strong>：无论是主动还是被动，连接关闭时都会触发 <code>onclose</code> 事件。</li></ul><h3 id="WebSocket-的核心-API（以-JavaScript-为例）"><a href="#WebSocket-的核心-API（以-JavaScript-为例）" class="headerlink" title="WebSocket 的核心 API（以 JavaScript 为例）"></a>WebSocket 的核心 API（以 JavaScript 为例）</h3><p>WebSocket 的 API 设计非常简洁，主要基于事件监听和方法调用。</p><ul><li><strong>new WebSocket(url)</strong>：创建一个 WebSocket 客户端实例。</li><li><strong>websocket.onopen</strong>：连接成功建立时触发。</li><li><strong>websocket.onmessage &#x3D; function(event)</strong>：接收到服务器数据时触发，数据在 <code>event.data</code> 中。</li><li><strong>websocket.onerror</strong>：连接发生错误时触发。</li><li><strong>websocket.onclose</strong>：连接关闭时触发。</li><li><strong>websocket.send(data)</strong>：向服务器发送数据。</li><li><strong>websocket.close()</strong>：关闭连接。</li></ul><h3 id="WebSocket-与-HTTP-的本质区别"><a href="#WebSocket-与-HTTP-的本质区别" class="headerlink" title="WebSocket 与 HTTP 的本质区别"></a>WebSocket 与 HTTP 的本质区别</h3><table><thead><tr><th>特性</th><th>HTTP</th><th>WebSocket</th><th>备注</th></tr></thead><tbody><tr><td><strong>通信模式</strong></td><td><strong>单向</strong>（请求-响应）</td><td><strong>双向</strong>（全双工）</td><td>HTTP 客户端必须先发请求，服务器才能响应。</td></tr><tr><td><strong>连接状态</strong></td><td><strong>无状态</strong>，短连接</td><td><strong>有状态</strong>，长连接</td><td>HTTP 每次请求都需要重新建立连接。</td></tr><tr><td><strong>协议开销</strong></td><td><strong>大</strong>（每次请求都携带头部）</td><td><strong>小</strong>（握手后只传输数据帧）</td><td>HTTP 适合传输大文件，WebSocket 适合小数据频繁传输。</td></tr><tr><td><strong>服务器主动性</strong></td><td><strong>被动</strong>（无法主动推送）</td><td><strong>主动</strong>（可随时推送数据）</td><td>WebSocket 解决了 HTTP 的“服务器推”难题。</td></tr><tr><td><strong>应用场景</strong></td><td>网页浏览、API 调用、文件下载</td><td>聊天、游戏、实时数据更新</td><td></td></tr></tbody></table><h3 id="WebSocket-在现代-Java-Web-中的应用"><a href="#WebSocket-在现代-Java-Web-中的应用" class="headerlink" title="WebSocket 在现代 Java Web 中的应用"></a>WebSocket 在现代 Java Web 中的应用</h3><p>在 Java 后端，WebSocket 通常由专门的框架或容器来实现，如：</p><ul><li><strong>JavaEE 7+ 的 WebSocket API</strong>：提供了 <code>javax.websocket</code> 包，可以直接在 Servlet 容器中开发 WebSocket 应用。</li><li><strong>Spring Framework</strong>：提供了强大的 WebSocket 支持，集成了 STOMP（Simple Text Oriented Messaging Protocol）协议，简化了消息路由和管理。</li></ul><p>在这些框架中，你通常会定义一个 WebSocket 端点（Endpoint），类似于 Servlet，它负责处理连接的建立、消息的接收和发送、以及连接的关闭。</p><p>总而言之，WebSocket 是 HTTP 协议在实时通信领域的有力补充。它通过一次性的握手建立一个持久的双向通道，极大地提高了 Web 应用的交互性和效率，是现代 Web 架构中不可或缺的一部分。</p><p>好的，为了更好地理解 WebSocket 的工作原理，我将提供几个具体的应用场景和相应的代码示例。这些示例将涵盖客户端（JavaScript）和服务器端（Java&#x2F;Spring Boot）的代码，以便你能够完整地看到双向通信是如何实现的。</p><hr><h3 id="示例一：实时聊天应用"><a href="#示例一：实时聊天应用" class="headerlink" title="示例一：实时聊天应用"></a>示例一：实时聊天应用</h3><p>这是 WebSocket 最经典的用例。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>多个用户连接到聊天室，当一个用户发送消息时，服务器将该消息实时广播给所有其他在线用户。</p><h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：当用户在输入框中按下回车，JavaScript 将消息通过 WebSocket 连接发送给服务器。</li><li><strong>服务器</strong>：接收到消息后，遍历所有已连接的 WebSocket 会话，将消息逐一发送给每个会话。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 WebSocket 服务器</span></span><br><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接成功事件</span></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> event.data;</span><br><span class="line">  <span class="type">const</span> <span class="variable">chatBox</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;chat-box&#x27;</span>);</span><br><span class="line">  chatBox.innerHTML += `&lt;p&gt;$&#123;message&#125;&lt;/p&gt;`; <span class="comment">// 将消息添加到聊天框</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已关闭&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.onerror = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket发生错误:&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息函数</span></span><br><span class="line">function <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">input</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;message-input&#x27;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> input.value;</span><br><span class="line">  <span class="keyword">if</span> (message) &#123;</span><br><span class="line">    socket.send(message); <span class="comment">// 通过 WebSocket 发送消息</span></span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回车事件</span></span><br><span class="line">document.getElementById(<span class="string">&#x27;message-input&#x27;</span>).addEventListener(<span class="string">&#x27;keypress&#x27;</span>, function(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="line">    sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有连接的客户端会话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session); <span class="comment">// 添加新会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新连接：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message + <span class="string">&quot; 来自：&quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 遍历所有会话，广播消息</span></span><br><span class="line">        sessions.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session); <span class="comment">// 移除会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接发生错误：&quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="示例二：实时股票行情或数据看板"><a href="#示例二：实时股票行情或数据看板" class="headerlink" title="示例二：实时股票行情或数据看板"></a>示例二：实时股票行情或数据看板</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>客户端连接到服务器，服务器定期或在数据更新时，向所有连接的客户端推送最新的股票价格或监控数据。</p><h4 id="核心逻辑：-1"><a href="#核心逻辑：-1" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：只监听 <code>onmessage</code> 事件，被动接收服务器推送的数据。</li><li><strong>服务器</strong>：在后台启动一个定时任务或数据监听器。当数据变化时，主动通过 WebSocket 连接将新数据发送给客户端。</li></ul><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/stock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;股票行情连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="comment">// 假设服务器发送的是JSON格式的股票数据</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">stockData</span> <span class="operator">=</span> JSON.parse(event.data);</span><br><span class="line">  <span class="type">const</span> <span class="variable">stockPriceElement</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;stock-price&#x27;</span>);</span><br><span class="line">  stockPriceElement.innerText = `当前价格: $&#123;stockData.price&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需 sendMessage 函数，因为是单向被动接收</span></span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/stock&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新股票行情订阅者：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个定时任务，每隔5秒向所有客户端推送数据</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取最新股票价格</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Math.random() * <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;price\&quot;: &quot;</span> + String.format(<span class="string">&quot;%.2f&quot;</span>, price) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有会话，推送数据</span></span><br><span class="line">        sessions.forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个例子清楚地展示了 WebSocket 如何通过<strong>持久连接</strong>和<strong>双向通信</strong>来解决实时应用中的核心痛点。</p><p>好的，让我们详细、清晰地解释<strong>静态资源</strong>和<strong>动态资源</strong>的概念，以及为什么某些服务器或工具只能处理静态资源。</p><hr><h3 id="一、静态资源-Static-Resources"><a href="#一、静态资源-Static-Resources" class="headerlink" title="一、静态资源 (Static Resources)"></a>一、静态资源 (Static Resources)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>静态资源</strong>是指在服务器端<strong>不需要经过任何处理或计算</strong>，就能直接返回给客户端的资源。它们的<strong>内容是固定不变</strong>的，无论何时、被谁请求，服务器返回的都是同一个文件。</p><h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>HTML 文件</strong> (<code>.html</code>)：纯 HTML 代码，浏览器直接渲染。</li><li><strong>CSS 样式表</strong> (<code>.css</code>)：定义网页样式。</li><li><strong>JavaScript 脚本</strong> (<code>.js</code>)：用于网页交互。</li><li><strong>图片</strong> (<code>.jpg</code>, <code>.png</code>, <code>.gif</code>)：图像文件。</li><li><strong>字体文件</strong> (<code>.woff</code>, <code>.ttf</code>)：网页字体。</li><li><strong>视频</strong> (<code>.mp4</code>, <code>.webm</code>)：视频文件。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/styles.css</code>。</li><li>服务器接收到请求，直接从<strong>文件系统</strong>中找到名为 <code>styles.css</code> 的文件。</li><li>服务器将 <code>styles.css</code> 的内容原封不动地返回给客户端。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>高效</strong>：无需服务器计算，直接读取文件，响应速度极快。</li><li><strong>可缓存</strong>：由于内容不变，浏览器、代理服务器都可以对静态资源进行缓存，进一步减少网络传输。</li><li><strong>部署简单</strong>：只需将文件放在服务器的特定目录下即可。</li></ul><h3 id="二、动态资源-Dynamic-Resources"><a href="#二、动态资源-Dynamic-Resources" class="headerlink" title="二、动态资源 (Dynamic Resources)"></a>二、动态资源 (Dynamic Resources)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>动态资源</strong>是指服务器端<strong>需要经过处理、计算或查询数据库</strong>，才能生成并返回给客户端的资源。它们的内容是<strong>可变</strong>的，不同的请求、不同的时间，返回的内容可能不同。</p><h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>Servlet&#x2F;JSP</strong>：Java 后端通过 Servlet 或 JSP 动态生成 HTML。</li><li><strong>PHP 脚本</strong> (<code>.php</code>)：PHP 后端生成 HTML。</li><li><strong>Python&#x2F;Django 视图</strong>：Python 后端处理请求并返回数据。</li><li><strong>RESTful API</strong>：返回 JSON、XML 等格式的数据。</li></ul><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/user/profile?id=123</code>。</li><li>服务器接收到请求，将请求转发给<strong>后端程序</strong>（如 Servlet 容器）。</li><li>后端程序接收请求，根据请求参数 <code>id=123</code> 查询数据库，获取该用户的信息。</li><li>后端程序将数据渲染到 HTML 模板中，或者将数据封装成 JSON 格式。</li><li>后端程序将<strong>动态生成的内容</strong>作为响应返回给服务器。</li><li>服务器将该响应发送给客户端。</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>灵活</strong>：可以根据业务逻辑生成个性化内容。</li><li><strong>消耗资源</strong>：需要消耗 CPU、内存、数据库连接等资源进行计算。</li><li><strong>不可直接缓存</strong>：由于内容可变，通常无法像静态资源那样直接缓存。</li></ul><h3 id="三、是什么东西只能解析静态资源？"><a href="#三、是什么东西只能解析静态资源？" class="headerlink" title="三、是什么东西只能解析静态资源？"></a>三、是什么东西只能解析静态资源？</h3><p>这个问题的核心在于**“解析”<strong>这个词。能“解析”静态资源的，通常指的是</strong>Web 服务器**。</p><ul><li><strong>Web 服务器</strong>：一种软件，它的主要职责是处理 HTTP 请求并返回文件。</li></ul><h4 id="1-纯静态-Web-服务器-Static-Web-Server"><a href="#1-纯静态-Web-服务器-Static-Web-Server" class="headerlink" title="1. 纯静态 Web 服务器 (Static Web Server)"></a>1. 纯静态 Web 服务器 (Static Web Server)</h4><p><strong>这类服务器的核心功能就是提供静态文件服务。</strong> 它们只知道如何根据 URL 路径，去文件系统找到对应的文件，然后返回。</p><ul><li><strong>工作原理</strong>：它们没有内置的后端语言解析器（如 Java 虚拟机、PHP 解释器）。当它们收到一个请求时，只会将 URL 映射到文件目录。如果文件存在，就返回；如果不存在，就返回 404 错误。</li><li><strong>代表</strong>：<strong>Nginx</strong>（作为反向代理或静态文件服务器时）、<strong>Apache HTTP Server</strong>（作为静态文件服务器时）。</li></ul><p><strong>为什么它们不能解析动态资源？</strong></p><p>因为它们<strong>不具备</strong>执行后端代码的能力。例如，当 Nginx 收到一个对 <code>.jsp</code> 文件的请求时，它不知道如何运行 Java 代码来生成 HTML。它只会把 <code>.jsp</code> 文件当作一个普通的文本文件返回给浏览器，浏览器也无法正确地解析。</p><h4 id="2-动态-Web-服务器-Dynamic-Web-Server"><a href="#2-动态-Web-服务器-Dynamic-Web-Server" class="headerlink" title="2. 动态 Web 服务器 (Dynamic Web Server)"></a>2. 动态 Web 服务器 (Dynamic Web Server)</h4><p>这类服务器通常被称为 <strong>“应用服务器”</strong>，它们在 Web 服务器的功能上，<strong>内置了后端语言的运行环境</strong>。</p><ul><li><strong>工作原理</strong>：<ul><li>当它们收到静态资源请求时，行为与静态服务器相同：直接返回文件。</li><li>当它们收到动态资源请求时，会将请求转发给内置的<strong>后端程序运行环境</strong>。例如，Tomcat 会将 <code>.jsp</code> 文件交给 JSP 引擎来编译和执行。</li></ul></li><li><strong>代表</strong>：<strong>Apache Tomcat</strong>、<strong>Jetty</strong>。</li></ul><p>因此，在实际生产环境中，我们经常采用<strong>动静分离</strong>的架构：</p><ul><li><strong>静态资源</strong>（<code>index.html</code>、<code>style.css</code> 等）交给 <strong>Nginx</strong> 这样的高效静态服务器处理。</li><li><strong>动态资源</strong>（<code>api/user</code>, <code>.jsp</code> 等）交给 <strong>Tomcat</strong> 这样的应用服务器处理。</li></ul><p>这样做的目的是，让专业的工具做专业的事：Nginx 擅长高并发的静态文件服务，而 Tomcat 则专注于复杂的动态业务逻辑。</p><p>好的，让我们来系统、全面地梳理前端的核心知识，这不仅是前端工程师的必备技能，也是后端开发者理解整个 Web 应用架构的关键。</p><h3 id="一、基础三剑客：构建网页的基石"><a href="#一、基础三剑客：构建网页的基石" class="headerlink" title="一、基础三剑客：构建网页的基石"></a>一、基础三剑客：构建网页的基石</h3><p>这三者是所有前端技术的基础，就像建筑的钢筋、水泥和水电。</p><h4 id="1-HTML-HyperText-Markup-Language"><a href="#1-HTML-HyperText-Markup-Language" class="headerlink" title="1. HTML (HyperText Markup Language)"></a>1. HTML (HyperText Markup Language)</h4><ul><li><strong>是什么</strong>：超文本标记语言，用于<strong>定义网页的结构和内容</strong>。它由一系列标签（tag）组成，这些标签告诉浏览器如何组织页面内容，如段落、标题、图片、链接等。</li><li><strong>核心概念</strong>：<ul><li><strong>标签（Tags）</strong>：如 <code>&lt;p&gt;</code> (段落), <code>&lt;h1&gt;</code> (一级标题), <code>&lt;img&gt;</code> (图片), <code>&lt;a&gt;</code> (超链接)。</li><li><strong>元素（Elements）</strong>：由开始标签、内容和结束标签组成，例如 <code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>。</li><li><strong>属性（Attributes）</strong>：提供关于元素的额外信息，如 <code>&lt;img src=&quot;image.jpg&quot; alt=&quot;描述&quot;&gt;</code> 中的 <code>src</code> 和 <code>alt</code>。</li><li><strong>语义化（Semantic HTML）</strong>：使用恰当的标签来表达内容的含义，如 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;footer&gt;</code>，这有助于搜索引擎优化（SEO）和无障碍访问。</li></ul></li></ul><h4 id="2-CSS-Cascading-Style-Sheets"><a href="#2-CSS-Cascading-Style-Sheets" class="headerlink" title="2. CSS (Cascading Style Sheets)"></a>2. CSS (Cascading Style Sheets)</h4><ul><li><strong>是什么</strong>：层叠样式表，用于<strong>定义网页的样式和表现</strong>。它告诉浏览器如何显示 HTML 元素，如颜色、字体、布局、大小等。</li><li><strong>核心概念</strong>：<ul><li><strong>选择器（Selectors）</strong>：用于选中要应用样式的 HTML 元素，如 <code>h1</code> (标签选择器), <code>.my-class</code> (类选择器), <code>#my-id</code> (ID 选择器)。</li><li><strong>盒模型（Box Model）</strong>：每个 HTML 元素都被视为一个矩形盒子，包含 <code>content</code>（内容）、<code>padding</code>（内边距）、<code>border</code>（边框）和 <code>margin</code>（外边距）。</li><li><strong>布局（Layout）</strong>：<ul><li><strong>传统布局</strong>：<code>float</code>, <code>position</code>, <code>display</code>。</li><li><strong>现代布局</strong>：<strong>Flexbox</strong> (弹性盒子，用于一维布局) 和 <strong>Grid</strong> (网格系统，用于二维布局)。这两种是目前最主流的布局方式。</li></ul></li><li><strong>响应式设计（Responsive Design）</strong>：使用 <code>@media</code> 查询来根据设备屏幕大小调整样式，使网页在不同设备上都能良好显示。</li></ul></li></ul><h4 id="3-JavaScript-JS"><a href="#3-JavaScript-JS" class="headerlink" title="3. JavaScript (JS)"></a>3. JavaScript (JS)</h4><ul><li><strong>是什么</strong>：一种高级编程语言，用于<strong>实现网页的动态行为和交互</strong>。它可以操作 HTML 和 CSS，处理用户事件，并与服务器进行通信。</li><li><strong>核心概念</strong>：<ul><li><strong>DOM (Document Object Model) 操作</strong>：通过 <code>document</code> 对象，JS 可以获取、修改、添加或删除页面上的 HTML 元素。例如 <code>document.getElementById(&#39;myId&#39;)</code>。</li><li><strong>事件处理（Event Handling）</strong>：响应用户的行为，如点击、输入、鼠标移动等。例如 <code>element.addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>。</li><li><strong>异步编程（Asynchronous Programming）</strong>：处理耗时操作，如网络请求。<ul><li><strong>Callback (回调函数)</strong>：传统方式。</li><li><strong>Promise</strong>：ES6 引入，解决了回调地狱问题。</li><li><strong>async&#x2F;await</strong>：基于 <code>Promise</code> 的语法糖，使异步代码看起来像同步代码，更易读。</li></ul></li><li><strong>AJAX (Asynchronous JavaScript and XML)</strong>：在不重新加载整个页面的情况下，与服务器进行异步通信。现代应用中通常使用 <code>fetch()</code> API 或 <code>Axios</code> 库来发送 JSON 数据。</li></ul></li></ul><hr><h3 id="二、现代前端框架：提升开发效率"><a href="#二、现代前端框架：提升开发效率" class="headerlink" title="二、现代前端框架：提升开发效率"></a>二、现代前端框架：提升开发效率</h3><p>为了处理日益复杂的 Web 应用，开发者通常会使用以下框架。</p><ul><li><strong>React</strong>：由 Facebook 开发，<strong>组件化</strong>、<strong>声明式</strong>的 UI 库。<ul><li><strong>核心</strong>：<strong>组件（Components）</strong>，将 UI 拆分成独立、可复用的部分。</li><li><strong>工作原理</strong>：使用<strong>虚拟 DOM (Virtual DOM)</strong>，在内存中进行计算，然后只更新实际改变的部分，提高了性能。</li><li><strong>生态</strong>：庞大而活跃，有成熟的状态管理（Redux, Zustand）、路由（React Router）等解决方案。</li></ul></li><li><strong>Vue.js</strong>：由尤雨溪开发，易学易用，<strong>渐进式</strong>框架。<ul><li><strong>核心</strong>：<strong>响应式数据绑定</strong>，数据改变，视图自动更新。</li><li><strong>特点</strong>：上手快，文档友好，社区生态完善。</li></ul></li><li><strong>Angular</strong>：由 Google 开发，<strong>全能型</strong>框架。<ul><li><strong>核心</strong>：提供了完整的解决方案，包括路由、依赖注入、状态管理等。</li><li><strong>特点</strong>：适合大型企业级应用，学习曲线相对陡峭。</li></ul></li></ul><hr><h3 id="三、工程化：高效协作和自动化"><a href="#三、工程化：高效协作和自动化" class="headerlink" title="三、工程化：高效协作和自动化"></a>三、工程化：高效协作和自动化</h3><p>现代前端开发已经不仅仅是写代码，还需要使用一系列工具来提高效率。</p><ul><li><strong>包管理器</strong>：<code>npm</code>, <code>yarn</code>, <code>pnpm</code>。用于管理项目依赖。</li><li><strong>构建工具</strong>：<ul><li><strong>Webpack</strong>：将多个模块打包成一个或多个文件，并能处理资源依赖、代码压缩等。</li><li><strong>Vite</strong>：基于 ES Modules 的新一代构建工具，开发模式下速度极快。</li></ul></li><li><strong>转译工具</strong>：<strong>Babel</strong>。将 ES6+ 的代码转译为浏览器兼容的 ES5 代码。</li><li><strong>代码规范</strong>：<strong>ESLint</strong> (代码风格检查), <strong>Prettier</strong> (代码格式化)。</li><li><strong>版本控制</strong>：<strong>Git</strong>。用于团队协作和代码版本管理。</li></ul><p>好的，让我们详细、全面地介绍 CSS 选择器。选择器是 CSS 的核心，掌握它才能精确地控制网页样式。我们将从基础到高级，系统地梳理不同类型的选择器及其用法。</p><hr><h3 id="一、基础选择器-Basic-Selectors"><a href="#一、基础选择器-Basic-Selectors" class="headerlink" title="一、基础选择器 (Basic Selectors)"></a>一、基础选择器 (Basic Selectors)</h3><p>这些是 CSS 中最简单、最常用的选择器，用于直接选中元素。</p><h4 id="1-元素选择器-Type-Selector"><a href="#1-元素选择器-Type-Selector" class="headerlink" title="1. 元素选择器 (Type Selector)"></a>1. 元素选择器 (Type Selector)</h4><ul><li><strong>作用</strong>：根据元素的标签名来选择元素。</li><li><strong>语法</strong>：<code>element_name &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>p &#123; color: blue; &#125;</code>：选中所有 <code>&lt;p&gt;</code> 元素。</li><li><code>h1 &#123; font-size: 24px; &#125;</code>：选中所有 <code>&lt;h1&gt;</code> 元素。</li></ul></li></ul><h4 id="2-类选择器-Class-Selector"><a href="#2-类选择器-Class-Selector" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>class</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>.class_name &#123; ... &#125;</code></li><li><strong>特点</strong>：一个元素可以有多个类名，类名可以重复使用，非常灵活。</li><li><strong>示例</strong>：<ul><li><code>.highlight &#123; background-color: yellow; &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>highlight</code> 的元素。</li></ul></li></ul><h4 id="3-ID-选择器-ID-Selector"><a href="#3-ID-选择器-ID-Selector" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>id</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>#id_name &#123; ... &#125;</code></li><li><strong>特点</strong>：在 HTML 文档中，一个 <code>id</code> 属性的值必须是<strong>唯一的</strong>。</li><li><strong>示例</strong>：<ul><li><code>#header &#123; height: 100px; &#125;</code>：选中 <code>id</code> 为 <code>header</code> 的唯一元素。</li></ul></li></ul><h4 id="4-通用选择器-Universal-Selector"><a href="#4-通用选择器-Universal-Selector" class="headerlink" title="4. 通用选择器 (Universal Selector)"></a>4. 通用选择器 (Universal Selector)</h4><ul><li><strong>作用</strong>：选择页面上的所有元素。</li><li><strong>语法</strong>：<code>* &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>* &#123; margin: 0; padding: 0; &#125;</code>：清除所有元素的默认外边距和内边距，常用于 CSS 重置。</li></ul></li></ul><hr><h3 id="二、组合选择器-Combinators"><a href="#二、组合选择器-Combinators" class="headerlink" title="二、组合选择器 (Combinators)"></a>二、组合选择器 (Combinators)</h3><p>这些选择器用于根据元素之间的关系来选择元素，如父子关系、兄弟关系等。</p><h4 id="1-后代选择器-Descendant-Selector"><a href="#1-后代选择器-Descendant-Selector" class="headerlink" title="1. 后代选择器 (Descendant Selector)"></a>1. 后代选择器 (Descendant Selector)</h4><ul><li><strong>作用</strong>：选择某个元素内部的<strong>所有</strong>后代元素（包括子元素、孙子元素等）。</li><li><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，用<strong>空格</strong>分隔。</li><li><strong>示例</strong>：<ul><li><code>ul li &#123; list-style-type: none; &#125;</code>：选中所有 <code>&lt;ul&gt;</code> 内部的 <code>&lt;li&gt;</code> 元素。</li></ul></li></ul><h4 id="2-子选择器-Child-Selector"><a href="#2-子选择器-Child-Selector" class="headerlink" title="2. 子选择器 (Child Selector)"></a>2. 子选择器 (Child Selector)</h4><ul><li><strong>作用</strong>：选择某个元素的<strong>直接子元素</strong>。</li><li><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，用 <code>&gt;</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>ul &gt; li &#123; list-style-type: none; &#125;</code>：只选中 <code>&lt;ul&gt;</code> 的直接子元素 <code>&lt;li&gt;</code>。</li><li><strong>区别</strong>：与后代选择器相比，更加精确，性能也更好。</li></ul></li></ul><h4 id="3-相邻兄弟选择器-Adjacent-Sibling-Selector"><a href="#3-相邻兄弟选择器-Adjacent-Sibling-Selector" class="headerlink" title="3. 相邻兄弟选择器 (Adjacent Sibling Selector)"></a>3. 相邻兄弟选择器 (Adjacent Sibling Selector)</h4><ul><li><strong>作用</strong>：选择紧接在另一个元素后面的<strong>兄弟元素</strong>。</li><li><strong>语法</strong>：<code>element + adjacent_element &#123; ... &#125;</code>，用 <code>+</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 + p &#123; margin-top: 0; &#125;</code>：选中紧跟在 <code>&lt;h1&gt;</code> 后的第一个 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><h4 id="4-通用兄弟选择器-General-Sibling-Selector"><a href="#4-通用兄弟选择器-General-Sibling-Selector" class="headerlink" title="4. 通用兄弟选择器 (General Sibling Selector)"></a>4. 通用兄弟选择器 (General Sibling Selector)</h4><ul><li><strong>作用</strong>：选择某个元素后面<strong>所有</strong>的兄弟元素（不限于紧邻的）。</li><li><strong>语法</strong>：<code>element ~ sibling &#123; ... &#125;</code>，用 <code>~</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 ~ p &#123; margin-top: 0; &#125;</code>：选中 <code>&lt;h1&gt;</code> 后的所有 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><hr><h3 id="三、属性选择器-Attribute-Selectors"><a href="#三、属性选择器-Attribute-Selectors" class="headerlink" title="三、属性选择器 (Attribute Selectors)"></a>三、属性选择器 (Attribute Selectors)</h3><p>这些选择器根据元素的属性及其值来选择元素。</p><ul><li><strong>[attribute]</strong>：选择具有该属性的元素。<ul><li><code>[title] &#123; ... &#125;</code>：选中所有具有 <code>title</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：选择具有特定属性和值的元素。<ul><li><code>input[type=&quot;text&quot;] &#123; ... &#125;</code>：选中所有 <code>type</code> 属性值为 <code>text</code> 的 <code>&lt;input&gt;</code> 元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：选择属性值中包含特定<strong>独立单词</strong>的元素。<ul><li><code>[class~=&quot;box&quot;] &#123; ... &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>box</code> 这个独立单词的元素（如 <code>class=&quot;card box&quot;</code>）。</li></ul></li><li><strong>[attribute|&#x3D;”value”]</strong>：选择属性值以特定字符串开头（后跟连字符 <code>-</code>）的元素。<ul><li><code>[lang|=&quot;en&quot;] &#123; ... &#125;</code>：选中 <code>lang</code> 属性值为 <code>en</code> 或 <code>en-us</code> 等的元素。</li></ul></li><li><strong>[attribute^&#x3D;”value”]</strong>：选择属性值以特定字符串开头的元素。<ul><li><code>a[href^=&quot;https&quot;] &#123; ... &#125;</code>：选中所有 <code>href</code> 属性以 <code>https</code> 开头的 <code>&lt;a&gt;</code> 元素。</li></ul></li><li><strong>[attribute$&#x3D;”value”]</strong>：选择属性值以特定字符串结尾的元素。<ul><li><code>img[src$=&quot;.png&quot;] &#123; ... &#125;</code>：选中所有 <code>src</code> 属性以 <code>.png</code> 结尾的 <code>&lt;img&gt;</code> 元素。</li></ul></li><li><strong>[attribute*&#x3D;”value”]</strong>：选择属性值中包含特定字符串的元素。<ul><li><code>[title*=&quot;hello&quot;] &#123; ... &#125;</code>：选中所有 <code>title</code> 属性值中包含 <code>hello</code> 的元素。</li></ul></li></ul><hr><h3 id="四、伪类选择器-Pseudo-class-Selectors"><a href="#四、伪类选择器-Pseudo-class-Selectors" class="headerlink" title="四、伪类选择器 (Pseudo-class Selectors)"></a>四、伪类选择器 (Pseudo-class Selectors)</h3><p>伪类用于选择元素的<strong>特定状态</strong>。</p><ul><li><strong>a:link</strong>：未访问的链接。</li><li><strong>a:visited</strong>：已访问的链接。</li><li><strong>a:hover</strong>：鼠标悬停在元素上。</li><li><strong>a:active</strong>：元素被点击时。</li><li><strong>element:focus</strong>：元素获得焦点时（常用于表单）。</li><li><strong>:nth-child(n)</strong>：选择属于其父元素的第 n 个子元素。</li><li><strong>:first-child</strong>：选择属于其父元素的第一个子元素。</li><li><strong>:last-child</strong>：选择属于其父元素的最后一个子元素。</li><li><strong>:not(selector)</strong>：选择不匹配指定选择器的元素。</li><li><strong>:empty</strong>：选择没有子元素或文本内容的元素。</li></ul><hr><h3 id="五、伪元素选择器-Pseudo-element-Selectors"><a href="#五、伪元素选择器-Pseudo-element-Selectors" class="headerlink" title="五、伪元素选择器 (Pseudo-element Selectors)"></a>五、伪元素选择器 (Pseudo-element Selectors)</h3><p>伪元素用于选择元素的<strong>特定部分</strong>。</p><ul><li><strong>::first-line</strong>：选择元素的第一行。</li><li><strong>::first-letter</strong>：选择元素的首个字母。</li><li><strong>::before</strong>：在元素的内容前面插入生成的内容。</li><li><strong>::after</strong>：在元素的内容后面插入生成的内容。</li></ul><hr><h3 id="优先级与层叠"><a href="#优先级与层叠" class="headerlink" title="优先级与层叠"></a>优先级与层叠</h3><p>当多个选择器选中同一个元素并应用不同的样式时，浏览器会根据**优先级（Specificity）**来决定最终样式。</p><ul><li><strong>优先级计算</strong>：<ul><li><code>!important</code>：最高优先级。</li><li><strong>行内样式</strong>：1000</li><li><strong>ID 选择器</strong>：100</li><li><strong>类、属性、伪类选择器</strong>：10</li><li><strong>元素、伪元素选择器</strong>：1</li><li><strong>通用选择器</strong>：0</li></ul></li><li><strong>举例</strong>：<ul><li><code>p &#123; color: red; &#125;</code>（优先级 1）</li><li><code>.highlight &#123; color: blue; &#125;</code>（优先级 10）</li><li><code>#main p &#123; color: green; &#125;</code>（优先级 101）</li></ul></li></ul><p>在这个例子中，即使 <code>p</code> 的样式最先声明，但 <code>main p</code> 的优先级最高，因此 <code>&lt;p id=&quot;main&quot;&gt;</code> 的字体颜色最终会是绿色。</p><p>好的，让我们来全面、深入地介绍 Maven，并剖析一些关键细节以及面试中可能遇到的问题。</p><hr><h3 id="一、Maven-核心概念"><a href="#一、Maven-核心概念" class="headerlink" title="一、Maven 核心概念"></a>一、Maven 核心概念</h3><h4 id="1-什么是-Maven？"><a href="#1-什么是-Maven？" class="headerlink" title="1. 什么是 Maven？"></a>1. 什么是 Maven？</h4><p>Maven 是一个<strong>项目管理和构建自动化工具</strong>。它提供了一套标准化的项目结构、统一的构建生命周期，并依赖于一个<strong>中央仓库</strong>来管理项目所需的依赖。</p><p>它的核心思想是**“约定优于配置”（Convention over Configuration）**，这意味着它有一套默认的项目目录结构和构建流程。只要你遵循这些约定，就可以用很少的配置完成复杂的构建任务。</p><h4 id="2-为什么需要-Maven？"><a href="#2-为什么需要-Maven？" class="headerlink" title="2. 为什么需要 Maven？"></a>2. 为什么需要 Maven？</h4><p>在 Maven 出现之前，Java 项目的构建非常混乱：</p><ul><li><strong>项目结构不统一</strong>：每个项目都有自己的目录结构，新成员需要花时间熟悉。</li><li><strong>依赖管理混乱</strong>：需要手动下载所有 JAR 包，并添加到项目中，非常容易出错。</li><li><strong>构建过程不统一</strong>：编译、测试、打包等操作需要手动执行脚本，效率低下。</li></ul><p>Maven 通过<strong>标准化</strong>解决了这些问题：</p><ul><li><strong>标准化的项目结构</strong>：所有 Maven 项目都遵循相同的目录结构，如 <code>src/main/java</code>、<code>src/test/java</code> 等。</li><li><strong>统一的依赖管理</strong>：通过在 <code>pom.xml</code> 中声明依赖，Maven 会自动从仓库下载并管理。</li><li><strong>标准化的构建生命周期</strong>：定义了一系列标准的构建阶段（如 <code>compile</code>, <code>test</code>, <code>package</code>），可以一键执行。</li></ul><hr><h3 id="二、Maven-的核心组成部分"><a href="#二、Maven-的核心组成部分" class="headerlink" title="二、Maven 的核心组成部分"></a>二、Maven 的核心组成部分</h3><h4 id="1-POM-Project-Object-Model"><a href="#1-POM-Project-Object-Model" class="headerlink" title="1. POM (Project Object Model)"></a>1. POM (Project Object Model)</h4><ul><li><strong>概念</strong>：<code>pom.xml</code> 文件是 Maven 项目的<strong>核心配置文件</strong>。它定义了项目的元数据、依赖、插件、构建配置等所有信息。</li><li><strong>重要标签</strong>：<ul><li><code>&lt;project&gt;</code>：根元素。</li><li><code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, <code>&lt;version&gt;</code>：项目的唯一标识符，通常称为 <strong>GAV 坐标</strong>。</li><li><code>&lt;packaging&gt;</code>：打包类型，如 <code>jar</code>, <code>war</code>, <code>pom</code>。</li><li><code>&lt;dependencies&gt;</code>：定义项目所需的依赖。</li><li><code>&lt;parent&gt;</code>：继承父 POM，实现依赖的统一管理。</li><li><code>&lt;build&gt;</code>：定义构建过程，如插件配置。</li></ul></li></ul><h4 id="2-依赖管理-Dependency-Management"><a href="#2-依赖管理-Dependency-Management" class="headerlink" title="2. 依赖管理 (Dependency Management)"></a>2. 依赖管理 (Dependency Management)</h4><ul><li><strong>概念</strong>：通过在 <code>&lt;dependencies&gt;</code> 中定义 GAV 坐标，Maven 会自动从本地或远程仓库下载依赖。</li><li><strong>传递性依赖</strong>：如果你的项目依赖 A，A 又依赖 B，Maven 会自动将 B 也下载下来。这是其强大的地方，但有时也可能导致版本冲突。</li><li><strong><dependencyManagement></strong>：这是一个非常重要的标签，通常在<strong>父 POM</strong> 中使用。它只定义依赖的版本，但<strong>不实际引入</strong>。子项目继承后，只需声明 <code>&lt;artifactId&gt;</code> 和 <code>&lt;groupId&gt;</code>，版本号会自动继承，这能确保整个项目所有模块的依赖版本一致。</li></ul><h4 id="3-仓库-Repositories"><a href="#3-仓库-Repositories" class="headerlink" title="3. 仓库 (Repositories)"></a>3. 仓库 (Repositories)</h4><p>Maven 仓库是用来存放所有依赖 JAR 包的地方。它分为三种：</p><ul><li><strong>本地仓库 (Local Repository)</strong>：<code>~/.m2/repository</code>，首次下载的依赖会存放在这里，后续构建时会优先从这里读取。</li><li><strong>远程仓库 (Remote Repository)</strong>：<ul><li><strong>中央仓库 (Central Repository)</strong>：Maven 官方维护的公共仓库，包含了绝大多数常用的开源库。</li><li><strong>私服 (Private Repository)</strong>：企业内部搭建的仓库，用于存放公司内部的 JAR 包或作为中央仓库的代理，加快下载速度。</li></ul></li></ul><h4 id="4-生命周期与阶段-Lifecycle-Phases"><a href="#4-生命周期与阶段-Lifecycle-Phases" class="headerlink" title="4. 生命周期与阶段 (Lifecycle &amp; Phases)"></a>4. 生命周期与阶段 (Lifecycle &amp; Phases)</h4><p>Maven 有一套标准的构建生命周期，分为三个：</p><ul><li><strong>clean</strong>：清理项目。<ul><li><code>clean</code>：删除 <code>target</code> 目录。</li></ul></li><li><strong>default</strong>：构建项目。<ul><li><code>validate</code></li><li><code>compile</code>：编译源代码。</li><li><code>test</code>：运行测试。</li><li><code>package</code>：打包。</li><li><code>install</code>：安装到本地仓库。</li><li><code>deploy</code>：部署到远程仓库。</li></ul></li><li><strong>site</strong>：生成项目站点。</li></ul><p><strong>重要规则</strong>：执行某个阶段时，它之前的所有阶段都会按顺序执行。例如，<code>mvn package</code> 会自动执行 <code>compile</code> 和 <code>test</code>。</p><hr><h3 id="三、面试常见问题与回答技巧"><a href="#三、面试常见问题与回答技巧" class="headerlink" title="三、面试常见问题与回答技巧"></a>三、面试常见问题与回答技巧</h3><h4 id="1-Maven-的-GAV-坐标是什么？有什么作用？"><a href="#1-Maven-的-GAV-坐标是什么？有什么作用？" class="headerlink" title="1. Maven 的 GAV 坐标是什么？有什么作用？"></a>1. Maven 的 GAV 坐标是什么？有什么作用？</h4><ul><li><strong>回答</strong>：GAV 坐标是 Maven 项目的唯一标识符，由 <code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, 和 <code>&lt;version&gt;</code> 三个元素组成。</li><li><strong>作用</strong>：<ul><li><strong>唯一性</strong>：确保每个项目和每个版本的依赖在仓库中都是唯一的。</li><li><strong>定位</strong>：Maven 通过 GAV 坐标来查找和下载依赖。</li><li><strong>传递性</strong>：在传递性依赖中，通过 GAV 坐标来识别和处理依赖关系。</li></ul></li></ul><h4 id="2-和-有什么区别？"><a href="#2-和-有什么区别？" class="headerlink" title="2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？"></a>2. <code>&lt;dependencyManagement&gt;</code> 和 <code>&lt;dependencies&gt;</code> 有什么区别？</h4><ul><li><strong>回答</strong>：这是面试高频问题，需要清晰地说明两者的职责。</li><li><strong><dependencies></strong>：<strong>实际引入</strong>依赖。它用于在当前项目中添加一个具体的依赖，Maven 会立即下载并使用它。</li><li><strong><dependencyManagement></strong>：<strong>只定义版本</strong>。它只声明依赖的版本，但<strong>不实际引入</strong>。其主要目的是<strong>统一管理子模块的依赖版本</strong>。子模块继承父 POM 后，只需在自己的 <code>&lt;dependencies&gt;</code> 中声明 <code>&lt;groupId&gt;</code> 和 <code>&lt;artifactId&gt;</code>，版本号会自动从父 POM 中继承，这避免了版本不一致的问题。</li></ul><h4 id="3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？"><a href="#3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？" class="headerlink" title="3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？"></a>3. 什么是 Maven 的生命周期？<code>mvn install</code> 和 <code>mvn deploy</code> 有什么区别？</h4><ul><li><strong>回答</strong>：</li><li><strong>生命周期</strong>：Maven 有三个标准的生命周期：<code>clean</code>、<code>default</code> 和 <code>site</code>。其中 <code>default</code> 包含了从编译到部署的所有阶段。</li><li><strong>mvn install</strong>：执行 <code>default</code> 生命周期到 <code>install</code> 阶段。它会将项目打包，并安装到<strong>本地仓库</strong>。这样，其他本地项目就可以依赖这个包。</li><li><strong>mvn deploy</strong>：执行 <code>default</code> 生命周期到 <code>deploy</code> 阶段。它会将项目打包，并部署到<strong>远程仓库</strong>（私服或中央仓库）。这使得其他团队成员或项目可以从远程仓库获取并使用这个包。</li></ul><h4 id="4-Maven-依赖冲突如何解决？"><a href="#4-Maven-依赖冲突如何解决？" class="headerlink" title="4. Maven 依赖冲突如何解决？"></a>4. Maven 依赖冲突如何解决？</h4><ul><li><strong>回答</strong>：当多个依赖间接引入了同一个库的不同版本时，就会发生依赖冲突。</li><li><strong>解决策略</strong>：<ul><li><strong>依赖调解（Dependency Mediation）</strong>：Maven 的默认规则是“<strong>路径最短者优先</strong>”。即在依赖树中，路径最短的那个版本会被选中。</li><li><strong>手动排除（Exclusion）</strong>：如果默认规则不能解决问题，可以在 <code>&lt;dependency&gt;</code> 标签内使用 <code>&lt;exclusions&gt;</code> 标签手动排除有问题的传递性依赖。</li><li><strong>手动引入（Declaration）</strong>：在 <code>&lt;dependencies&gt;</code> 中明确声明需要使用的版本。Maven 的另一个规则是“<strong>最近声明者优先</strong>”，即如果两个依赖路径长度相同，先声明的那个会被使用。但更好的做法是直接在父 POM 的 <code>&lt;dependencyManagement&gt;</code> 中统一版本。</li></ul></li></ul><p>好的，我们来详细梳理你提供的这份关于会话技术的笔记，并按照你要求的逻辑，以一种更清晰、更专业的面试回答或技术讲解的方式进行重新组织和补充。</p><hr><h3 id="一、会话技术概述：解决-HTTP-无状态问题"><a href="#一、会话技术概述：解决-HTTP-无状态问题" class="headerlink" title="一、会话技术概述：解决 HTTP 无状态问题"></a>一、会话技术概述：解决 HTTP 无状态问题</h3><p>HTTP 协议本身是无状态的，它不记得上一次请求的任何信息。为了在多次请求之间共享数据并识别用户，引入了两种核心的会话技术：客户端会话（Cookie）和服务器端会话（Session）。</p><h3 id="二、客户端会话：Cookie"><a href="#二、客户端会话：Cookie" class="headerlink" title="二、客户端会话：Cookie"></a>二、客户端会话：Cookie</h3><p><strong>核心概念</strong>：Cookie 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时会自动将该 Cookie 携带在请求中。</p><h4 id="1-关于-Cookie-的几个常见问题"><a href="#1-关于-Cookie-的几个常见问题" class="headerlink" title="1. 关于 Cookie 的几个常见问题"></a>1. 关于 Cookie 的几个常见问题</h4><ul><li><strong>一次请求响应可以发送多个 Cookie 吗？</strong><ul><li><strong>回答</strong>：<strong>可以</strong>。服务器可以在一个响应中通过多个 <code>Set-Cookie</code> 响应头来设置多个 Cookie。浏览器会分别存储这些 Cookie，并在后续请求中将它们全部发送给服务器。</li></ul></li><li><strong>Cookie 支持中文传输吗？</strong><ul><li><strong>回答</strong>：<strong>在大多数现代服务器和浏览器中都支持。</strong> 在早期的 Servlet 容器（如 Tomcat 8.0 之前），Cookie 不能直接存储中文，需要手动进行 URL 编码（<code>URLEncoder</code>）和解码（<code>URLDecoder</code>）。<strong>在 Tomcat 8.0 及以后版本</strong>，容器默认支持 UTF-8 编码，可以直接存储中文。</li></ul></li><li><strong>Cookie 的过期时间如何设置？</strong><ul><li><strong>回答</strong>：通过 <code>response.addCookie(cookie)</code> 方法，并调用 <code>cookie.setMaxAge(int expiry)</code> 方法来设置。<ul><li><code>expiry &gt; 0</code>：表示 Cookie 将被<strong>持久化</strong>到客户端硬盘，有效期为 <code>expiry</code> 秒。即使浏览器关闭，Cookie 依然存在，直到过期。</li><li><code>expiry = 0</code>：表示<strong>立即删除</strong>该 Cookie。常用于退出登录功能。</li><li><code>expiry &lt; 0</code>：<strong>默认值</strong>。表示 Cookie 只在内存中存在，当<strong>浏览器关闭时</strong>，该 Cookie 就会被删除。</li></ul></li></ul></li></ul><h4 id="2-Cookie-的特点"><a href="#2-Cookie-的特点" class="headerlink" title="2. Cookie 的特点"></a>2. Cookie 的特点</h4><ul><li><strong>存储位置</strong>：存储在客户端（浏览器）。</li><li><strong>大小限制</strong>：单个 Cookie 最大约 4KB。</li><li><strong>数量限制</strong>：一个服务器最多可以向一个浏览器保存 20 个 Cookie，一个浏览器最多可以保存 300 个 Cookie（这些是早期的规范，现代浏览器已放宽，但仍有限制）。</li><li><strong>安全性</strong>：数据以明文形式存储，且容易被用户修改，安全性较差。</li></ul><h4 id="3-Cookie-案例：获取上一次访问时间"><a href="#3-Cookie-案例：获取上一次访问时间" class="headerlink" title="3. Cookie 案例：获取上一次访问时间"></a>3. Cookie 案例：获取上一次访问时间</h4><p>这个案例是经典的 Cookie 用法。</p><ul><li><strong>首次访问</strong>：服务器接收请求，判断 Cookie 中没有记录上次访问时间。服务器创建一个新的 Cookie，存储当前时间，并将其发送给浏览器。</li><li><strong>再次访问</strong>：浏览器自动将上次存储的 Cookie 发送给服务器。服务器读取 Cookie，获取上次访问时间，并将其显示给用户。然后，服务器可以更新 Cookie 的时间，再次发送给浏览器。</li></ul><h3 id="三、服务器端会话：HttpSession"><a href="#三、服务器端会话：HttpSession" class="headerlink" title="三、服务器端会话：HttpSession"></a>三、服务器端会话：HttpSession</h3><p><strong>核心概念</strong>：Session 是服务器端为每个客户端创建的一个对象，用于在一次会话的多个请求之间存储和共享数据。</p><h4 id="1-Session-的快速使用"><a href="#1-Session-的快速使用" class="headerlink" title="1. Session 的快速使用"></a>1. Session 的快速使用</h4><ul><li><strong>获取对象</strong>：通过 <code>HttpServletRequest</code> 对象的 <code>getSession()</code> 方法来获取 <code>HttpSession</code> 对象。</li><li><strong>使用对象（域对象）</strong>：Session 是一个<strong>域对象</strong>，提供了以下方法：<ul><li><code>void setAttribute(String name, Object value)</code>：将数据以键值对形式存储到 Session 中。</li><li><code>Object getAttribute(String name)</code>：根据键名获取存储的数据。</li><li><code>void removeAttribute(String name)</code>：根据键名删除存储的数据。</li></ul></li></ul><h4 id="2-Session-的失效时间"><a href="#2-Session-的失效时间" class="headerlink" title="2. Session 的失效时间"></a>2. Session 的失效时间</h4><ul><li><p><strong>服务器关闭</strong>：当服务器关闭时，所有 Session 对象都会被销毁。</p></li><li><p><strong>手动失效</strong>：调用 <code>session.invalidate()</code> 方法，可以立即强制 Session 失效。常用于用户退出登录。</p></li><li><p><strong>默认失效时间</strong>：默认情况下，Session 有一个超时时间，通常是 30 分钟。如果客户端在 30 分钟内没有向服务器发送任何请求，Session 就会自动失效。这个时间可以在 <code>web.xml</code> 中配置。</p></li><li><p>对的 👍，在 **Java Web 应用（Servlet 容器，比如 Tomcat）**里，<code>Session</code> 的默认失效时间通常是 <strong>30 分钟</strong>。</p><p>要修改它，可以在 <code>web.xml</code> 中配置 <code>&lt;session-config&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- session 过期时间设置（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>📌 说明：</p><ul><li><code>60</code> 表示 Session 在 <strong>60 分钟</strong>无请求时会自动失效。</li><li>默认值是 <strong>30</strong> 分钟，如果不配置，就走默认。</li><li>这个配置对所有用户 Session 都生效。</li></ul><h3 id="🔧-在代码里动态设置（单个-Session）"><a href="#🔧-在代码里动态设置（单个-Session）" class="headerlink" title="🔧 在代码里动态设置（单个 Session）"></a>🔧 在代码里动态设置（单个 Session）</h3><p>除了在 <code>web.xml</code> 里全局配置，还可以针对某个用户的 Session 动态修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">120</span> * <span class="number">60</span>); <span class="comment">// 单位：秒，这里是 2 小时</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="🔧-特殊情况"><a href="#🔧-特殊情况" class="headerlink" title="🔧 特殊情况"></a>🔧 特殊情况</h3><ul><li>如果 <code>session-timeout</code> 设置为 <strong>0</strong> → Session 永不超时（危险 ⚠️，容易导致内存泄露）。</li><li>如果设置为 <strong>负数</strong>（如 -1） → 表示 Session 仅在浏览器关闭时销毁（有些容器支持，有些不支持。</li></ul><h4 id="3-Session-的特点"><a href="#3-Session-的特点" class="headerlink" title="3. Session 的特点"></a>3. Session 的特点</h4><ul><li><strong>存储位置</strong>：存储在服务器端。</li><li><strong>大小限制</strong>：可以存储任意类型、任意大小的数据（受限于服务器内存）。</li><li><strong>安全性</strong>：由于数据存储在服务器，客户端只传递一个 Session ID，安全性相对较高。</li></ul><h4 id="4-面试题：Cookie-和-Session-的区别？"><a href="#4-面试题：Cookie-和-Session-的区别？" class="headerlink" title="4. 面试题：Cookie 和 Session 的区别？"></a>4. 面试题：Cookie 和 Session 的区别？</h4><ul><li><strong>存储位置</strong>：Cookie 存储在<strong>客户端</strong>，Session 存储在<strong>服务器端</strong>。</li><li><strong>数据大小</strong>：Cookie 的大小<strong>有限制</strong>（约 4KB），Session 的大小<strong>没有限制</strong>。</li><li><strong>安全性</strong>：Session <strong>相对安全</strong>，Cookie <strong>相对不安全</strong>。因为 Session ID 难以被猜测，而 Cookie 存储的数据是明文。</li><li><strong>服务器开销</strong>：Session 会占用服务器内存，在高并发场景下可能成为性能瓶颈；而 Cookie 不占用服务器资源。</li></ul><h3 id="四、Servlet-三大域对象的关系（按照你的逻辑）"><a href="#四、Servlet-三大域对象的关系（按照你的逻辑）" class="headerlink" title="四、Servlet 三大域对象的关系（按照你的逻辑）"></a>四、Servlet 三大域对象的关系（按照你的逻辑）</h3><p><strong>域对象</strong>（Scope Object）是指那些可以用来在不同组件之间共享数据的对象。Servlet 规范提供了三个这样的对象，它们的生命周期不同，从而决定了数据的共享范围。</p><ul><li><strong>request 域</strong>：生命周期最短。数据只能在<strong>一次请求-响应</strong>的周期内共享。即使请求被转发（forward），数据也依然可见。</li><li><strong>session 域</strong>：生命周期中等。数据可以在<strong>一次会话</strong>（多个请求）之间共享。只要浏览器不关闭，且 Session 未超时或失效，数据就一直存在。</li><li><strong>servletContext 域</strong>：生命周期最长。数据可以在<strong>整个 Web 应用</strong>中共享。从 Web 应用启动到关闭，数据都一直存在。</li></ul><p><strong>三大域对象之间的关系是包含关系，即 request &lt; session &lt; servletContext。</strong></p><ul><li><strong>request 包含于 session</strong>：一个 Session 中可以有多个请求。</li><li><strong>session 包含于 servletContext</strong>：一个 Web 应用（ServletContext）中可以有多个 Session。</li></ul><p>这个关系图清晰地展示了它们各自的生命周期和数据共享范围，是理解 Servlet 域对象的关键。</p><p>啊哈～你这个场景就是 <strong>同一个库的两个版本必须共存</strong>，典型的 “深度 JAR hell” 🚨。<br> 比如：</p><ul><li>你的系统用到 <strong>老版本 log4j</strong>，</li><li>但某个第三方库硬性依赖 <strong>新版本 log4j</strong>。</li></ul><p>这时候如果放到同一个 classpath 里，肯定会冲突。解决思路主要有三类：</p><hr><h2 id="✅-两个版本-JAR-共存的解决方案"><a href="#✅-两个版本-JAR-共存的解决方案" class="headerlink" title="✅ 两个版本 JAR 共存的解决方案"></a>✅ 两个版本 JAR 共存的解决方案</h2><h3 id="1-ClassLoader-隔离（推荐方式）"><a href="#1-ClassLoader-隔离（推荐方式）" class="headerlink" title="1. ClassLoader 隔离（推荐方式）"></a>1. <strong>ClassLoader 隔离</strong>（推荐方式）</h3><p>利用 <strong>不同的类加载器</strong> 来隔离两个版本的依赖，让它们互不干扰。</p><ul><li><p><strong>Web 容器隔离</strong>：</p><ul><li>把一个版本放在 <code>WEB-INF/lib</code>，另一个放在全局 <code>lib/ext</code>。</li><li>通过 parent-first &#x2F; parent-last 策略控制加载。</li></ul></li><li><p><strong>自定义 ClassLoader</strong>：</p><ul><li><p>用 <code>URLClassLoader</code> 指定不同版本 JAR 的路径。</p></li><li><p>哪个模块需要哪个版本，就用哪个 ClassLoader。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLClassLoader loaderV1 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-old.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null // 不委托父加载器</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">URLClassLoader loaderV2 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-new.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz1 = loaderV1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">Class&lt;?&gt; clazz2 = loaderV2.loadClass(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>👉 OSGi、Spring Boot 的 <strong>ClassLoader 层级</strong>就是用这种方法解决多版本依赖的。</p><hr><h3 id="2-包重定位（Shading-Relocation）"><a href="#2-包重定位（Shading-Relocation）" class="headerlink" title="2. 包重定位（Shading &#x2F; Relocation）"></a>2. <strong>包重定位（Shading &#x2F; Relocation）</strong></h3><p>把其中一个版本的包路径 <strong>改名</strong>，让 JVM 认为它是完全不同的类库。</p><ul><li><p>工具：</p><ul><li><code>jarjar</code></li><li>Maven Shade（即使你不用 Maven，也可以单独跑插件）</li><li>Gradle Shadow</li></ul></li><li><p>原理：自动把 <code>org.apache.commons</code> 改成 <code>myproject.shaded.org.apache.commons</code>。</p></li><li><p>示例（JarJar 规则）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule org.apache.log4j.** com.myapp.shaded.log4j.@1</span><br></pre></td></tr></table></figure></li></ul><p>这样，项目就能同时用 <code>log4j-1.2</code> 和 <code>log4j-2.x</code>。</p><hr><h3 id="3-服务解耦-模块化"><a href="#3-服务解耦-模块化" class="headerlink" title="3. 服务解耦 &#x2F; 模块化"></a>3. <strong>服务解耦 &#x2F; 模块化</strong></h3><p>如果两个版本都要在 <strong>同一个 JVM 里用</strong>，但 ClassLoader 太麻烦：</p><ul><li><strong>拆分成微服务 &#x2F; 子进程</strong>，让不同进程使用不同版本的依赖。</li><li>或者在 <strong>Java 9+ 模块系统 (JPMS)</strong> 下，给不同模块声明不同依赖，避免直接冲突。</li></ul><hr><h2 id="🚀-实际建议"><a href="#🚀-实际建议" class="headerlink" title="🚀 实际建议"></a>🚀 实际建议</h2><ul><li>如果你是 <strong>自己开发的项目</strong> → 用 <strong>包重定位</strong> 比较简单。</li><li>如果是 <strong>插件式系统 &#x2F; 容器运行</strong> → 用 <strong>ClassLoader 隔离</strong>。</li><li>如果是 <strong>重量级系统</strong>（比如需要不同版本的 JDBC 驱动） → 拆进程更干净。</li></ul><hr><p>要不要我帮你写一个 <strong>最小可运行的 Java Demo</strong>（两个版本 JAR 同时运行，通过 ClassLoader 隔离）？这样你可以直接跑起来看看效果。</p><p>好的，我将根据您提供的这份详尽的笔记，以更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、CSS-选择器概述：精准定位网页元素"><a href="#一、CSS-选择器概述：精准定位网页元素" class="headerlink" title="一、CSS 选择器概述：精准定位网页元素"></a>一、CSS 选择器概述：精准定位网页元素</h3><p><strong>选择器</strong>是 CSS 的核心，它用于<strong>精确地选择 HTML 文档中的元素</strong>，并为其应用样式。掌握不同类型的选择器及其组合，是高效编写 CSS 代码的关键。</p><h3 id="二、基础选择器-Basic-Selectors"><a href="#二、基础选择器-Basic-Selectors" class="headerlink" title="二、基础选择器 (Basic Selectors)"></a>二、基础选择器 (Basic Selectors)</h3><p>基础选择器用于根据最基本的属性（标签、类、ID）来选择元素。</p><h4 id="1-标签选择器-Type-Selector"><a href="#1-标签选择器-Type-Selector" class="headerlink" title="1. 标签选择器 (Type Selector)"></a>1. 标签选择器 (Type Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的<strong>标签名称</strong>来匹配。</p></li><li><p><strong>优点</strong>：简单、直接，可以一次性选中所有同类型的元素。</p></li><li><p><strong>缺点</strong>：过于笼统，无法对个别元素进行精确控制。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; color: red; &#125; /* 所有&lt;div&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-类选择器-Class-Selector-1"><a href="#2-类选择器-Class-Selector-1" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的 <code>class</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>高度复用</strong>：可以在多个元素上使用同一个类名。</li><li><strong>灵活</strong>：一个元素可以拥有多个类名，用空格分隔。</li></ul></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cl1 &#123; color: red; &#125; /* 所有class属性包含cl1的元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-ID-选择器-ID-Selector-1"><a href="#3-ID-选择器-ID-Selector-1" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的 <code>id</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：<strong>唯一性</strong>，精确地选中文档中唯一的元素。</p></li><li><p><strong>缺点</strong>：不具复用性，一个 ID 在文档中只能出现一次。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p1 &#123; color: red; &#125; /* id为p1的唯一元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-通配符选择器-Universal-Selector"><a href="#4-通配符选择器-Universal-Selector" class="headerlink" title="4. 通配符选择器 (Universal Selector)"></a>4. 通配符选择器 (Universal Selector)</h4><ul><li><p><strong>原理</strong>：匹配文档中<strong>所有</strong>的元素。</p></li><li><p><strong>优点</strong>：可以快速设置全局样式，常用于重置浏览器默认样式。</p></li><li><p><strong>缺点</strong>：性能开销大，因为浏览器需要遍历所有元素，应谨慎使用。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125; /* 清除所有元素的内外边距 */</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="三、组合选择器-Combinators"><a href="#三、组合选择器-Combinators" class="headerlink" title="三、组合选择器 (Combinators)"></a>三、组合选择器 (Combinators)</h3><p>组合选择器通过符号连接多个选择器，根据元素之间的关系来匹配。</p><h4 id="1-交集选择器-Intersection-Selector"><a href="#1-交集选择器-Intersection-Selector" class="headerlink" title="1. 交集选择器 (Intersection Selector)"></a>1. 交集选择器 (Intersection Selector)</h4><ul><li><p><strong>原理</strong>：同时满足多个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1selector2 &#123; ... &#125;</code>，中间<strong>没有空格</strong>。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.cl1 &#123; color: red; &#125; /* 既是&lt;div&gt;标签，又拥有cl1这个class的元素 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-并集选择器-Union-Selector"><a href="#2-并集选择器-Union-Selector" class="headerlink" title="2. 并集选择器 (Union Selector)"></a>2. 并集选择器 (Union Selector)</h4><ul><li><p><strong>原理</strong>：匹配所有满足其中任意一个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1, selector2 &#123; ... &#125;</code>，以<strong>逗号</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, p &#123; color: red; &#125; /* 所有&lt;a&gt;标签和所有&lt;p&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-子选择器-Child-Selector"><a href="#3-子选择器-Child-Selector" class="headerlink" title="3. 子选择器 (Child Selector)"></a>3. 子选择器 (Child Selector)</h4><ul><li><p><strong>原理</strong>：匹配<strong>直接</strong>子元素。</p></li><li><p><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，以 <code>&gt;</code> 符号分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer &gt; span &#123; color: red; &#125; /* 只选中id为outer的&lt;div&gt;的直接子元素&lt;span&gt; */</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-后代选择器-Descendant-Selector"><a href="#4-后代选择器-Descendant-Selector" class="headerlink" title="4. 后代选择器 (Descendant Selector)"></a>4. 后代选择器 (Descendant Selector)</h4><ul><li><p><strong>原理</strong>：匹配所有位于祖先元素内部的<strong>所有后代</strong>元素。</p></li><li><p><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，以<strong>空格</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer span &#123; color: red; &#125; /* 选中id为outer的&lt;div&gt;内部的所有&lt;span&gt;，无论嵌套多深 */</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="四、属性选择器-Attribute-Selectors"><a href="#四、属性选择器-Attribute-Selectors" class="headerlink" title="四、属性选择器 (Attribute Selectors)"></a>四、属性选择器 (Attribute Selectors)</h3><p>属性选择器根据元素的属性及其值来匹配。</p><ul><li><strong>[attribute]</strong>：匹配具有该属性的元素。<ul><li>示例：<code>[class]</code> 匹配所有具有 <code>class</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：匹配属性值完全相等的元素。<ul><li>示例：<code>[type=&quot;text&quot;]</code> 匹配 <code>type</code> 属性值恰好为 <code>&quot;text&quot;</code> 的元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：匹配属性值中包含该<strong>独立单词</strong>的元素。</li><li><strong>[attribute^&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>开头</strong>的元素。</li><li><strong>[attribute$&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>结尾</strong>的元素。</li><li><strong>[attribute*&#x3D;”value”]</strong>：匹配属性值中包含该字符串的<strong>任意位置</strong>的元素。</li></ul><hr><h3 id="五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors"><a href="#五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors" class="headerlink" title="五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)"></a>五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</h3><ul><li><strong>伪类</strong>：用<strong>一个冒号 :</strong>，表示元素在<strong>特定状态</strong>下的样式。<ul><li><strong>:link</strong>：未访问的链接。</li><li><strong>:visited</strong>：已访问的链接。</li><li><strong>:hover</strong>：鼠标悬停状态。</li><li><strong>:active</strong>：被点击状态。</li><li><strong>:focus</strong>：获得焦点状态（常用于表单）。</li></ul></li><li><strong>伪元素</strong>：用<strong>两个冒号 ::</strong>，表示元素的<strong>特定部分</strong>。<ul><li><strong>::before</strong> 和 <strong>::after</strong>：在元素内容的前后插入内容。</li><li><strong>::first-line</strong>：元素的文本第一行。</li><li><strong>::first-letter</strong>：元素的文本第一个字母。</li></ul></li></ul><hr><h3 id="六、选择器优先级-Specificity"><a href="#六、选择器优先级-Specificity" class="headerlink" title="六、选择器优先级 (Specificity)"></a>六、选择器优先级 (Specificity)</h3><p>这是 CSS 的核心机制，决定了当多个规则应用到同一个元素时，哪一个会生效。</p><ul><li><strong>计算规则</strong>：优先级由<strong>选择器的类型</strong>和<strong>数量</strong>决定。<ol><li><strong>行内样式</strong>：优先级最高，为 <code>1000</code>。</li><li><strong>ID 选择器</strong>：优先级为 <code>100</code>。</li><li><strong>类、属性、伪类选择器</strong>：优先级为 <code>10</code>。</li><li><strong>元素、伪元素选择器</strong>：优先级为 <code>1</code>。</li><li><strong>通用选择器 *</strong>：优先级为 <code>0</code>。</li></ol></li><li><strong>!important</strong>：最高优先级，但会破坏层叠机制，应<strong>避免使用</strong>。</li></ul><p>如何计算：</p><p>将每个选择器的优先级数字相加，得到一个最终的权重值。权重值越高的规则越优先。</p><ul><li>示例：<ul><li><code>p</code>：权重 <code>1</code>。</li><li><code>.cl1</code>：权重 <code>10</code>。</li><li><code>div.cl1</code>：权重 <code>1 + 10 = 11</code>。</li><li><code>#p1</code>：权重 <code>100</code>。</li><li><code>#outer span</code>：权重 <code>100 + 1 = 101</code>。</li></ul></li></ul><p><strong>!important</strong> 会凌驾于所有这些规则之上。当你遇到样式不生效的问题时，首先要检查优先级，其次是是否有 <code>!important</code> 的存在。</p><p>好的，让我们来详细、深入地解释 <strong>BOM</strong> 和 <strong>DOM</strong> 这两个 JavaScript 在浏览器中操作网页的核心概念。</p><hr><h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>BOM</strong>，即<strong>浏览器对象模型</strong>，是 JavaScript 用于<strong>操作浏览器窗口</strong>的一套 API。它没有统一的标准，而是由各个浏览器厂商各自实现的。BOM 的核心是 <code>window</code> 对象，它既代表了浏览器窗口本身，也是 JavaScript 全局作用域的唯一对象。</p><h4 id="2-BOM-的核心对象与功能"><a href="#2-BOM-的核心对象与功能" class="headerlink" title="2. BOM 的核心对象与功能"></a>2. BOM 的核心对象与功能</h4><p>BOM 提供了以下关键对象，用于与浏览器进行交互：</p><ul><li><strong>window 对象</strong>：<ul><li><strong>全局对象</strong>：<code>window</code> 是 JavaScript 的全局对象，所有全局变量和函数都是 <code>window</code> 对象的属性和方法。</li><li><strong>窗口控制</strong>：<code>window.open()</code> (打开新窗口), <code>window.close()</code> (关闭当前窗口)。</li><li><strong>定时器</strong>：<code>setTimeout()</code> 和 <code>setInterval()</code>，用于延迟或重复执行代码。</li><li><strong>导航与位置</strong>：<code>window.location</code>，用于获取和修改当前页面的 URL。</li></ul></li><li><strong>location 对象</strong>：<ul><li><strong>URL 信息</strong>：提供了当前 URL 的详细信息，如 <code>location.href</code> (完整 URL), <code>location.protocol</code> (协议), <code>location.hostname</code> (主机名), <code>location.pathname</code> (路径)。</li><li><strong>页面跳转</strong>：<code>location.href = &#39;new_url&#39;</code> 或 <code>location.assign(&#39;new_url&#39;)</code> (有历史记录), <code>location.replace(&#39;new_url&#39;)</code> (不留历史记录), <code>location.reload()</code> (刷新页面)。</li></ul></li><li><strong>history 对象</strong>：<ul><li><strong>历史记录</strong>：提供了对浏览器历史记录的访问。</li><li><strong>导航</strong>：<code>history.back()</code> (后退), <code>history.forward()</code> (前进), <code>history.go(n)</code> (前进或后退 n 页)。</li></ul></li><li><strong>navigator 对象</strong>：<ul><li><strong>浏览器信息</strong>：提供了关于浏览器本身的信息，如 <code>navigator.userAgent</code> (用户代理字符串), <code>navigator.platform</code> (操作系统), <code>navigator.onLine</code> (是否在线)。</li></ul></li><li><strong>screen 对象</strong>：<ul><li><strong>屏幕信息</strong>：提供了关于用户屏幕的信息，如 <code>screen.width</code> (屏幕宽度), <code>screen.height</code> (屏幕高度)。</li></ul></li></ul><h4 id="3-BOM-的特点"><a href="#3-BOM-的特点" class="headerlink" title="3. BOM 的特点"></a>3. BOM 的特点</h4><ul><li><strong>没有标准</strong>：BOM 没有 W3C 的正式标准，不同浏览器可能在实现上存在差异。</li><li><strong>以 window 为核心</strong>：所有 BOM 对象都是 <code>window</code> 对象的属性。</li></ul><hr><h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>DOM</strong>，即<strong>文档对象模型</strong>，是 JavaScript 用于<strong>操作 HTML 或 XML 文档</strong>的一套 API。它将整个 HTML 文档解析为一个<strong>树形结构</strong>，每个 HTML 标签、属性和文本都成为了树中的一个节点（Node）。DOM 是一个由 W3C 制定的标准。</p><h4 id="2-DOM-的核心对象与功能"><a href="#2-DOM-的核心对象与功能" class="headerlink" title="2. DOM 的核心对象与功能"></a>2. DOM 的核心对象与功能</h4><p>DOM 的核心是 <code>document</code> 对象，它是整个文档的入口。</p><ul><li><strong>document 对象</strong>：<ul><li><strong>DOM 树的根节点</strong>：代表整个 HTML 文档。</li><li><strong>元素获取</strong>：提供了多种方法来获取页面上的元素：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：通过 ID 获取单个元素。</li><li><code>document.getElementsByClassName(&#39;class&#39;)</code>：通过类名获取元素集合。</li><li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：通过标签名获取元素集合。</li><li><code>document.querySelector(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取第一个匹配的元素。</li><li><code>document.querySelectorAll(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取所有匹配的元素。</li></ul></li></ul></li><li><strong>元素节点（Element Nodes）</strong>：<ul><li><strong>操作元素</strong>：提供了操作 HTML 元素的方法和属性：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容。</li><li><code>element.style.color</code>：修改元素的行内样式。</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;val&#39;)</code>：设置元素的属性。</li><li><code>element.addEventListener(&#39;event&#39;, handler)</code>：添加事件监听器。</li></ul></li></ul></li><li><strong>DOM 树操作</strong>：<ul><li><strong>创建</strong>：<code>document.createElement(&#39;tag&#39;)</code> (创建新元素)。</li><li><strong>添加</strong>：<code>parent.appendChild(child)</code> (添加子元素)。</li><li><strong>删除</strong>：<code>parent.removeChild(child)</code> (删除子元素)。</li><li><strong>替换</strong>：<code>parent.replaceChild(newChild, oldChild)</code> (替换子元素)。</li></ul></li></ul><h4 id="3-DOM-的特点"><a href="#3-DOM-的特点" class="headerlink" title="3. DOM 的特点"></a>3. DOM 的特点</h4><ul><li><strong>有标准</strong>：DOM 是由 W3C 制定的标准，因此在不同浏览器中的实现差异较小。</li><li><strong>树形结构</strong>：将 HTML 文档抽象为树形结构，使得我们可以通过编程的方式像操作树一样操作网页。</li></ul><hr><h3 id="BOM-和-DOM-的核心区别与联系"><a href="#BOM-和-DOM-的核心区别与联系" class="headerlink" title="BOM 和 DOM 的核心区别与联系"></a>BOM 和 DOM 的核心区别与联系</h3><table><thead><tr><th>特性</th><th>BOM (Browser Object Model)</th><th>DOM (Document Object Model)</th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td><strong>操作浏览器窗口</strong></td><td><strong>操作网页文档内容</strong></td></tr><tr><td><strong>核心对象</strong></td><td><code>window</code></td><td><code>document</code></td></tr><tr><td><strong>标准化</strong></td><td>无统一标准（各浏览器实现不同）</td><td>有 W3C 标准</td></tr><tr><td><strong>层级关系</strong></td><td><code>window</code> 包含了 <code>location</code>, <code>history</code>, <code>navigator</code> 等，<strong>也包含了 document 对象</strong>。</td><td><code>document</code> 包含了 HTML 元素的树形结构。</td></tr></tbody></table><p>它们的关系：</p><p>BOM 是 DOM 的超集。window 对象是所有 JavaScript 对象的全局对象，它包含了 document 对象。换句话说，window.document 就是 document。因此，当我们使用 document 对象来操作网页时，实际上是通过 window 对象来访问的。</p><p>这个关系可以理解为：</p><p>window -&gt; 浏览器窗口</p><p>document -&gt; 窗口中加载的文档</p><p>掌握 BOM 和 DOM 是成为一个合格前端工程师的基础，它们是 JavaScript 驱动 Web 页面交互的两个最重要的工具。</p><p>好的，我将根据您提供的这份 JS 学习笔记，以一种更深入、更条理化的方式，逐一进行详细的展开和补充。这不仅是对知识点的梳理，也包含了其背后的原理和一些进阶用法，使其更具面试和实战价值。</p><hr><h3 id="一、JavaScript-中的数据类型"><a href="#一、JavaScript-中的数据类型" class="headerlink" title="一、JavaScript 中的数据类型"></a>一、JavaScript 中的数据类型</h3><h4 id="1-基础数据类型（原始数据类型）"><a href="#1-基础数据类型（原始数据类型）" class="headerlink" title="1. 基础数据类型（原始数据类型）"></a>1. 基础数据类型（原始数据类型）</h4><ul><li><p><strong>number 类型</strong>：</p><ul><li><strong>深入</strong>：JS 采用 IEEE 754 标准的双精度 64 位浮点数来表示所有数字。这意味着它<strong>没有单独的整数类型</strong>，所有数字都是浮点数。</li><li><code>NaN</code> (Not a Number)：表示非数字值。需要注意的是，<code>typeof NaN</code> 结果是 <code>number</code>。<code>NaN</code> 不等于自身，<code>NaN === NaN</code> 结果为 <code>false</code>。</li><li><code>Infinity</code>：表示正无穷大，<code>+Infinity</code> 和 <code>-Infinity</code> 分别表示正负无穷大。</li><li><code>0.1 + 0.2 !== 0.3</code>：由于浮点数表示的精度问题，这个经典问题需要注意。</li></ul></li><li><p><strong>boolean 类型</strong>：</p><ul><li><strong>深入</strong>：<code>true</code> 和 <code>false</code>。在条件判断中，所有数据类型都会被隐式转换为布尔值。</li></ul></li><li><p><strong>undefined 类型</strong>：</p><ul><li><strong>深入</strong>：表示一个<strong>未定义</strong>的变量或变量<strong>未被赋值</strong>。<code>typeof undefined</code> 结果为 <code>undefined</code>。它是一个值也是一个类型。</li><li><code>null</code>：与 <code>undefined</code> 的区别在于，<code>null</code> 是一种<strong>意图</strong>，表示变量被显式地赋予了“空”值。<code>typeof null</code> 结果为 <code>object</code>，这是一个历史遗留的 bug。</li></ul></li><li><p><strong>string 类型</strong>：</p><ul><li><p><strong>深入</strong>：JS 中<strong>没有字符类型</strong>。字符串是不可变的，一旦创建就不能修改。</p></li><li><p><strong>反引号（     ）</strong>：ES6 引入，支持<strong>模板字面量</strong>。它允许在字符串中嵌入变量和表达式，并支持多行书写，极大提升了字符串拼接的便利性。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;张三&quot;;</span><br><span class="line">console.log(`你好，我的名字是$&#123;name&#125;。`);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h4><ul><li><p><strong>转换为 number</strong>：<code>Number(value)</code></p><ul><li><strong>深入</strong>：会尝试将参数转换为数字。非数字字符串会返回 <code>NaN</code>。<code>null</code> 转为 <code>0</code>，<code>undefined</code> 转为 <code>NaN</code>。</li></ul></li><li><p><strong>转换为 boolean</strong>：<code>Boolean(value)</code></p><ul><li><strong>深入</strong>：所有能被转换为 <code>false</code> 的值被称为<strong>假值（Falsy Value）</strong>。</li><li><strong>假值列表</strong>：<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code>, <code>&#39;&#39;</code> (空字符串)。</li><li><strong>真值（Truthy Value）</strong>：除上述假值外，所有值都是真值，包括空数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code>。</li></ul></li><li><p><strong>转换为 string</strong>：<code>String(value)</code> 或 <code>value + &#39;&#39;</code></p><ul><li><strong>深入</strong>：<code>value + &#39;&#39;</code> 是最常用的技巧，利用了 JS 的隐式类型转换。</li></ul></li><li><p><strong>parseInt 和 parseFloat</strong>：</p><ul><li><p><strong>深入</strong>：这两个函数专门用于从<strong>字符串开头</strong>解析出数字。</p></li><li><p><code>parseInt</code>：解析<strong>整数</strong>。遇到第一个非数字字符就停止解析。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;100px&quot;); // 100</span><br><span class="line">parseInt(&quot;a100&quot;);  // NaN</span><br></pre></td></tr></table></figure></li><li><p><code>parseFloat</code>：解析<strong>浮点数</strong>。遇到第一个非数字字符（除了小数点）就停止解析。</p></li></ul></li></ul><h3 id="二、JavaScript-中的弹出框"><a href="#二、JavaScript-中的弹出框" class="headerlink" title="二、JavaScript 中的弹出框"></a>二、JavaScript 中的弹出框</h3><p>这些是浏览器提供的 BOM API。</p><ul><li><code>alert(message)</code>：<strong>警告框</strong>。阻塞式，显示一条消息，不返回任何值。</li><li><code>prompt(message, default_value)</code>：<strong>询问框</strong>。返回用户输入的字符串，如果点击“取消”则返回 <code>null</code>。</li><li><code>confirm(message)</code>：<strong>确认框</strong>。返回一个布尔值，用户点击“确定”返回 <code>true</code>，点击“取消”返回 <code>false</code>。</li></ul><h3 id="三、条件运算符：-和"><a href="#三、条件运算符：-和" class="headerlink" title="三、条件运算符：== 和 ==="></a>三、条件运算符：<code>==</code> 和 <code>===</code></h3><ul><li><p><strong>&#x3D;&#x3D;（宽松相等）</strong>：只比较<strong>值</strong>，不比较类型。它在比较前会进行<strong>隐式类型转换</strong>。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot;;     // true</span><br><span class="line">null == undefined; // true</span><br></pre></td></tr></table></figure></li><li><p><strong>&#x3D;&#x3D;&#x3D;（严格相等）</strong>：既比较<strong>值</strong>，也比较<strong>类型</strong>。不会进行类型转换。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 === &quot;5&quot;;    // false</span><br><span class="line">null === undefined; // false</span><br></pre></td></tr></table></figure></li><li><p><strong>面试建议</strong>：在实际开发中，<strong>强烈建议使用 &#x3D;&#x3D;&#x3D;</strong>，以避免不必要的类型转换带来的 bug。</p></li></ul><h3 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h3><ul><li><strong>字符串</strong>：<ul><li><strong>深入</strong>：<code>string</code> 是一个<strong>对象</strong>，拥有 <code>length</code> 属性和许多方法（如 <code>split()</code>, <code>slice()</code>, <code>indexOf()</code> 等），但它<strong>不可变</strong>。</li></ul></li><li><strong>数组</strong>：<ul><li><strong>特点</strong>：<ol><li><strong>动态长度</strong>：JS 数组的长度是可变的，你可以随时添加或删除元素。</li><li><strong>异构性</strong>：一个数组可以存放不同数据类型的元素，如 <code>[1, &quot;hello&quot;, true]</code>。</li></ol></li><li><strong>方法</strong>：<ul><li><code>push()</code>, <code>pop()</code>：在数组<strong>末尾</strong>添加和删除。</li><li><code>unshift()</code>, <code>shift()</code>：在数组<strong>开头</strong>添加和删除。</li><li><code>splice()</code>：功能强大的方法，用于删除、替换或添加元素。</li><li><code>forEach()</code>, <code>map()</code>, <code>filter()</code>：常用的遍历方法。</li></ul></li></ul></li></ul><h3 id="五、函数和对象"><a href="#五、函数和对象" class="headerlink" title="五、函数和对象"></a>五、函数和对象</h3><ul><li><strong>函数</strong>：<ul><li><strong>深入</strong>：在 JS 中，函数是<strong>一等公民（First-Class Citizens）</strong>。这意味着函数可以作为参数传递、作为返回值，也可以赋值给变量。</li></ul></li><li><strong>对象</strong>：<ul><li><strong>深入</strong>：JS 对象是<strong>键值对</strong>的集合。键是字符串，值可以是任意类型。</li><li><strong>访问属性</strong>：<ul><li>点语法：<code>obj.prop</code>。</li><li>中括号语法：<code>obj[&#39;prop&#39;]</code>。后者适用于键名包含特殊字符或动态键名的情况。</li></ul></li></ul></li></ul><h3 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h3><ul><li><strong>setTimeout(callback, delay)</strong>：<ul><li><strong>用途</strong>：只执行<strong>一次</strong>。</li><li><strong>深入</strong>：<code>delay</code> 参数是<strong>最小延迟时间</strong>。由于 JS 是单线程的，如果主线程被阻塞，<code>callback</code> 的执行会延迟。</li></ul></li><li><strong>setInterval(callback, delay)</strong>：<ul><li><strong>用途</strong>：<strong>重复</strong>执行。</li><li><strong>深入</strong>：每次执行完回调函数后，<code>setInterval</code> 都会将下一个回调任务放入队列。</li></ul></li></ul><h3 id="七、ES6-新特性（重要）"><a href="#七、ES6-新特性（重要）" class="headerlink" title="七、ES6 新特性（重要）"></a>七、ES6 新特性（重要）</h3><ul><li><strong>let 和 const</strong>：<ul><li><strong>var 的问题</strong>：全局作用域，可以被重复声明，有变量提升。</li><li><strong>let</strong>：<strong>块级作用域</strong>（<code>&#123;&#125;</code> 内），不能重复声明，没有变量提升。</li><li><strong>const</strong>：<strong>块级作用域</strong>，用于声明<strong>常量</strong>。一旦声明，其引用地址不能改变。</li></ul></li><li><strong>字符串模板字面量</strong>：使用反引号（<code>     </code>）创建多行字符串和嵌入变量。</li><li><strong>箭头函数</strong>：<ul><li><strong>语法</strong>：<code>const func = (param) =&gt; &#123; ... &#125;</code>。</li><li><strong>this 指向</strong>：箭头函数<strong>没有自己的 this</strong>，它会捕获其所在上下文的 <code>this</code> 值。这解决了传统函数中 <code>this</code> 绑定复杂的问题。</li></ul></li><li><strong>可变参数</strong>：<code>...args</code>，用于函数接收不确定数量的参数。</li></ul><h3 id="八、DOM"><a href="#八、DOM" class="headerlink" title="八、DOM"></a>八、DOM</h3><ul><li><strong>什么是 DOM</strong>：<ul><li><strong>深入</strong>：DOM 是浏览器将 HTML 文档解析后生成的<strong>树形结构</strong>，是 JavaScript 操作网页的接口。HTML 文件是文本，DOM 是一个对象，可以被 JS 编程控制。</li></ul></li><li><strong>DOM 操作</strong>：<ul><li><strong>获取标签对象</strong>：<ul><li><code>document.getElementById()</code></li><li><code>document.getElementsByClassName()</code></li><li><code>document.querySelector()</code> (更常用)</li></ul></li><li><strong>操作属性</strong>：<ul><li><code>element.attribute = &#39;...&#39;</code> (例如 <code>element.style.color = &#39;red&#39;</code>)</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;value&#39;)</code></li></ul></li><li><strong>操作内容</strong>：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容（包括子标签）。</li><li><code>element.textContent</code>：获取或设置元素的文本内容（不含 HTML）。</li></ul></li></ul></li></ul><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、Web-架构与网络基础"><a href="#一、Web-架构与网络基础" class="headerlink" title="一、Web 架构与网络基础"></a>一、Web 架构与网络基础</h3><h4 id="1-常见的软件架构"><a href="#1-常见的软件架构" class="headerlink" title="1. 常见的软件架构"></a>1. 常见的软件架构</h4><ul><li><strong>B&#x2F;S 架构 (Browser&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：浏览器和服务器架构。客户端只需安装一个通用的浏览器，业务逻辑和数据都存储在服务器端。</li><li><strong>优点</strong>：易于维护和升级，跨平台性好。</li><li><strong>缺点</strong>：对网络依赖性强，用户体验可能不如 C&#x2F;S 架构。</li></ul></li><li><strong>C&#x2F;S 架构 (Client&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：客户端和服务器架构。客户端需要安装专用的应用程序，例如桌面 QQ、微信等。</li><li><strong>优点</strong>：用户体验好，响应速度快，可以离线使用。</li><li><strong>缺点</strong>：维护和升级复杂，需要为不同平台开发不同版本。</li></ul></li></ul><h4 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h4><p>这是所有网络通信的基础，理解这三点至关重要。</p><ul><li><strong>IP 地址</strong>：设备在网络上的唯一标识，类似于你的家庭住址。它用于在网络中定位到一台具体的计算机。</li><li><strong>端口号</strong>：应用程序在计算机上的唯一标识，类似于你家里的电话号码或门牌号。一台计算机上可以运行多个应用程序，端口号用于区分它们。</li><li><strong>协议</strong>：通信规则。就像人与人交流需要遵循共同的语言一样，网络设备之间通信也需要遵循特定的协议，如 HTTP、FTP、TCP 等。</li></ul><h4 id="3-资源的分类"><a href="#3-资源的分类" class="headerlink" title="3. 资源的分类"></a>3. 资源的分类</h4><ul><li><strong>静态资源</strong>：<ul><li><strong>特点</strong>：内容固定，无需服务器端处理，可由浏览器直接解析。</li><li><strong>原理</strong>：当浏览器请求静态资源时，Web 服务器直接从文件系统中读取文件并返回。</li><li><strong>示例</strong>：HTML、CSS、JS、图片等。</li></ul></li><li><strong>动态资源</strong>：<ul><li><strong>特点</strong>：内容动态生成，需要服务器端处理后才能返回给浏览器。</li><li><strong>原理</strong>：当浏览器请求动态资源时，Web 服务器将请求交给<strong>后台程序</strong>（如 Servlet 容器），后台程序执行业务逻辑，生成静态内容（如 HTML、JSON 等），然后返回给服务器，服务器再返回给浏览器。</li><li><strong>示例</strong>：Servlet、JSP、PHP、ASP 等。</li></ul></li></ul><h3 id="二、Web-服务器"><a href="#二、Web-服务器" class="headerlink" title="二、Web 服务器"></a>二、Web 服务器</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Web 服务器（也称为 <strong>Web 容器</strong>）是一个软件，它负责处理 HTTP 请求，并提供静态资源和动态资源。它为动态资源（如 Servlet）提供了一个运行环境。</p><h4 id="2-常见的-Web-服务器"><a href="#2-常见的-Web-服务器" class="headerlink" title="2. 常见的 Web 服务器"></a>2. 常见的 Web 服务器</h4><ul><li><strong>Tomcat</strong>：Apache 基金组织开发，<strong>中小型的 JavaEE 服务器</strong>，<strong>免费</strong>且开源。它是一个<strong>Servlet 容器</strong>，能够运行 Servlet 和 JSP。</li><li><strong>WebSphere</strong>：IBM 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。功能强大，支持完整的 JavaEE 规范。</li><li><strong>WebLogic</strong>：Oracle 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。</li><li><strong>JBoss&#x2F;WildFly</strong>：开源，但其商业版收费。</li></ul><h3 id="三、Tomcat-的使用与配置"><a href="#三、Tomcat-的使用与配置" class="headerlink" title="三、Tomcat 的使用与配置"></a>三、Tomcat 的使用与配置</h3><ul><li><strong>安装与启动</strong>：Tomcat 是免安装的，解压即可。启动前需要配置 <code>JAVA_HOME</code> 环境变量。启动后，默认监听 <code>8080</code> 端口。</li><li><strong>端口号修改</strong>：<ul><li><strong>面试题</strong>：修改 Tomcat 端口号在哪个文件？</li><li><strong>回答</strong>：在 Tomcat 的 <code>conf</code> 目录下的 <code>server.xml</code> 文件中，修改 <code>&lt;Connector&gt;</code> 标签的 <code>port</code> 属性。</li><li><strong>注意</strong>：HTTP 协议的默认端口号是 <code>80</code>。如果将 Tomcat 端口号改为 <code>80</code>，那么访问时就可以省略端口号，例如 <code>http://localhost/</code>。</li></ul></li><li><strong>项目部署</strong>：<ul><li><strong>静态项目</strong>：将 HTML、CSS、JS 等文件直接放到 <code>webapps</code> 目录下的文件夹中。</li><li><strong>动态项目</strong>：将包含 <code>WEB-INF</code> 文件夹的整个项目目录放到 <code>webapps</code> 目录下。</li><li><strong>WEB-INF</strong>：这是动态项目的核心目录，具有特殊作用，外部无法直接通过 URL 访问该目录下的资源，保证了项目的安全性。<ul><li><code>classes</code>：存放所有编译后的 <code>.class</code> 字节码文件。</li><li><code>lib</code>：存放项目依赖的第三方 <code>.jar</code> 包。</li><li><code>web.xml</code>：Web 项目的<strong>核心配置文件</strong>，用于配置 Servlet、监听器、过滤器等。</li></ul></li></ul></li></ul><h3 id="四、Servlet-深入解析"><a href="#四、Servlet-深入解析" class="headerlink" title="四、Servlet 深入解析"></a>四、Servlet 深入解析</h3><h4 id="1-Servlet-的概念和本质"><a href="#1-Servlet-的概念和本质" class="headerlink" title="1. Servlet 的概念和本质"></a>1. Servlet 的概念和本质</h4><ul><li><strong>概念</strong>：Servlet 是运行在服务器端的 Java 程序，用于处理客户端请求并生成动态响应。它不是一个独立的程序，<strong>必须部署到支持 Servlet 的容器中</strong>（如 Tomcat）才能运行。</li><li><strong>本质</strong>：Servlet 的本质是一个<strong>接口</strong>。所有自定义的 Servlet 类都必须<strong>实现 javax.servlet.Servlet 接口</strong>。</li></ul><h4 id="2-Servlet-的执行原理（详细解释）"><a href="#2-Servlet-的执行原理（详细解释）" class="headerlink" title="2. Servlet 的执行原理（详细解释）"></a>2. Servlet 的执行原理（详细解释）</h4><p>这是一个非常重要的面试点，需要从请求-响应的整个流程来详细阐述。</p><ol><li><strong>客户端请求</strong>：用户在浏览器中输入 URL，向服务器发送一个 HTTP 请求。</li><li><strong>Web 服务器接收请求</strong>：Web 服务器（Tomcat）接收到这个请求。</li><li><strong>Servlet 容器处理</strong>：Tomcat 会根据请求 URL，在 <code>web.xml</code> 或通过注解（如 <code>@WebServlet</code>）查找匹配的 Servlet。</li><li><strong>Servlet 实例创建</strong>：<ul><li>如果是<strong>第一次</strong>访问该 Servlet，Servlet 容器会创建一个该 Servlet 的实例。</li><li><strong>面试点</strong>：Servlet 是<strong>单例的</strong>，一个 Servlet 在容器中只会被创建一次。</li></ul></li><li><strong>init() 方法执行</strong>：<ul><li>在 Servlet 实例创建后，容器会立即调用它的 <code>init()</code> 方法。</li><li><code>init()</code> 方法只在 Servlet 的<strong>生命周期中执行一次</strong>，用于完成一些初始化工作，如加载配置文件、数据库连接等。</li></ul></li><li><strong>service() 方法执行</strong>：<ul><li>每次客户端请求该 Servlet 时，容器都会调用它的 <code>service()</code> 方法。</li><li><code>service()</code> 方法根据请求的 HTTP 方法（GET、POST 等），将请求分发给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>面试点</strong>：<code>service()</code> 方法是处理请求的核心方法，它是<strong>多线程的</strong>，每个请求都会在新线程中执行 <code>service()</code> 方法。</li></ul></li><li><strong>destroy() 方法执行</strong>：<ul><li>当 Servlet 容器关闭，或者决定卸载该 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><code>destroy()</code> 方法也只执行一次，用于释放资源，如关闭数据库连接池。</li></ul></li></ol><p><strong>总结</strong>：Servlet 的生命周期是：<strong>创建实例</strong> -&gt; <strong>调用 init()</strong> (只一次) -&gt; <strong>调用 service()</strong> (多次) -&gt; <strong>调用 destroy()</strong> (只一次) -&gt; <strong>销毁实例</strong>。</p><p>好的，我们来将“网络编程三要素”这一部分进行更深入、更详细的展开，并补充常见应用的默认端口号，使其更具实用性和面试价值。</p><hr><h3 id="一、网络编程三要素：深入解析"><a href="#一、网络编程三要素：深入解析" class="headerlink" title="一、网络编程三要素：深入解析"></a>一、网络编程三要素：深入解析</h3><p>网络编程的本质就是让不同的计算机上的应用程序能够进行通信。要实现这一点，必须解决三个核心问题：</p><ol><li><strong>找到对方计算机</strong>：IP 地址</li><li><strong>找到对方计算机上的应用程序</strong>：端口号</li><li><strong>以什么样的规则进行通信</strong>：协议</li></ol><p>这三者缺一不可。</p><h4 id="1-IP-地址-Internet-Protocol-Address"><a href="#1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1. IP 地址 (Internet Protocol Address)"></a>1. IP 地址 (Internet Protocol Address)</h4><ul><li><strong>概念</strong>：IP 地址是分配给连接到网络中的设备（如计算机、手机、服务器）的一串数字标识。</li><li><strong>作用</strong>：它用于<strong>唯一地标识网络上的一个设备</strong>。数据包在网络中传输时，就是根据 IP 地址来路由和寻址的。</li><li><strong>版本</strong>：<ul><li><strong>IPv4</strong>：由 32 位二进制数组成，通常表示为四个十进制数，用点分隔（例如 <code>192.168.1.1</code>）。由于地址资源枯竭，现在已经不够用。</li><li><strong>IPv6</strong>：由 128 位二进制数组成，地址空间巨大，足以满足未来需求。</li></ul></li><li><strong>类型</strong>：<ul><li><strong>公网 IP</strong>：在互联网上是唯一的，可以直接访问。</li><li><strong>内网 IP</strong>：在局域网内是唯一的，不能直接在互联网上访问。例如 <code>192.168.x.x</code>、<code>10.x.x.x</code>。</li></ul></li></ul><h4 id="2-端口号-Port-Number"><a href="#2-端口号-Port-Number" class="headerlink" title="2. 端口号 (Port Number)"></a>2. 端口号 (Port Number)</h4><ul><li><strong>概念</strong>：端口号是用于<strong>区分一台计算机上不同应用程序</strong>的数字标识。它的范围是从 <code>0</code> 到 <code>65535</code>。</li><li><strong>作用</strong>：当一个数据包到达一台计算机时，操作系统会检查其目的端口号，然后将数据包交给监听该端口号的相应应用程序。</li><li><strong>与 IP 地址的关系</strong>：IP 地址解决了“数据包发送到哪台计算机”的问题，而端口号则解决了“数据包发送到这台计算机上的哪个应用程序”的问题。两者结合起来才能唯一确定一个网络连接的端点。</li></ul><h4 id="3-协议-Protocol"><a href="#3-协议-Protocol" class="headerlink" title="3. 协议 (Protocol)"></a>3. 协议 (Protocol)</h4><ul><li><strong>概念</strong>：协议是网络通信中<strong>数据传输的规则和约定</strong>。它定义了数据如何打包、传输、路由和接收。</li><li><strong>作用</strong>：确保通信双方能够理解彼此发送的数据。没有协议，数据包就是一堆无意义的字节。</li><li><strong>分层</strong>：网络协议通常是分层的，最经典的是 <strong>TCP&#x2F;IP 协议栈</strong>。<ul><li><strong>应用层</strong>：<strong>决定数据内容</strong>，如 HTTP、FTP、SMTP。</li><li><strong>传输层</strong>：<strong>决定数据如何传输</strong>，如 TCP 和 UDP。<ul><li><strong>TCP (Transmission Control Protocol)</strong>：面向连接、可靠、有序。适用于对数据完整性要求高的场景，如文件传输、网页浏览。</li><li><strong>UDP (User Datagram Protocol)</strong>：无连接、不可靠、速度快。适用于对实时性要求高的场景，如在线视频、游戏。</li></ul></li><li><strong>网络层</strong>：<strong>决定数据如何路由</strong>，如 IP 协议。</li><li><strong>数据链路层&#x2F;物理层</strong>：负责物理设备的通信。</li></ul></li></ul><hr><h3 id="二、常见应用的默认端口号"><a href="#二、常见应用的默认端口号" class="headerlink" title="二、常见应用的默认端口号"></a>二、常见应用的默认端口号</h3><p>了解这些默认端口号，可以帮助你更好地理解网络协议和服务。</p><ul><li><strong>Web 服务</strong><ul><li><strong>HTTP</strong> (HyperText Transfer Protocol)：<strong>80</strong></li><li><strong>HTTPS</strong> (HTTP Secure)：<strong>443</strong></li><li><strong>Tomcat</strong> (默认)：<strong>8080</strong></li><li><strong>WebLogic</strong> (默认)：<strong>7001</strong></li></ul></li><li><strong>文件传输</strong><ul><li><strong>FTP</strong> (File Transfer Protocol)：<strong>21</strong> (控制连接)</li><li><strong>SFTP</strong> (SSH File Transfer Protocol)：<strong>22</strong></li></ul></li><li><strong>远程登录与管理</strong><ul><li><strong>SSH</strong> (Secure Shell)：<strong>22</strong></li><li><strong>Telnet</strong>：<strong>23</strong></li><li><strong>RDP</strong> (Remote Desktop Protocol)：<strong>3389</strong></li></ul></li><li><strong>数据库服务</strong><ul><li><strong>MySQL</strong>：<strong>3306</strong></li><li><strong>PostgreSQL</strong>：<strong>5432</strong></li><li><strong>SQL Server</strong>：<strong>1433</strong></li><li><strong>Oracle</strong>：<strong>1521</strong></li></ul></li><li><strong>邮件服务</strong><ul><li><strong>SMTP</strong> (Simple Mail Transfer Protocol)：<strong>25</strong> (发送邮件)</li><li><strong>POP3</strong> (Post Office Protocol 3)：<strong>110</strong> (接收邮件)</li><li><strong>IMAP</strong> (Internet Message Access Protocol)：<strong>143</strong> (接收邮件)</li></ul></li><li><strong>其他常见服务</strong><ul><li><strong>DNS</strong> (Domain Name System)：<strong>53</strong></li><li><strong>Redis</strong>：<strong>6379</strong></li><li><strong>MongoDB</strong>：<strong>27017</strong></li><li><strong>Kafka</strong>：<strong>9092</strong></li></ul></li></ul><p>为什么需要默认端口号？</p><p>为了方便用户。当你在浏览器中访问 <a href="http://www.example.com/">www.example.com</a> 时，你不需要手动输入 <a href="http://www.example.com:80，因为浏览器知道">www.example.com:80，因为浏览器知道</a> HTTP 协议的默认端口就是 80。如果服务器的端口不是默认端口，你就必须手动指定，比如 <a href="http://www.example.com:8080。">www.example.com:8080。</a></p><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、Servlet-剩余部分"><a href="#一、Servlet-剩余部分" class="headerlink" title="一、Servlet 剩余部分"></a>一、Servlet 剩余部分</h3><h4 id="1-Servlet-的生命周期方法"><a href="#1-Servlet-的生命周期方法" class="headerlink" title="1. Servlet 的生命周期方法"></a>1. Servlet 的生命周期方法</h4><p>这是理解 Servlet 工作原理的核心。</p><ul><li><strong>init() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，用于初始化 Servlet 实例。</li><li><strong>执行时机</strong>：<ul><li><strong>默认（懒加载）</strong>：第一次被访问时执行。这是一种“按需加载”的策略，节省了服务器启动时的资源。</li><li><strong>预加载</strong>：可以在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签来设置。如果值为非负整数（<code>0</code>或正数），Servlet 容器将在服务器启动时立即创建并初始化该 Servlet。这适用于需要立即提供服务、启动耗时较长的 Servlet。</li></ul></li></ul></li><li><strong>service() 方法</strong>：<ul><li><strong>特点</strong>：每次客户端请求该 Servlet 时，都会执行一次。</li><li><strong>原理</strong>：它是 Servlet 接口的核心方法，用于处理请求。对于 <code>HttpServlet</code> 来说，它会根据 HTTP 请求方法（GET、POST 等）来分发请求给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>重要性</strong>：<strong>service() 方法是多线程的</strong>。Servlet 容器会为每个请求创建一个新线程来执行 <code>service()</code> 方法，确保并发访问时互不影响。</li></ul></li><li><strong>destroy() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，在 Servlet 实例正常销毁时调用。</li><li><strong>执行时机</strong>：通常在 Web 应用关闭或 Servlet 容器关闭时。用于释放资源，如关闭数据库连接、文件句柄等。</li></ul></li></ul><h4 id="2-Servlet-的实现方式：XML-vs-注解"><a href="#2-Servlet-的实现方式：XML-vs-注解" class="headerlink" title="2. Servlet 的实现方式：XML vs. 注解"></a>2. Servlet 的实现方式：XML vs. 注解</h4><ul><li><p><strong>XML 配置方式</strong>：在 <code>web.xml</code> 文件中，通过 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code> 标签来配置 Servlet 的名称、类和访问路径。这是 Servlet 2.x 及以前版本的主流方式。</p></li><li><p><strong>注解方式</strong>：自 Servlet 3.0 开始引入，可以使用 <code>@WebServlet</code> 注解来代替 XML 配置。</p><ul><li><strong>优点</strong>：简化了配置，代码和配置更集中，提高了开发效率。</li><li><strong>示例</strong>：</li></ul><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Servlet-的体系结构"><a href="#3-Servlet-的体系结构" class="headerlink" title="3. Servlet 的体系结构"></a>3. Servlet 的体系结构</h4><ul><li><code>Servlet</code> <strong>接口</strong>：所有 Servlet 的顶层接口，定义了 <code>init()</code>, <code>service()</code>, <code>destroy()</code> 等核心方法。</li><li><code>GenericServlet</code> <strong>抽象类</strong>：实现了 <code>Servlet</code> 接口，并提供了 <code>init()</code>, <code>destroy()</code> 的空实现，以及一些通用方法。开发者可以继承它来编写协议无关的 Servlet。</li><li><code>HttpServlet</code> <strong>抽象类</strong>：继承自 <code>GenericServlet</code>，专门用于处理 <strong>HTTP 请求</strong>。它重写了 <code>service()</code> 方法，并根据请求方法分发给 <code>doGet()</code>, <code>doPost()</code> 等具体方法。</li><li><strong>总结</strong>：在 Web 项目中，我们几乎总是处理 HTTP 请求，因此<strong>继承 HttpServlet 是最常用、最推荐的方式</strong>。</li></ul><hr><h3 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h3><h4 id="1-概念与特点"><a href="#1-概念与特点" class="headerlink" title="1. 概念与特点"></a>1. 概念与特点</h4><ul><li><strong>概念</strong>：<strong>超文本传输协议</strong>，是 Web 应用层协议，基于 TCP&#x2F;IP。它规定了客户端和服务器之间的通信格式。</li><li><strong>特点</strong>：<ul><li><strong>基于 TCP&#x2F;IP</strong>：它位于 TCP&#x2F;IP 协议栈的应用层，利用了 TCP 的可靠传输特性。</li><li><strong>请求&#x2F;响应模型</strong>：客户端发送请求，服务器返回响应，一次请求只对应一次响应。</li><li><strong>无状态</strong>：这是 HTTP 的核心特征。服务器不保留任何关于客户端过去请求的信息。每个请求都是独立的。</li><li><strong>无状态带来的问题</strong>：服务器无法识别多个请求是否来自同一个用户，因此需要引入<strong>会话技术</strong>（如 Cookie 和 Session）来解决。</li></ul></li></ul><h4 id="2-HTTP-协议的数据格式"><a href="#2-HTTP-协议的数据格式" class="headerlink" title="2. HTTP 协议的数据格式"></a>2. HTTP 协议的数据格式</h4><p>HTTP 协议是文本格式，由<strong>请求格式</strong>和<strong>响应格式</strong>两部分组成。</p><ul><li><strong>请求格式</strong>：<ol><li><strong>请求行</strong>：<code>请求方式 虚拟路径/资源路径[?参数] 请求协议/版本</code>。</li><li><strong>请求头</strong>：键值对形式，提供额外信息。<ul><li><code>Host</code>：目标主机名。</li><li><code>User-Agent</code>：浏览器类型和版本。</li><li><code>Referer</code>：请求来源地址，常用于防盗链。</li></ul></li><li><strong>请求空行</strong>：一个空行，用于分隔请求头和请求体。</li><li><strong>请求体</strong>：<strong>只有 POST 请求才有</strong>，用于封装请求参数。</li></ol></li></ul><h4 id="3-ServletRequest-对象"><a href="#3-ServletRequest-对象" class="headerlink" title="3. ServletRequest 对象"></a>3. <code>ServletRequest</code> 对象</h4><p><code>ServletRequest</code> 是 Servlet 容器在接收到请求后，封装请求信息的对象。</p><ul><li><strong>获取请求行信息</strong>：<ul><li><code>getMethod()</code>：获取请求方式（GET&#x2F;POST）。</li><li><code>getContextPath()</code>：获取虚拟路径。</li><li><code>getRequestURI()</code>：获取 URI，如 <code>/web02/demo4</code>。</li><li><code>getRequestURL()</code>：获取 URL，如 <code>http://localhost:8080/web02/demo4</code>。</li></ul></li><li><strong>获取请求头信息</strong>：<ul><li><code>getHeader(name)</code>：根据请求头名获取值。</li><li><code>getHeaderNames()</code>：获取所有请求头名。</li></ul></li><li><strong>获取请求体信息</strong>：<ul><li><code>getReader()</code> (字符流) 和 <code>getInputStream()</code> (字节流)，用于读取 POST 请求的请求体内容。</li></ul></li><li><strong>获取请求参数（通用）</strong>：<ul><li><code>getParameter(name)</code>：获取单个参数值。</li><li><code>getParameterValues(name)</code>：获取参数值数组，用于复选框等。</li></ul></li><li><strong>中文乱码</strong>：<ul><li><strong>GET 请求</strong>：在 Tomcat 8.x 及以后版本，默认已解决。</li><li><strong>POST 请求</strong>：需要手动设置编码，<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>。</li></ul></li></ul><h4 id="4-request-请求转发"><a href="#4-request-请求转发" class="headerlink" title="4. request 请求转发"></a>4. <code>request</code> 请求转发</h4><ul><li><strong>概念</strong>：是一种<strong>服务器内部</strong>的资源跳转方式。请求从一个 Servlet 转发到另一个 Servlet 或 JSP，<strong>浏览器地址栏不会发生改变</strong>。</li><li><strong>特点</strong>：<ol><li><strong>地址栏不变</strong>：用户不知道发生了跳转。</li><li><strong>一次请求&#x2F;响应</strong>：整个转发过程发生在一次 HTTP 请求和一次 HTTP 响应中。</li><li><strong>共享数据</strong>：由于是同一次请求，<code>request</code> 对象中的数据在转发前后是共享的。</li></ol></li></ul><h4 id="5-request-作为域对象"><a href="#5-request-作为域对象" class="headerlink" title="5. request 作为域对象"></a>5. <code>request</code> 作为域对象</h4><ul><li><strong>概念</strong>：<code>request</code> 是一种<strong>域对象</strong>，其作用范围是<strong>一次请求-响应的生命周期</strong>。</li><li><strong>共享数据</strong>：可以使用 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法在这次请求的生命周期内共享数据。</li><li><strong>应用场景</strong>：常用于在 Servlet 和 JSP 之间传递数据。</li><li><strong>与会话技术的联系</strong>：<code>request</code> 是三大域对象（<code>request</code>, <code>session</code>, <code>servletContext</code>）中作用范围最小的一个。</li></ul><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、HTTP-协议的响应格式"><a href="#一、HTTP-协议的响应格式" class="headerlink" title="一、HTTP 协议的响应格式"></a>一、HTTP 协议的响应格式</h3><h4 id="1-响应格式组成"><a href="#1-响应格式组成" class="headerlink" title="1. 响应格式组成"></a>1. 响应格式组成</h4><p>HTTP 响应格式由四部分组成：<code>响应行</code>、<code>响应头</code>、<code>响应空行</code>、<code>响应体</code>。这与 HTTP 请求格式相呼应。</p><h4 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a>2. 响应行</h4><ul><li><strong>格式</strong>：<code>协议/版本号 状态码 状态描述</code>。例如：<code>HTTP/1.1 200 OK</code>。</li><li><strong>状态码</strong>：一个三位数的数字，服务器用于告诉浏览器本次响应的状态。<ul><li><strong>2xx 成功</strong>：<ul><li><strong>200 OK</strong>：请求成功，一切正常。</li></ul></li><li><strong>3xx 重定向</strong>：<ul><li><strong>302 Found</strong>：重定向。服务器告诉浏览器，资源临时移动到另一个位置，请重新发起请求。</li><li><strong>304 Not Modified</strong>：访问缓存。服务器告诉浏览器，请求的资源没有更新，可以使用浏览器本地的缓存副本。</li></ul></li><li><strong>4xx 客户端错误</strong>：<ul><li><strong>404 Not Found</strong>：找不到资源。请求的路径没有对应的资源。</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，客户端用 POST 请求访问了只支持 GET 方法的 Servlet。</li></ul></li><li><strong>5xx 服务器端错误</strong>：<ul><li><strong>500 Internal Server Error</strong>：服务器内部错误。通常是服务器端的代码出现了异常。</li></ul></li></ul></li><li><strong>面试题</strong>：列举 5 个常见的状态码：200、302、304、404、405、500。</li></ul><h4 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h4><ul><li><strong>作用</strong>：以键值对形式提供关于响应的额外信息。</li><li><strong>常见响应头</strong>：<ul><li><strong>Content-Type</strong>：告诉浏览器响应体的数据类型和字符编码，例如 <code>text/html;charset=utf-8</code>。</li><li><strong>Content-disposition</strong>：<ul><li><strong>inline</strong> (默认)：浏览器在当前页面内直接打开。</li><li><strong>attachment;filename&#x3D;xxx</strong>：浏览器将数据作为附件下载。</li></ul></li><li><strong>Location</strong>：与 <code>3xx</code> 状态码配合使用，用于告诉浏览器重定向到哪个 URL。</li></ul></li></ul><h3 id="二、ServletResponse-response"><a href="#二、ServletResponse-response" class="headerlink" title="二、ServletResponse (response)"></a>二、ServletResponse (response)</h3><ul><li><strong>简介</strong>：<code>ServletResponse</code> 对象由 Tomcat 创建，封装了服务器发送给客户端的响应消息。</li><li><strong>相关方法</strong>：<ul><li><strong>设置响应行</strong>：<code>setStatus(int sc)</code></li><li><strong>设置响应头</strong>：<code>setHeader(String name, String value)</code></li><li><strong>设置响应体</strong>：<ul><li><code>getWriter()</code>：获取字符输出流，用于发送<strong>文本</strong>数据。</li><li><code>getOutputStream()</code>：获取字节输出流，用于发送<strong>字节</strong>数据（如图片、视频）。</li></ul></li></ul></li></ul><h3 id="三、转发（Forward）和重定向（Redirect）的区别"><a href="#三、转发（Forward）和重定向（Redirect）的区别" class="headerlink" title="三、转发（Forward）和重定向（Redirect）的区别"></a>三、转发（Forward）和重定向（Redirect）的区别</h3><p>这是一个非常重要的面试题，需要从多个角度进行对比。</p><table><thead><tr><th>特性</th><th>转发（Forward）</th><th>重定向（Redirect）</th></tr></thead><tbody><tr><td><strong>发生方</strong></td><td>服务器内部</td><td>浏览器</td></tr><tr><td><strong>地址栏</strong></td><td><strong>不变</strong></td><td><strong>会改变</strong></td></tr><tr><td><strong>请求次数</strong></td><td><strong>一次</strong>请求，一次响应</td><td><strong>两次</strong>请求，两次响应</td></tr><tr><td><strong>共享数据</strong></td><td><code>request</code> 对象共享数据</td><td><code>request</code> 对象不共享数据</td></tr><tr><td><strong>跳转范围</strong></td><td><strong>只能</strong>在当前 Web 项目内部</td><td>可以跳出项目，访问外部资源</td></tr><tr><td><strong>调用方</strong></td><td><code>RequestDispatcher</code> (<code>request</code>)</td><td><code>ServletResponse</code> (<code>response</code>)</td></tr><tr><td><strong>底层实现</strong></td><td><code>request.getRequestDispatcher().forward()</code></td><td><code>response.sendRedirect()</code></td></tr></tbody></table><ul><li><strong>重定向的实现原理</strong>：<ol><li>服务器收到请求，执行 <code>response.sendRedirect()</code>，并发送 <code>302</code> 状态码和 <code>Location</code> 响应头（值为新的 URL）。</li><li>浏览器收到响应，解析到 <code>302</code> 和 <code>Location</code> 头后，会<strong>自动</strong>向新的 URL 发起<strong>第二次</strong>请求。</li></ol></li></ul><h3 id="四、ServletContext"><a href="#四、ServletContext" class="headerlink" title="四、ServletContext"></a>四、ServletContext</h3><h4 id="1-简介与特点"><a href="#1-简介与特点" class="headerlink" title="1. 简介与特点"></a>1. 简介与特点</h4><ul><li><strong>作用</strong>：代表<strong>整个 Web 应用</strong>。可以用来和服务器容器进行通信。</li><li><strong>特点</strong>：<ul><li><strong>单例</strong>：一个 Web 应用只有一个 <code>ServletContext</code> 对象。</li><li><strong>作用域</strong>：是<strong>最大的域对象</strong>，其作用范围是整个 Web 应用，从应用启动到关闭。</li></ul></li></ul><h4 id="2-获取-ServletContext-对象"><a href="#2-获取-ServletContext-对象" class="headerlink" title="2. 获取 ServletContext 对象"></a>2. 获取 <code>ServletContext</code> 对象</h4><ul><li><strong>通过 request</strong>：<code>request.getServletContext()</code></li><li><strong>通过 HttpServlet</strong>：<code>getServletContext()</code></li></ul><h4 id="3-ServletContext-的方法"><a href="#3-ServletContext-的方法" class="headerlink" title="3. ServletContext 的方法"></a>3. <code>ServletContext</code> 的方法</h4><ul><li><strong>获取文件 MIME 类型</strong>：<code>getMimeType(String file)</code>，返回文件的类型，如 <code>image/jpeg</code>。</li><li><strong>作为域对象</strong>：提供了 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法，用于在整个 Web 应用范围内共享数据。<ul><li><strong>示例</strong>：您提供的代码片段完美地展示了如何使用 <code>ServletContext</code> 来统计服务器的访问次数。这是 <code>ServletContext</code> 作为域对象最经典的用法。</li></ul></li><li><strong>获取文件真实路径</strong>：<code>getRealPath(String path)</code>，将相对路径转换为服务器上的绝对路径。</li></ul><h3 id="五、会话（Session）"><a href="#五、会话（Session）" class="headerlink" title="五、会话（Session）"></a>五、会话（Session）</h3><h4 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h4><ul><li><strong>概念</strong>：在 HTTP 协议的无状态特性基础上，通过会话技术将多次请求和响应联系起来，形成一个完整的会话。</li><li><strong>作用</strong>：在一次会话范围内的多次请求之间<strong>共享数据</strong>，从而识别用户。</li><li><strong>实现方式</strong>：<ul><li><strong>客户端会话（Cookie）</strong>：数据存储在客户端浏览器。</li><li><strong>服务器端会话（Session）</strong>：数据存储在服务器端。</li></ul></li></ul><h4 id="2-客户端会话：Cookie"><a href="#2-客户端会话：Cookie" class="headerlink" title="2. 客户端会话：Cookie"></a>2. 客户端会话：Cookie</h4><ul><li><strong>快速开始</strong>：<ol><li><strong>创建</strong>：<code>new Cookie(name, value)</code>。</li><li><strong>发送</strong>：<code>response.addCookie(cookie)</code>，将 Cookie 发送给浏览器。</li><li><strong>获取</strong>：<code>request.getCookies()</code>，从请求中获取所有 Cookie。</li></ol></li><li><strong>特点</strong>：数据存储在客户端，有大小限制，安全性低。</li></ul><p>这是一个非常好的问题，它触及了 Web 开发中一个容易混淆但至关重要的概念。<code>enctype</code> 和 <code>Content-Type</code> 确实有相似之处，但它们的作用域和角色是完全不同的。</p><p>让我来详细解释一下它们的区别：</p><hr><h3 id="一、enctype"><a href="#一、enctype" class="headerlink" title="一、enctype"></a>一、<code>enctype</code></h3><ul><li><strong>作用域</strong>：HTML <code>&lt;form&gt;</code> 标签的属性。</li><li><strong>角色</strong>：客户端<strong>表单的编码方式</strong>。</li><li><strong>概念</strong>：<code>enctype</code> (Encoding Type) 告诉<strong>浏览器</strong>如何将 <code>&lt;form&gt;</code> 表单中的数据<strong>编码</strong>成 HTTP 请求体中的数据。它只作用于<strong>表单提交</strong>这个行为。</li><li><strong>常见值</strong>：<ul><li><code>application/x-www-form-urlencoded</code>：默认值，用于文本数据。</li><li><code>multipart/form-data</code>：用于文件上传。</li><li><code>text/plain</code>：用于纯文本提交。</li></ul></li></ul><p><strong>简单来说，enctype 是“表单数据在浏览器端如何打包”的规则。</strong></p><h3 id="二、Content-Type"><a href="#二、Content-Type" class="headerlink" title="二、Content-Type"></a>二、<code>Content-Type</code></h3><ul><li><strong>作用域</strong>：HTTP 请求头或响应头。</li><li><strong>角色</strong>：<strong>通信数据的媒体类型</strong>。</li><li><strong>概念</strong>：<code>Content-Type</code> 告诉接收方（服务器或浏览器）请求体或响应体中的<strong>数据是什么格式</strong>。它是一个通用的 HTTP 头部，不仅限于表单提交。</li><li><strong>常见值</strong>：<ul><li><code>text/html</code>：HTML 文档。</li><li><code>application/json</code>：JSON 格式数据。</li><li><code>image/jpeg</code>：JPEG 图片。</li><li><code>application/xml</code>：XML 文档。</li><li><code>text/plain</code>：纯文本。</li></ul></li></ul><p><strong>简单来说，Content-Type 是“我发送给你的数据是什么类型”的声明。</strong></p><h3 id="三、核心区别与联系"><a href="#三、核心区别与联系" class="headerlink" title="三、核心区别与联系"></a>三、核心区别与联系</h3><table><thead><tr><th>特性</th><th><code>enctype</code></th><th><code>Content-Type</code></th></tr></thead><tbody><tr><td><strong>位置</strong></td><td>HTML <code>&lt;form&gt;</code> 标签的属性</td><td>HTTP 请求头或响应头</td></tr><tr><td><strong>谁定义</strong></td><td>开发者在 HTML 中设置</td><td>发送方（浏览器或服务器）在 HTTP 头部中设置</td></tr><tr><td><strong>作用</strong></td><td>告诉<strong>浏览器</strong>如何<strong>打包</strong>表单数据</td><td>告诉<strong>接收方</strong>如何<strong>解析</strong>数据</td></tr><tr><td><strong>关系</strong></td><td><strong>enctype 的值决定了 HTTP 请求头中 Content-Type 的值。</strong></td><td><code>Content-Type</code> 是 HTTP 协议的一部分，<code>enctype</code> 是 HTML 的一部分。</td></tr></tbody></table><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你有一个包含用户名和头像上传的表单：</p><p>HTML</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>当用户点击提交时，浏览器会做两件事：</p><ol><li><p><strong>根据 enctype&#x3D;”multipart&#x2F;form-data” 规则</strong>，浏览器会生成一个**多部分（<code>multipart</code>）**的请求体，包含用户名和头像文件的二进制数据。</p></li><li><p>在发送 HTTP 请求时，浏览器会在请求头中自动添加一个 <code>Content-Type</code> 字段，其值为<strong>与 enctype 匹配的</strong> <code>multipart/form-data</code>。</p><p>HTTP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /profile HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong>：</p><ul><li><strong>enctype 是一个前端概念</strong>，它是 HTML 表单的属性，用于指导浏览器如何构建请求体。</li><li><strong>Content-Type 是一个 HTTP 协议概念</strong>，它是 HTTP 头部的一个字段，用于告知数据格式。</li><li>两者之间存在<strong>联动关系</strong>：你在 HTML 中设置的 <code>enctype</code> 值，会<strong>最终影响</strong>浏览器在 HTTP 请求中设置的 <code>Content-Type</code> 头的值。</li></ul><p>好的，我来为你分别列出 <code>enctype</code> 和 <code>Content-Type</code> 各自常见的属性值，并简要说明其用途。</p><hr><h3 id="一、enctype-的常见值"><a href="#一、enctype-的常见值" class="headerlink" title="一、enctype 的常见值"></a>一、<code>enctype</code> 的常见值</h3><p><code>enctype</code> 是 HTML <code>&lt;form&gt;</code> 标签的属性，用于定义表单数据提交的编码方式。</p><ol><li><strong>application&#x2F;x-www-form-urlencoded</strong><ul><li><strong>用途</strong>：这是 <code>enctype</code> 的<strong>默认值</strong>。它将表单数据编码为键值对字符串，其中所有特殊字符都会被 URL 编码（例如空格被 <code>%20</code> 替代）。</li><li><strong>适用场景</strong>：只包含文本数据的普通表单提交。</li></ul></li><li><strong>multipart&#x2F;form-data</strong><ul><li><strong>用途</strong>：将表单数据分割成多个部分，每个部分都有独立的 <code>Content-Type</code> 和 <code>Content-Disposition</code> 头部。这种格式能够<strong>同时处理文本和二进制数据</strong>。</li><li><strong>适用场景</strong>：<strong>文件上传</strong>。</li></ul></li><li><strong>text&#x2F;plain</strong><ul><li><strong>用途</strong>：将表单数据以纯文本格式发送，不进行任何编码。数据以键值对的形式，用换行符分隔。</li><li><strong>适用场景</strong>：不常用，主要用于调试目的。</li></ul></li></ol><h3 id="二、Content-Type-的常见值"><a href="#二、Content-Type-的常见值" class="headerlink" title="二、Content-Type 的常见值"></a>二、<code>Content-Type</code> 的常见值</h3><p><code>Content-Type</code> 是 HTTP 头部字段，用于指定消息体的媒体类型（MIME 类型）。</p><h4 id="1-文本类型-text"><a href="#1-文本类型-text" class="headerlink" title="1. 文本类型 (text/)"></a>1. 文本类型 (<code>text/</code>)</h4><ul><li><strong>text&#x2F;plain</strong>：纯文本。</li><li><strong>text&#x2F;html</strong>：HTML 文档。这是浏览器渲染网页的默认类型。</li><li><strong>text&#x2F;css</strong>：CSS 样式表。</li><li><strong>text&#x2F;javascript</strong>：JavaScript 代码。</li></ul><h4 id="2-应用类型-application"><a href="#2-应用类型-application" class="headerlink" title="2. 应用类型 (application/)"></a>2. 应用类型 (<code>application/</code>)</h4><ul><li><strong>application&#x2F;json</strong>：JSON 格式的数据。目前最常用的前后端数据交互格式。</li><li><strong>application&#x2F;xml</strong>：XML 格式的数据。</li><li><strong>application&#x2F;pdf</strong>：PDF 文档。</li><li><strong>application&#x2F;octet-stream</strong>：通用的<strong>二进制流数据</strong>。通常用于<strong>强制浏览器下载</strong>未知类型的文件，因为它告诉浏览器“这是一个原始的字节流，请不要尝试解析它”。</li><li><strong>application&#x2F;x-www-form-urlencoded</strong>：与 <code>enctype</code> 的默认值对应，表明请求体是 URL 编码的键值对。</li><li><strong>application&#x2F;javascript</strong>：与 <code>text/javascript</code> 类似，更推荐使用。</li></ul><h4 id="3-图片类型-image"><a href="#3-图片类型-image" class="headerlink" title="3. 图片类型 (image/)"></a>3. 图片类型 (<code>image/</code>)</h4><ul><li><strong>image&#x2F;jpeg</strong>：JPEG&#x2F;JPG 格式的图片。</li><li><strong>image&#x2F;png</strong>：PNG 格式的图片。</li><li><strong>image&#x2F;gif</strong>：GIF 格式的图片。</li><li><strong>image&#x2F;svg+xml</strong>：SVG 矢量图。</li></ul><h4 id="4-音视频类型"><a href="#4-音视频类型" class="headerlink" title="4. 音视频类型"></a>4. 音视频类型</h4><ul><li><strong>audio&#x2F;mpeg</strong>：MP3 音频文件。</li><li><strong>video&#x2F;mp4</strong>：MP4 视频文件。</li></ul><h4 id="5-多部分类型-multipart"><a href="#5-多部分类型-multipart" class="headerlink" title="5. 多部分类型 (multipart/)"></a>5. 多部分类型 (<code>multipart/</code>)</h4><ul><li><strong>multipart&#x2F;form-data</strong>：用于文件上传，与 <code>enctype</code> 的值对应。</li><li><strong>multipart&#x2F;byteranges</strong>：用于分块下载，支持断点续传。</li></ul><p>好的，这是一个非常经典的面试题，也是理解 Web 基础知识的关键。我会详细、清晰地解释 URL 和 URI，并用通俗易懂的方式区分它们。</p><hr><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><ul><li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul><li><strong>概念</strong>：URI 是一个用于<strong>标识</strong>互联网上<strong>任何资源</strong>的字符串。它不仅仅能标识网页，还可以标识文件、服务、电子邮箱等。</li><li><strong>作用</strong>：<strong>标识</strong>。URI 就像一个资源的“身份证号”，它能唯一地识别一个资源，但<strong>不一定</strong>告诉我们如何访问它。</li></ul></li><li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul><li><strong>概念</strong>：URL 是一个用于<strong>定位</strong>互联网上资源的字符串。它是 URI 的一个<strong>子集</strong>。</li><li><strong>作用</strong>：<strong>定位</strong>。URL 就像一个资源的“详细地址”，它不仅标识了资源，还提供了<strong>如何访问该资源</strong>的完整信息，包括协议、主机名、端口号和路径等。</li></ul></li></ul><h3 id="二、URL-和-URI-的关系"><a href="#二、URL-和-URI-的关系" class="headerlink" title="二、URL 和 URI 的关系"></a>二、URL 和 URI 的关系</h3><p>用一个比喻来理解：</p><ul><li><strong>URI</strong> 就像一个人的<strong>名字</strong>。<code>张三</code>这个名字可以标识这个人，但你不知道他在哪里、怎么找到他。</li><li><strong>URL</strong> 就像一个人的<strong>家庭住址</strong>。<code>北京市海淀区中关村大街1号</code>。这个地址不仅标识了这个人，还告诉了你如何定位他。</li></ul><p><strong>因此，所有的 URL 都是 URI，但并非所有的 URI 都是 URL。</strong></p><h3 id="三、URL-和-URI-的具体结构"><a href="#三、URL-和-URI-的具体结构" class="headerlink" title="三、URL 和 URI 的具体结构"></a>三、URL 和 URI 的具体结构</h3><h4 id="URI-的结构："><a href="#URI-的结构：" class="headerlink" title="URI 的结构："></a>URI 的结构：</h4><p>一个 URI 通常由两部分组成：</p><p><code>scheme:[//authority][path][?query][#fragment]</code></p><ul><li><code>scheme</code>：协议，如 <code>http</code>, <code>ftp</code>, <code>mailto</code>。</li><li><code>path</code>：资源路径。</li></ul><h4 id="URL-的结构："><a href="#URL-的结构：" class="headerlink" title="URL 的结构："></a>URL 的结构：</h4><p>URL 包含了 URI 的所有组成部分，并加入了定位信息。</p><p><code>scheme://host:port/path?query#fragment</code></p><ul><li><code>scheme</code>：协议。如 <code>http</code>, <code>https</code>, <code>ftp</code>。</li><li><code>host</code>：主机名或 IP 地址。</li><li><code>port</code>：端口号（可选，如果使用默认端口则可以省略）。</li><li><code>path</code>：资源路径。</li><li><code>query</code>：查询参数，以 <code>?</code> 开始。</li><li><code>fragment</code>：片段标识符，以 <code>#</code> 开始。</li></ul><h3 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a>四、举例说明</h3><table><thead><tr><th>字符串</th><th>类别</th><th>解释</th></tr></thead><tbody><tr><td><code>https://www.google.com/search?q=url+uri</code></td><td><strong>URL</strong> 和 <strong>URI</strong></td><td>既是 URI（标识），也是 URL（定位），提供了完整的访问信息。</td></tr><tr><td><code>urn:isbn:0451450523</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td><code>urn:isbn</code> 是一个 URN (Uniform Resource Name)，它是 URI 的另一种类型，用于标识一本书。它标识了资源，但没有提供如何访问它的位置信息。</td></tr><tr><td><code>/images/logo.png</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>这是一个相对路径，它标识了资源，但没有完整的定位信息（如协议、主机名），需要结合当前页面的 URL 才能确定完整位置。</td></tr><tr><td><code>mailto:test@example.com</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>标识了一个邮箱资源，但无法通过它来定位到具体的文件或服务器。</td></tr></tbody></table><h3 id="五、面试回答总结"><a href="#五、面试回答总结" class="headerlink" title="五、面试回答总结"></a>五、面试回答总结</h3><ol><li><p><strong>开门见山</strong>：URL 是 URI 的子集。</p></li><li><p><strong>核心区别</strong>：</p><ul><li><strong>URI 是标识符</strong>，它只负责<strong>标识</strong>一个资源，不提供如何访问它的信息。</li><li><strong>URL 是定位符</strong>，它在标识资源的同时，还提供了<strong>定位</strong>该资源的完整信息，如协议、主机名等。</li></ul></li><li><p><strong>举例</strong>：</p><ul><li>URL：<code>https://www.example.com/index.html</code>，包含了协议、主机、路径，可以明确地定位一个资源。</li><li>URI：<code>urn:isbn:0451450523</code>，它标识了一本书，但你无法通过它来访问这本书的电子版。</li></ul></li><li><p><strong>关系图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|      URI    |</span><br><span class="line">|             |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|  |   URL    |   URN   |</span><br><span class="line">|  | (定位)   |  (命名) |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>用这个图能非常清晰地展现它们之间的关系。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、HTTP-协议概述&quot;&gt;&lt;a href=&quot;#一、HTTP-协议概述&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP 协</summary>
      
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="servlet" scheme="http://example.com/tags/servlet/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>总结</title>
    <link href="http://example.com/2025/09/11/%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/09/11/%E6%80%BB%E7%BB%93/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-21T09:32:27.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络"><a href="#1-网络" class="headerlink" title="1.网络"></a>1.网络</h1><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h3><p>物理层 </p><p>数据链路层</p><p>网络层 ip</p><p>传输层 tcp&#x2F;udp</p><p>会话层</p><p>表示层 unicode ssl </p><p>应用层 http https dns</p><p>实际中使用TCP&#x2F;IP四层模型 </p><p>网络接口层</p><p>网络层 </p><p>传输层</p><p>应用层</p><h3 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h3><ol><li>客户端发送 SYN，告知初始序列号。</li><li>服务器返回 SYN-ACK，确认收到 SYN 并告知自身序列号。</li><li>客户端 ACK 确认，双方 ESTABLISHED。</li></ol><h3 id="3-四次挥手"><a href="#3-四次挥手" class="headerlink" title="3.四次挥手"></a>3.四次挥手</h3><ol><li>主动方 FIN，关闭发送。</li><li>被动方 ACK，确认。</li><li>被动方 FIN，关闭发送。</li><li>主动方 ACK，进入 TIME_WAIT，等待 2MSL。</li></ol><h2 id="2-Linux"><a href="#2-Linux" class="headerlink" title="2.Linux"></a>2.Linux</h2><h2 id="3-Mysql"><a href="#3-Mysql" class="headerlink" title="3.Mysql"></a>3.Mysql</h2><h3 id="1-慢查询"><a href="#1-慢查询" class="headerlink" title="1.慢查询"></a>1.慢查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><h3 id="EXPLAIN-核心字段解析"><a href="#EXPLAIN-核心字段解析" class="headerlink" title="EXPLAIN 核心字段解析"></a>EXPLAIN 核心字段解析</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>查询序列号，越大优先级越高；相同 id 按顺序执行。</td></tr><tr><td>select_type</td><td>查询类型：SIMPLE, PRIMARY, SUBQUERY, DEPENDENT SUBQUERY, UNION, DERIVED 等。</td></tr><tr><td>table</td><td>正在访问的表名。</td></tr><tr><td>partitions</td><td>匹配的分区信息（如果有分区表）。</td></tr><tr><td>type</td><td>连接类型&#x2F;访问方式，性能从好到差：system → const → eq_ref → ref → range → index → ALL。</td></tr><tr><td>possible_keys</td><td>查询可能使用的索引。</td></tr><tr><td>key</td><td>实际使用的索引，NULL 表示未使用索引。</td></tr><tr><td>key_len</td><td>使用的索引长度（字节），越短越好。</td></tr><tr><td>ref</td><td>表示索引列与哪个列或常量进行比较。</td></tr><tr><td>rows</td><td>MySQL 估计要扫描的行数，越少越好。</td></tr><tr><td>filtered</td><td>WHERE 条件过滤行的百分比，越高越好。</td></tr><tr><td>Extra</td><td>额外信息，重要优化指标：- <code>Using filesort</code>：需要额外排序。- <code>Using temporary</code>：需要临时表处理。- <code>Using index</code>：使用覆盖索引，查询效率高。- <code>Using where</code>：使用 WHERE 条件过滤。- <code>Using index condition</code>：索引条件下推（ICP）。- <code>Using join buffer</code>：连接查询未用索引，使用缓存优化。</td></tr></tbody></table><hr><h3 id="type-类型说明（访问方式）"><a href="#type-类型说明（访问方式）" class="headerlink" title="type 类型说明（访问方式）"></a>type 类型说明（访问方式）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">system</span>  : 表中只有一行记录，性能极高</span><br><span class="line">const   : 通过主键或唯一索引查找，最多一行</span><br><span class="line">eq_ref   : 对前表每行组合读取一行，用于主键或唯一索引连接</span><br><span class="line"><span class="keyword">ref</span>      : 非唯一索引等值查找，可能多行</span><br><span class="line"><span class="keyword">range</span>    : 范围查找，使用索引</span><br><span class="line">index    : 全索引扫描，优于全表扫描</span><br><span class="line"><span class="keyword">ALL</span>      : 全表扫描，性能最差</span><br></pre></td></tr></table></figure><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h3><h4 id="2-1索引的概念"><a href="#2-1索引的概念" class="headerlink" title="2.1索引的概念"></a>2.1索引的概念</h4><p>索引是一种数据结构，用于提升查询到效率</p><h4 id="2-2索引的具体结构"><a href="#2-2索引的具体结构" class="headerlink" title="2.2索引的具体结构"></a>2.2索引的具体结构</h4><p>B+树 </p><p>B+树的特点是</p><p>每个叶子节点都有指针相互指向</p><p>每个非叶子节点的数据都在叶子节点冗余一份</p><h4 id="2-3索引的分类"><a href="#2-3索引的分类" class="headerlink" title="2.3索引的分类"></a>2.3索引的分类</h4><h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><h4 id="3-1-事务的特性"><a href="#3-1-事务的特性" class="headerlink" title="3.1 事务的特性"></a>3.1 事务的特性</h4><h4 id="3-2-事务的隔离级别"><a href="#3-2-事务的隔离级别" class="headerlink" title="3.2 事务的隔离级别"></a>3.2 事务的隔离级别</h4><h3 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4.存储引擎"></a>4.存储引擎</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-网络&quot;&gt;&lt;a href=&quot;#1-网络&quot; class=&quot;headerlink&quot; title=&quot;1.网络&quot;&gt;&lt;/a&gt;1.网络&lt;/h1&gt;&lt;h3 id=&quot;1-OSI七层模型&quot;&gt;&lt;a href=&quot;#1-OSI七层模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="未分类" scheme="http://example.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="Hexo, Markdown" scheme="http://example.com/tags/Hexo-Markdown/"/>
    
  </entry>
  
  <entry>
    <title>题单</title>
    <link href="http://example.com/2025/09/11/%E9%A2%98%E5%8D%95/"/>
    <id>http://example.com/2025/09/11/%E9%A2%98%E5%8D%95/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-22T04:31:36.223Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="🔹-数组（Array）"><a href="#🔹-数组（Array）" class="headerlink" title="🔹 数组（Array）"></a>🔹 数组（Array）</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(diff), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最大子数组和（Kadane-算法）"><a href="#2-最大子数组和（Kadane-算法）" class="headerlink" title="2. 最大子数组和（Kadane 算法）"></a>2. 最大子数组和（Kadane 算法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>], cur = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i], cur + nums[i]);</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-链表（Linked-List）"><a href="#🔹-链表（Linked-List）" class="headerlink" title="🔹 链表（Linked List）"></a>🔹 链表（Linked List）</h2><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断链表是否有环（快慢指针）"><a href="#2-判断链表是否有环（快慢指针）" class="headerlink" title="2. 判断链表是否有环（快慢指针）"></a>2. 判断链表是否有环（快慢指针）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-栈-队列"><a href="#🔹-栈-队列" class="headerlink" title="🔹 栈 &#x2F; 队列"></a>🔹 栈 &#x2F; 队列</h2><h3 id="1-有效括号"><a href="#1-有效括号" class="headerlink" title="1. 有效括号"></a>1. 有效括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2. 用栈实现队列"></a>2. 用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123; in.push(x); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; peek(); <span class="keyword">return</span> out.pop(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) <span class="keyword">while</span> (!in.isEmpty()) out.push(in.pop());</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123; <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-二叉树"><a href="#🔹-二叉树" class="headerlink" title="🔹 二叉树"></a>🔹 二叉树</h2><h3 id="1-二叉树的遍历（递归-迭代）"><a href="#1-二叉树的遍历（递归-迭代）" class="headerlink" title="1. 二叉树的遍历（递归 &amp; 迭代）"></a>1. 二叉树的遍历（递归 &amp; 迭代）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2. 验证二叉搜索树"></a>2. 验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(node.left, min, node.val) &amp;&amp; helper(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-堆-优先队列"><a href="#🔹-堆-优先队列" class="headerlink" title="🔹 堆 &#x2F; 优先队列"></a>🔹 堆 &#x2F; 优先队列</h2><h3 id="1-数组中的第-K-大元素"><a href="#1-数组中的第-K-大元素" class="headerlink" title="1. 数组中的第 K 大元素"></a>1. 数组中的第 K 大元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        pq.offer(n);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-图"><a href="#🔹-图" class="headerlink" title="🔹 图"></a>🔹 图</h2><h3 id="1-图的-BFS"><a href="#1-图的-BFS" class="headerlink" title="1. 图的 BFS"></a>1. 图的 BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.size()];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.get(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nei]) &#123;</span><br><span class="line">                visited[nei] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-岛屿数量（DFS）"><a href="#2-岛屿数量（DFS）" class="headerlink" title="2. 岛屿数量（DFS）"></a>2. 岛屿数量（DFS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-排序算法"><a href="#🔹-排序算法" class="headerlink" title="🔹 排序算法"></a>🔹 排序算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left], i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-动态规划（DP）"><a href="#🔹-动态规划（DP）" class="headerlink" title="🔹 动态规划（DP）"></a>🔹 动态规划（DP）</h2><h3 id="1-爬楼梯（斐波那契）"><a href="#1-爬楼梯（斐波那契）" class="headerlink" title="1. 爬楼梯（斐波那契）"></a>1. 爬楼梯（斐波那契）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长公共子序列（LCS）"><a href="#2-最长公共子序列（LCS）" class="headerlink" title="2. 最长公共子序列（LCS）"></a>2. 最长公共子序列（LCS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><blockquote><p>先给两个通用辅助类（很多题会用到）：<code>ListNode</code>（链表节点）和 <code>TreeNode</code>（二叉树节点）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目录（快速跳转）"><a href="#目录（快速跳转）" class="headerlink" title="目录（快速跳转）"></a>目录（快速跳转）</h1><ol><li>数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</li><li>排序 &#x2F; 选择（Quickselect）</li><li>链表进阶</li><li>栈进阶 &#x2F; 单调栈</li><li>队列 &#x2F; 双端队列（滑动窗口最大值）</li><li>堆（合并 K 表、数据流中位数）</li><li>树（序列化&#x2F;反序列化、LCA、最大路径和）</li><li>图（拓扑、Dijkstra、Bellman-Ford、并查集）</li><li>动态规划（LIS、背包、DP 状态压缩等）</li><li>回溯（N 皇后、组合&#x2F;子集变体）</li><li>字符串（KMP、Rabin-Karp、最小覆盖子串）</li><li>字典树 Trie</li><li>线段树 &#x2F; 树状数组（Fenwick）</li><li>位运算 &#x2F; 数学小技巧</li><li>设计题（LRU Cache）</li></ol><hr><h1 id="1-数组-双指针-滑动窗口-前缀和"><a href="#1-数组-双指针-滑动窗口-前缀和" class="headerlink" title="1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和"></a>1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</h1><h3 id="1-1-最长不含重复字符的子串（LeetCode-3）"><a href="#1-1-最长不含重复字符的子串（LeetCode-3）" class="headerlink" title="1.1 最长不含重复字符的子串（LeetCode 3）"></a>1.1 最长不含重复字符的子串（LeetCode 3）</h3><p>思路：滑动窗口 + 哈希表记录字符上次出现位置。<br> 复杂度：O(n) 时间，O(min(n, charset)) 空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// ASCII</span></span><br><span class="line">    Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        start = Math.max(start, last[c] + <span class="number">1</span>);</span><br><span class="line">        maxLen = Math.max(maxLen, i - start + <span class="number">1</span>);</span><br><span class="line">        last[c] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-最小覆盖子串（LeetCode-76）"><a href="#1-2-最小覆盖子串（LeetCode-76）" class="headerlink" title="1.2 最小覆盖子串（LeetCode 76）"></a>1.2 最小覆盖子串（LeetCode 76）</h3><p>思路：滑动窗口 + 计数表；需要满足条件时收缩左边界。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) need[c]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, required = t.length(), minLen = Integer.MAX_VALUE, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right++);</span><br><span class="line">        <span class="keyword">if</span> (need[c]-- &gt; <span class="number">0</span>) required--;</span><br><span class="line">        <span class="keyword">while</span> (required == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; minLen) &#123; minLen = right - left; start = left; &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left++);</span><br><span class="line">            <span class="keyword">if</span> (need[d]++ &gt;= <span class="number">0</span>) required++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-子数组和等于-k（LeetCode-560）"><a href="#1-3-子数组和等于-k（LeetCode-560）" class="headerlink" title="1.3 子数组和等于 k（LeetCode 560）"></a>1.3 子数组和等于 k（LeetCode 560）</h3><p>思路：前缀和 + 哈希表记录之前出现的前缀和频次。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    cnt.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">        res += cnt.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        cnt.put(sum, cnt.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-三数之和最接近（LeetCode-16）"><a href="#1-4-三数之和最接近（LeetCode-16）" class="headerlink" title="1.4 三数之和最接近（LeetCode 16）"></a>1.4 三数之和最接近（LeetCode 16）</h3><p>思路：排序 + 双指针。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(closest - target)) closest = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-排序-选择-Quickselect"><a href="#2-排序-选择-Quickselect" class="headerlink" title="2. 排序 &#x2F; 选择 (Quickselect)"></a>2. 排序 &#x2F; 选择 (Quickselect)</h1><h3 id="2-1-Quickselect：第-k-小-第-k-大"><a href="#2-1-Quickselect：第-k-小-第-k-大" class="headerlink" title="2.1 Quickselect：第 k 小 &#x2F; 第 k 大"></a>2.1 Quickselect：第 k 小 &#x2F; 第 k 大</h3><p>思路：类似快速排序 partition，期望线性时间。<br> 复杂度：平均 O(n)，最坏 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123; <span class="comment">// 1-based k-th smallest</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (k == pivot) <span class="keyword">return</span> a[k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivot) <span class="keyword">return</span> quickSelect(a, l, pivot - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, pivot + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotVal</span> <span class="operator">=</span> a[r], i = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= pivotVal) swap(a, i++, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-链表进阶"><a href="#3-链表进阶" class="headerlink" title="3. 链表进阶"></a>3. 链表进阶</h1><h3 id="3-1-反转-k-个一组（LeetCode-25）"><a href="#3-1-反转-k-个一组（LeetCode-25）" class="headerlink" title="3.1 反转 k 个一组（LeetCode 25）"></a>3.1 反转 k 个一组（LeetCode 25）</h3><p>思路：分段反转。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), prev = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; node != <span class="literal">null</span>; i++) node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> prev.next, curr = tail.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tail.next = curr.next;</span><br><span class="line">            curr.next = prev.next;</span><br><span class="line">            prev.next = curr;</span><br><span class="line">            curr = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-链表排序（归并排序，LeetCode-148）"><a href="#3-2-链表排序（归并排序，LeetCode-148）" class="headerlink" title="3.2 链表排序（归并排序，LeetCode 148）"></a>3.2 链表排序（归并排序，LeetCode 148）</h3><p>思路：递归分治，O(n log n) 时间，O(log n) 递归栈空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow.next; slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">null</span> &amp;&amp; b != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.val &lt; b.val) &#123; p.next = a; a = a.next; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; p.next = b; b = b.next; &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = (a != <span class="literal">null</span>) ? a : b;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-环的入口（LeetCode-142）"><a href="#3-3-环的入口（LeetCode-142）" class="headerlink" title="3.3 环的入口（LeetCode 142）"></a>3.3 环的入口（LeetCode 142）</h3><p>思路：Floyd 快慢指针，找到相遇点后从头与相遇点同步移动。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next; fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123; p = p.next; slow = slow.next; &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-栈进阶-单调栈"><a href="#4-栈进阶-单调栈" class="headerlink" title="4. 栈进阶 &#x2F; 单调栈"></a>4. 栈进阶 &#x2F; 单调栈</h1><h3 id="4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）"><a href="#4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）" class="headerlink" title="4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）"></a>4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）</h3><p>思路：维护单调递增或递减栈（存下标）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以寻找每个元素右侧第一个大于它的下标为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterIndices(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; arr[i] &gt; arr[st.peek()]) res[st.pop()] = i;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-逆波兰表达式求值（LeetCode-150）"><a href="#4-2-逆波兰表达式求值（LeetCode-150）" class="headerlink" title="4.2 逆波兰表达式求值（LeetCode 150）"></a>4.2 逆波兰表达式求值（LeetCode 150）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(t)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> st.pop(), a = st.pop();</span><br><span class="line">            <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> : st.push(a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> : st.push(a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> : st.push(a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> : st.push(a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> st.push(Integer.parseInt(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-队列-双端队列（滑动窗口最大值）"><a href="#5-队列-双端队列（滑动窗口最大值）" class="headerlink" title="5. 队列 &#x2F; 双端队列（滑动窗口最大值）"></a>5. 队列 &#x2F; 双端队列（滑动窗口最大值）</h1><h3 id="5-1-滑动窗口最大值（LeetCode-239）"><a href="#5-1-滑动窗口最大值（LeetCode-239）" class="headerlink" title="5.1 滑动窗口最大值（LeetCode 239）"></a>5.1 滑动窗口最大值（LeetCode 239）</h3><p>思路：用双端队列维护当前窗口的“候选”下标（单调递减）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt; i - k + <span class="number">1</span>) dq.pollFirst();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i]) dq.pollLast();</span><br><span class="line">        dq.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res[i - k + <span class="number">1</span>] = nums[dq.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆（PriorityQueue）"><a href="#6-堆（PriorityQueue）" class="headerlink" title="6. 堆（PriorityQueue）"></a>6. 堆（PriorityQueue）</h1><h3 id="6-1-合并-K-个有序链表（LeetCode-23）"><a href="#6-1-合并-K-个有序链表（LeetCode-23）" class="headerlink" title="6.1 合并 K 个有序链表（LeetCode 23）"></a>6.1 合并 K 个有序链表（LeetCode 23）</h3><p>思路：把每个链表头放入最小堆，循环弹出最小节点并推进。复杂度 O(N log k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a.val - b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode ln : lists) <span class="keyword">if</span> (ln != <span class="literal">null</span>) pq.offer(ln);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        cur.next = node; cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) pq.offer(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-数据流中位数（MedianFinder）"><a href="#6-2-数据流中位数（MedianFinder）" class="headerlink" title="6.2 数据流中位数（MedianFinder）"></a>6.2 数据流中位数（MedianFinder）</h3><p>思路：维护两个堆（大顶堆保存较小一半，小顶堆保存较大一半）。复杂度 add O(log n)，findMedian O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a); <span class="comment">// max-heap</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// min-heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        small.offer(num);</span><br><span class="line">        large.offer(small.poll());</span><br><span class="line">        <span class="keyword">if</span> (small.size() &lt; large.size()) small.offer(large.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt; large.size()) <span class="keyword">return</span> small.peek();</span><br><span class="line">        <span class="keyword">return</span> (small.peek() + large.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-树高级题"><a href="#7-树高级题" class="headerlink" title="7. 树高级题"></a>7. 树高级题</h1><h3 id="7-1-二叉树序列化与反序列化（LeetCode-297）"><a href="#7-1-二叉树序列化与反序列化（LeetCode-297）" class="headerlink" title="7.1 二叉树序列化与反序列化（LeetCode 297）"></a>7.1 二叉树序列化与反序列化（LeetCode 297）</h3><p>思路：BFS（层序）用特殊符号表示 null，或用前序 + 标记 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="literal">null</span>) sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(n.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                q.offer(n.left); q.offer(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span> || data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.left); &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.right); &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-最近公共祖先（LCA-二叉树，LeetCode-236）"><a href="#7-2-最近公共祖先（LCA-二叉树，LeetCode-236）" class="headerlink" title="7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）"></a>7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）</h3><p>思路：递归搜索左右子树，若左右都有非 null 返回当前结点。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-二叉树最大路径和（LeetCode-124）"><a href="#7-3-二叉树最大路径和（LeetCode-124）" class="headerlink" title="7.3 二叉树最大路径和（LeetCode 124）"></a>7.3 二叉树最大路径和（LeetCode 124）</h3><p>思路：每个节点计算经过该节点的最大向下路径贡献，维护全局最大。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.left));</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.right));</span><br><span class="line">    maxSum = Math.max(maxSum, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> node.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="8-图（高级）"><a href="#8-图（高级）" class="headerlink" title="8. 图（高级）"></a>8. 图（高级）</h1><h3 id="8-1-拓扑排序（Kahn-算法）"><a href="#8-1-拓扑排序（Kahn-算法）" class="headerlink" title="8.1 拓扑排序（Kahn 算法）"></a>8.1 拓扑排序（Kahn 算法）</h3><p>思路：入度为 0 的点入队，逐出并减小邻居入度。能检测有向无环图。复杂度 O(V+E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topoSort</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; adj)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) indeg[v]++;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) q.offer(i);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.poll(); res.add(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) <span class="keyword">if</span> (--indeg[v] == <span class="number">0</span>) q.offer(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == n ? res : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 若有环则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-Dijkstra（带优先队列的邻接表版本）"><a href="#8-2-Dijkstra（带优先队列的邻接表版本）" class="headerlink" title="8.2 Dijkstra（带优先队列的邻接表版本）"></a>8.2 Dijkstra（带优先队列的邻接表版本）</h3><p>复杂度 O((V+E) log V)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, w; Edge(<span class="type">int</span> t, <span class="type">int</span> w)&#123;to=t;<span class="built_in">this</span>.w=w;&#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> n, List&lt;List&lt;Edge&gt;&gt; graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a-&gt;a[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">0</span>], u = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + e.w &lt; dist[e.to]) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.w;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist[e.to], e.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Bellman-Ford（带负权检测）"><a href="#8-3-Bellman-Ford（带负权检测）" class="headerlink" title="8.3 Bellman-Ford（带负权检测）"></a>8.3 Bellman-Ford（带负权检测）</h3><p>复杂度 O(V*E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bellmanFord(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// relax n-1 times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> e[<span class="number">0</span>], v = e[<span class="number">1</span>], w = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[u] != Integer.MAX_VALUE &amp;&amp; dist[u] + w &lt; dist[v]) dist[v] = dist[u] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测负环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[e[<span class="number">0</span>]] != Integer.MAX_VALUE &amp;&amp; dist[e[<span class="number">0</span>]] + e[<span class="number">2</span>] &lt; dist[e[<span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 存在负环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-并查集（Union-Find）"><a href="#8-4-并查集（Union-Find）" class="headerlink" title="8.4 并查集（Union-Find）"></a>8.4 并查集（Union-Find）</h3><p>思路：用于连通性、群组合并、Kruskal 最小生成树等。带路径压缩和按秩合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent, rank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n]; rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> find(x), ry = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rx] &lt; rank[ry]) parent[rx] = ry;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rx] &gt; rank[ry]) parent[ry] = rx;</span><br><span class="line">        <span class="keyword">else</span> &#123; parent[ry] = rx; rank[rx]++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="9-动态规划（DP）"><a href="#9-动态规划（DP）" class="headerlink" title="9. 动态规划（DP）"></a>9. 动态规划（DP）</h1><h3 id="9-1-最长递增子序列（LIS）-—-O-n-log-n"><a href="#9-1-最长递增子序列（LIS）-—-O-n-log-n" class="headerlink" title="9.1 最长递增子序列（LIS） — O(n log n)"></a>9.1 最长递增子序列（LIS） — O(n log n)</h3><p>思路：维护 tails 数组，tails[i] &#x3D; 最小结尾值使得长度为 i+1。可选重建路径。复杂度 O(n log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Arrays.binarySearch(tails, <span class="number">0</span>, size, x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = -(i + <span class="number">1</span>);</span><br><span class="line">        tails[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == size) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-0-1-背包（经典-DP）"><a href="#9-2-0-1-背包（经典-DP）" class="headerlink" title="9.2 0&#x2F;1 背包（经典 DP）"></a>9.2 0&#x2F;1 背包（经典 DP）</h3><p>时间 O(nW)，空间可滚动到 O(W)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span>[] wt, <span class="type">int</span>[] val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wt.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> W; w &gt;= wt[i]; w--) &#123;</span><br><span class="line">            dp[w] = Math.max(dp[w], dp[w - wt[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-字符串拆分（Word-Break，LeetCode-139）"><a href="#9-3-字符串拆分（Word-Break，LeetCode-139）" class="headerlink" title="9.3 字符串拆分（Word Break，LeetCode 139）"></a>9.3 字符串拆分（Word Break，LeetCode 139）</h3><p>思路：DP，dp[i] &#x3D; [0..i)是否可拆分。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="10-回溯（Backtracking）"><a href="#10-回溯（Backtracking）" class="headerlink" title="10. 回溯（Backtracking）"></a>10. 回溯（Backtracking）</h1><h3 id="10-1-N-皇后（LeetCode-51）"><a href="#10-1-N-皇后（LeetCode-51）" class="headerlink" title="10.1 N 皇后（LeetCode 51）"></a>10.1 N 皇后（LeetCode 51）</h3><p>思路：回溯 + 列 &#x2F; 斜对角 剪枝，可用位运算优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] row : board) Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    backtrack(<span class="number">0</span>, board, res, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">char</span>[][] board, List&lt;List&lt;String&gt;&gt; res, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; sol = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] r : board) sol.add(<span class="keyword">new</span> <span class="title class_">String</span>(r));</span><br><span class="line">        res.add(sol);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col, n)) <span class="keyword">continue</span>;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        backtrack(row + <span class="number">1</span>, board, res, n);</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-组合总和（Combination-Sum，LeetCode-39）"><a href="#10-2-组合总和（Combination-Sum，LeetCode-39）" class="headerlink" title="10.2 组合总和（Combination Sum，LeetCode 39）"></a>10.2 组合总和（Combination Sum，LeetCode 39）</h3><p>思路：回溯，注意去重与剪枝（排序后剪枝）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    back(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span>[] cand, <span class="type">int</span> idx, <span class="type">int</span> target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123; res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; cand.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cand[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">        path.add(cand[i]);</span><br><span class="line">        back(cand, i, target - cand[i], path, res); <span class="comment">// i 允许重复</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="11-字符串算法"><a href="#11-字符串算法" class="headerlink" title="11. 字符串算法"></a>11. 字符串算法</h1><h3 id="11-1-KMP（计算-LPS）"><a href="#11-1-KMP（计算-LPS）" class="headerlink" title="11.1 KMP（计算 LPS）"></a>11.1 KMP（计算 LPS）</h3><p>思路：预处理模式串得到最长相同前后缀数组 lps，然后线性匹配。复杂度 O(n+m)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] computeLPS(String pat) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pat.length();</span><br><span class="line">    <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat.charAt(i) == pat.charAt(len)) &#123; lps[i++] = ++len; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = lps[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123; lps[i++] = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kmp</span><span class="params">(String s, String pat)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] lps = computeLPS(pat);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == pat.charAt(j)) &#123; i++; j++; <span class="keyword">if</span> (j == pat.length()) <span class="keyword">return</span> i - j; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) j = lps[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-Rabin-Karp（字符串哈希）"><a href="#11-2-Rabin-Karp（字符串哈希）" class="headerlink" title="11.2 Rabin-Karp（字符串哈希）"></a>11.2 Rabin-Karp（字符串哈希）</h3><p>思路：用滚动哈希快速比较子串，注意哈希冲突处理。复杂度 平均 O(n).</p><hr><h1 id="12-字典树-Trie"><a href="#12-字典树-Trie" class="headerlink" title="12. 字典树 Trie"></a>12. 字典树 Trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] next = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) cur.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="13-线段树-树状数组（Fenwick）"><a href="#13-线段树-树状数组（Fenwick）" class="headerlink" title="13. 线段树 &#x2F; 树状数组（Fenwick）"></a>13. 线段树 &#x2F; 树状数组（Fenwick）</h1><h3 id="13-1-树状数组（Fenwick）"><a href="#13-1-树状数组（Fenwick）" class="headerlink" title="13.1 树状数组（Fenwick）"></a>13.1 树状数组（Fenwick）</h3><p>功能：前缀和 &#x2F; 单点更新，构建简单，复杂度 O(log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="type">int</span>[] bit;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fenwick</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="built_in">this</span>.n = n; bit = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123; <span class="keyword">for</span> (; i &lt;= n; i += i &amp; -i) bit[i] += delta; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= i &amp; -i) s += bit[i]; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123; <span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-线段树（区间和-区间更新）"><a href="#13-2-线段树（区间和-区间更新）" class="headerlink" title="13.2 线段树（区间和 &#x2F; 区间更新）"></a>13.2 线段树（区间和 &#x2F; 区间更新）</h3><p>实现略长，模式熟悉后直接写模板即可 —— 支持区间查询&#x2F;更新，复杂度 O(log n)。</p><hr><h1 id="14-位运算-数学小技巧"><a href="#14-位运算-数学小技巧" class="headerlink" title="14. 位运算 &#x2F; 数学小技巧"></a>14. 位运算 &#x2F; 数学小技巧</h1><ul><li>单数：<code>x &amp; 1</code>；取反 <code>~x</code>。</li><li>异或特性：<code>a ^ a = 0</code>，用于求单数、交换不需要临时变量等。</li><li><code>lowbit(x) = x &amp; -x</code>（树状数组用到）。</li><li>统计 1 的个数（Hamming weight）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; n &amp;= (n - <span class="number">1</span>); cnt++; &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单数问题（数组中其它数出现两次，只有一个出现一次）：使用 XOR。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) res ^= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="15-设计题：LRU-Cache（双向链表-哈希表）"><a href="#15-设计题：LRU-Cache（双向链表-哈希表）" class="headerlink" title="15. 设计题：LRU Cache（双向链表 + 哈希表）"></a>15. 设计题：LRU Cache（双向链表 + 哈希表）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> key, val; Node prev, next; Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;key=k;val=v;&#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>), tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        head.next = tail; tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next; node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = head.next; node.prev = head;</span><br><span class="line">        head.next.prev = node; head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        remove(node); addToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key); node.val = value;</span><br><span class="line">            remove(node); addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">tailPrev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(tailPrev);</span><br><span class="line">                map.remove(tailPrev.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            addToHead(node); map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="小结与复习建议（给你一个刷题路线）"><a href="#小结与复习建议（给你一个刷题路线）" class="headerlink" title="小结与复习建议（给你一个刷题路线）"></a>小结与复习建议（给你一个刷题路线）</h1><ul><li>基础题（数组 &#x2F; 链表 &#x2F; 栈 &#x2F; 队列 &#x2F; 哈希表）：先熟练增删查遍历，能写模板。</li><li>递归 + 树（中序&#x2F;前序&#x2F;后序&#x2F;层序） → 再做 LCA、序列化、最低深度。</li><li>双指针 &#x2F; 滑动窗口 &#x2F; 单调栈：拿来解决子数组、子串类题。</li><li>堆 &#x2F; 并查集 &#x2F; 图（BFS&#x2F;DFS&#x2F;Dijkstra&#x2F;拓扑） → 面试常考。</li><li>动态规划：从经典 1D DP → 背包、序列 DP → 状态压缩。</li><li>回溯：背诵回溯模板，练 N 皇后、子集 &#x2F; 组合 &#x2F; 排列 变体。</li><li>设计题：LRU&#x2F;MedianFinder&#x2F;Trie&#x2F;SegmentTree 模板要熟悉。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;🔹-数组（Array）&quot;&gt;&lt;a href=&quot;#🔹-数组（Array）&quot; class=&quot;headerlink&quot; title=&quot;🔹 数组（Array）&quot;&gt;&lt;/a&gt;🔹 数组（Array）&lt;/h2&gt;&lt;h3 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面试题目</title>
    <link href="http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2025-09-11T10:29:28.000Z</published>
    <updated>2025-09-22T04:31:09.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java-基础语法-关键字"><a href="#一、Java-基础语法-关键字" class="headerlink" title="一、Java 基础语法 &amp; 关键字"></a>一、Java 基础语法 &amp; 关键字</h2><h2 id="1-JDK、JRE-和-JVM-的区别"><a href="#1-JDK、JRE-和-JVM-的区别" class="headerlink" title="1. JDK、JRE 和 JVM 的区别"></a>1. JDK、JRE 和 JVM 的区别</h2><ul><li><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，负责执行字节码（<code>.class</code>）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。</li><li><strong>JRE（Java Runtime Environment）</strong>：运行环境，包含 JVM、核心类库（rt.jar 或 modules）、以及运行时需要的其它资源。用于运行 Java 程序。</li><li><strong>JDK（Java Development Kit）</strong>：开发工具包，包含 JRE + 开发工具（<code>javac</code>、<code>jar</code>、<code>javadoc</code>、调试工具等）。用于开发 Java 程序。<br> 总结：JDK ⊃ JRE ⊃ JVM（JDK 包含 JRE，JRE 包含 JVM）。</li></ul><hr><h2 id="2-Java-的跨平台原理是什么？"><a href="#2-Java-的跨平台原理是什么？" class="headerlink" title="2. Java 的跨平台原理是什么？"></a>2. Java 的跨平台原理是什么？</h2><ul><li>Java 程序先由 <code>javac</code> 编译成与平台无关的 <strong>字节码</strong>（<code>.class</code>）。字节码不是机器码，而是供 JVM 执行的指令集。</li><li>每个平台（Windows&#x2F;Linux&#x2F;macOS）有相应的 JVM 实现，JVM 把字节码翻译成该平台的机器指令（通过解释器、JIT 编译器等）。因此同一套 <code>.class</code> 可以在不同平台的 JVM 上运行 —— “一次编写，处处运行”（Write Once, Run Anywhere）。</li><li>其它保证跨平台的要点：标准库隐藏平台差异（I&#x2F;O、线程等），需避免使用与平台绑定的本地代码（JNI）。</li></ul><hr><h2 id="3-Java-的基本数据类型有哪些？各自的默认值？"><a href="#3-Java-的基本数据类型有哪些？各自的默认值？" class="headerlink" title="3. Java 的基本数据类型有哪些？各自的默认值？"></a>3. Java 的基本数据类型有哪些？各自的默认值？</h2><p>8 种基本类型及默认值（成员变量&#x2F;数组元素；局部变量无默认值必须初始化）：</p><ul><li><code>byte</code>：1 byte，默认值 <code>0</code></li><li><code>short</code>：2 bytes，默认值 <code>0</code></li><li><code>int</code>：4 bytes，默认值 <code>0</code></li><li><code>long</code>：8 bytes，默认值 <code>0L</code></li><li><code>float</code>：4 bytes，默认值 <code>0.0f</code></li><li><code>double</code>：8 bytes，默认值 <code>0.0d</code></li><li><code>char</code>：2 bytes（UTF-16 code unit），默认值 <code>&#39;\u0000&#39;</code>（即 0）</li><li><code>boolean</code>：JVM 语义上用 1 bit 表示，默认值 <code>false</code></li></ul><p>另外，<strong>引用类型</strong>（对象、数组等）的默认值是 <code>null</code>。</p><hr><h2 id="4-byte、short、int、long-各占多少字节？"><a href="#4-byte、short、int、long-各占多少字节？" class="headerlink" title="4. byte、short、int、long 各占多少字节？"></a>4. <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 各占多少字节？</h2><ul><li><code>byte</code>：<strong>1 字节</strong>（8 位）</li><li><code>short</code>：<strong>2 字节</strong>（16 位）</li><li><code>int</code>：<strong>4 字节</strong>（32 位）</li><li><code>long</code>：<strong>8 字节</strong>（64 位）</li></ul><p>（上述为 Java 语言规范定义，与平台无关。）</p><hr><h2 id="5-float-和-double-的区别？"><a href="#5-float-和-double-的区别？" class="headerlink" title="5. float 和 double 的区别？"></a>5. <code>float</code> 和 <code>double</code> 的区别？</h2><ul><li>精度与存储：<ul><li><code>float</code>：32 位单精度浮点（IEEE 754），约 6~7 位有效数字。</li><li><code>double</code>：64 位双精度浮点（IEEE 754），约 15~16 位有效数字。</li></ul></li><li>精度更高的 <code>double</code> 更常用；<code>float</code> 用于节省内存或与特定 API（如图形库）兼容。</li><li>注意：浮点数有精度误差，不适合做精确货币计算（应使用 <code>BigDecimal</code>）。</li><li>默认浮点字面量为 <code>double</code>（例如 <code>1.2</code> 是 <code>double</code>，写成 <code>1.2f</code> 才是 <code>float</code>）。</li></ul><hr><h2 id="6-char-类型占几个字节？能存汉字吗？"><a href="#6-char-类型占几个字节？能存汉字吗？" class="headerlink" title="6. char 类型占几个字节？能存汉字吗？"></a>6. <code>char</code> 类型占几个字节？能存汉字吗？</h2><ul><li><code>char</code> 占 <strong>2 字节</strong>（16 位），表示 UTF-16 的一个 code unit。</li><li>能否存汉字：多数常用汉字（位于基本多文种平面 BMP）可以用单个 <code>char</code> 表示（例如 <code>&#39;你&#39;</code>）；但有些罕见汉字或 emoji 属于补充平面（Supplementary Planes），它们需要 <strong>两个 char（称为 surrogate pair）</strong> 来表示。</li><li>因此，单个 <code>char</code> 能表示一个 UTF-16 code unit，而不是完整的 Unicode code point。处理 Unicode 字符时注意使用 <code>int codePoint</code> &#x2F; <code>Character</code> 的相关 API。</li></ul><hr><h2 id="7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"><a href="#7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？" class="headerlink" title="7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"></a>7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？</h2><ul><li><p><strong>概念</strong>：</p><ul><li>装箱：把基本类型自动转换成对应的包装类型（如 <code>int</code> → <code>Integer</code>）。</li><li>拆箱：把包装类型自动转换回基本类型（如 <code>Integer</code> → <code>int</code>）。</li></ul></li><li><p><strong>编译器行为</strong>：自动装箱&#x2F;拆箱是在编译期由 Java 编译器插入对应的调用，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        <span class="comment">// 编译器会转换为 Integer.valueOf(10)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;             <span class="comment">// 编译器会转换为 a.intValue()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>valueOf 缓存</strong>：包装类（如 <code>Integer.valueOf(int)</code>）会对小整数（默认 -128 到 127）做缓存以重用对象，减少频繁创建对象。</p></li><li><p><strong>注意事项</strong>：</p><ul><li><p>拆箱 <code>null</code> 会抛出 <code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// NPE</span></span><br></pre></td></tr></table></figure></li><li><p>装箱&#x2F;拆箱会有性能开销（对象创建、装箱&#x2F;拆箱方法调用），在性能敏感场景尽量使用基本类型或手动优化。</p></li><li><p>比较时注意：<code>Integer a = 100; Integer b = 100; a==b</code> 在缓存范围内可能为 <code>true</code>，超出范围则通常为 <code>false</code>。</p></li></ul></li></ul><hr><h2 id="8-和-equals-的区别？"><a href="#8-和-equals-的区别？" class="headerlink" title="8. == 和 equals() 的区别？"></a>8. <code>==</code> 和 <code>equals()</code> 的区别？</h2><ul><li><strong>&#x3D;&#x3D;</strong>：<ul><li>对于基本类型：比较 <strong>值</strong>（数值是否相等）。</li><li>对于引用类型：比较 <strong>引用地址</strong>（是否是同一个对象）。</li></ul></li><li><strong>equals()</strong>：<ul><li>是 <code>Object</code> 的方法，默认实现也是比较引用（等价于 <code>==</code>）。</li><li>许多类（如 <code>String</code>、<code>Integer</code>、集合类等）重写了 <code>equals()</code>，用于比较<strong>逻辑&#x2F;内容相等</strong>。</li></ul></li><li><strong>使用建议</strong>：<ul><li>比较对象内容用 <code>equals()</code>（需检查 <code>null</code>），比较是否同一实例用 <code>==</code>。</li><li>与 <code>equals()</code> 配套应重写 <code>hashCode()</code>（见下题）。</li></ul></li></ul><hr><h2 id="9-hashCode-和-equals-的关系？"><a href="#9-hashCode-和-equals-的关系？" class="headerlink" title="9. hashCode 和 equals 的关系？"></a>9. <code>hashCode</code> 和 <code>equals</code> 的关系？</h2><ul><li><strong>合同（Contract）</strong>（重要）：<ol><li>如果两个对象通过 <code>equals()</code> 被判定为相等（<code>a.equals(b)</code> 为 <code>true</code>），那么 <code>a.hashCode() == b.hashCode()</code> 必须成立。</li><li>反之不要求：<code>hashCode</code> 相等的对象不一定 <code>equals()</code> 相等（哈希冲突允许）。</li></ol></li><li><strong>在哈希集合中的角色</strong>：<ul><li>哈希表（<code>HashMap</code>&#x2F;<code>HashSet</code>）先用 <code>hashCode()</code> 找到桶（bucket），若桶中有多个元素，再用 <code>equals()</code> 逐个比较确认相等或冲突。</li><li>如果只重写 <code>equals()</code> 而不重写 <code>hashCode()</code> 会破坏集合行为（例如放入 <code>HashSet</code> 后无法正确查找）。</li></ul></li><li><strong>实现要点</strong>：<ul><li><code>hashCode()</code> 要尽量分散（降低冲突），并在对象不可变字段上基于相同规则计算。</li><li>若对象可变，若用于哈希集合要小心：修改字段会导致 <code>hashCode()</code> 改变，破坏集合内部结构。</li></ul></li></ul><hr><h2 id="10-String、StringBuffer、StringBuilder-的区别？"><a href="#10-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="10. String、StringBuffer、StringBuilder 的区别？"></a>10. <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？</h2><ul><li><strong>String</strong>：<ul><li>不可变（immutable），每次修改都会产生新的对象（或新内部 char&#x2F;byte 数组）。</li><li>线程安全（因为不可变），适合频繁读取、少量修改的场景。</li></ul></li><li><strong>StringBuffer</strong>：<ul><li>可变的字符序列（内部有缓冲区 <code>char[]</code>&#x2F;<code>byte[]</code>），几乎与 <code>StringBuilder</code> 接口相同。</li><li><strong>线程安全</strong>，其方法大多使用 <code>synchronized</code>，因此在多线程下可以被多个线程安全使用。</li><li>相对较慢（同步开销）。</li></ul></li><li><strong>StringBuilder（Java 5+）</strong>：<ul><li>可变，<strong>非线程安全</strong>（没有同步），比 <code>StringBuffer</code> 快。</li><li>推荐在单线程或外部已同步的场景下使用。</li></ul></li><li><strong>选择建议</strong>：<ul><li>多线程需要可变字符串：<code>StringBuffer</code>（或外部同步）。</li><li>单线程&#x2F;局部构造字符串：<code>StringBuilder</code>。</li><li>常量字符串或少量拼接：<code>String</code>（编译器对 <code>+</code> 会优化为 <code>StringBuilder</code>）。</li></ul></li></ul><hr><h2 id="11-为什么-String-是不可变的（immutable）？"><a href="#11-为什么-String-是不可变的（immutable）？" class="headerlink" title="11. 为什么 String 是不可变的（immutable）？"></a>11. 为什么 <code>String</code> 是不可变的（immutable）？</h2><p>原因（几条重要理由）：</p><ol><li><strong>安全性</strong>：<code>String</code> 经常用于关键场景（类加载器、网络地址、文件名、权限检查、数据库连接字符串等）。不可变保证在传递引用时不被恶意或意外修改。</li><li><strong>线程安全</strong>：不可变对象固有线程安全，多个线程可共享同一 <code>String</code> 实例而无需同步。</li><li><strong>性能（缓存 hashCode）</strong>：<code>String</code> 的哈希值可缓存（<code>hash</code> 字段），便于作为 Map 的 key，避免重复计算。</li><li><strong>字符串常量池</strong>：可安全地将字面量放入池中重用，不用复制或担心修改。</li><li><strong>优化</strong>：JVM 可进行共享、常量折叠等优化（更易于实现某些编译期&#x2F;运行期优化）。</li></ol><hr><h2 id="12-String-常量池的实现机制？"><a href="#12-String-常量池的实现机制？" class="headerlink" title="12. String 常量池的实现机制？"></a>12. <code>String</code> 常量池的实现机制？</h2><ul><li><strong>概念</strong>：编译期和运行期维护一个字符串池（String Intern Pool），用于存放字符串字面量（literal）和显式 <code>intern()</code> 后的字符串，以便重用相同内容的 <code>String</code> 实例。</li><li><strong>编译期</strong>：源代码中的字符串字面量（如 <code>&quot;abc&quot;</code>）会被放到常量池（编译后的 class 文件常量池），类加载后这些字面量会放入运行时的字符串池。</li><li><strong>运行期</strong>：<ul><li>以前（Java 6 及更早）：字符串常量池在 PermGen（方法区）中。</li><li>Java 7 起：常量池迁移到 Java 堆（运行时常量池也在堆里），避免 PermGen 问题。</li></ul></li><li><strong>intern()</strong>：当调用 <code>s.intern()</code> 时，JVM 会检查池中是否已有相同内容的字符串：<ul><li>若存在，返回池中的引用；</li><li>若不存在，将该字符串的引用加入池并返回它。</li></ul></li><li><strong>编译时优化</strong>：字符串常量的拼接（编译时常量）会在编译期合并，如 <code>&quot;a&quot; + &quot;b&quot;</code> → <code>&quot;ab&quot;</code>，直接放入常量池；而运行时拼接（变量参与）则使用 <code>StringBuilder</code>。</li></ul><hr><h2 id="13-new-String-abc-创建了几个对象？"><a href="#13-new-String-abc-创建了几个对象？" class="headerlink" title="13. new String(&quot;abc&quot;) 创建了几个对象？"></a>13. <code>new String(&quot;abc&quot;)</code> 创建了几个对象？</h2><ul><li><strong>通常情形</strong>：<ul><li>若 <code>&quot;abc&quot;</code> 字面量尚未在常量池中存在，执行 <code>new String(&quot;abc&quot;)</code> 会导致 <strong>两个对象</strong> 被创建：常量池中的 <code>&quot;abc&quot;</code>（一个 <code>String</code>）和堆中通过 <code>new</code> 创建的新的 <code>String</code> 实例（内容通常是对常量池中字符数组的复制或共享，具体实现随 Java 版本而异）。</li><li>如果字面量 <code>&quot;abc&quot;</code> 已经存在于常量池中（例如之前被加载过），那么 <code>new String(&quot;abc&quot;)</code> 只会创建 <strong>一个堆对象</strong>（new 的那个 <code>String</code>）。</li></ul></li><li><strong>注意</strong>：自 Java 7&#x2F;9 后 <code>String</code> 内部实现改变（压缩字符串、byte[] 存储等），但逻辑上上述结论成立：通常 1 或 2 个对象，取决于常量池中是否已存在该字面量。</li></ul><hr><h2 id="14-final-关键字的作用？"><a href="#14-final-关键字的作用？" class="headerlink" title="14. final 关键字的作用？"></a>14. <code>final</code> 关键字的作用？</h2><ul><li><strong>用于类（final class）</strong>：类不可被继承（如 <code>String</code>）。</li><li><strong>用于方法（final 方法）</strong>：方法不能被子类重写（override），用于确保行为不可变。</li><li><strong>用于变量（final 字段&#x2F;局部变量）</strong>：<ul><li>对基本类型：赋值后值不可改变（常量）。</li><li>对引用类型：引用不可改变（不能指向另一个对象），但所指向对象的内部状态仍可变（除非对象本身不可变）。</li><li><code>static final</code> 常用来定义常量（编译期常量）。</li></ul></li><li><strong>用于参数</strong>（方法形参可以声明为 <code>final</code>）：代表方法内不能修改该参数引用&#x2F;值。</li><li><strong>其它用途</strong>：在多线程中，<code>final</code> 字段的写-构造过程被 JMM（Java 内存模型）处理，确保构造完成后其他线程可见（安全发布方面有好处）。</li></ul><hr><h2 id="15-static-关键字的作用？"><a href="#15-static-关键字的作用？" class="headerlink" title="15. static 关键字的作用？"></a>15. <code>static</code> 关键字的作用？</h2><ul><li>用于声明类级别成员（字段、方法、初始化块、嵌套类），不依赖实例。</li><li><strong>static 变量</strong>：类变量，所有实例共享一份。内存中仅有一份副本。</li><li><strong>static 方法</strong>：类方法，可通过 <code>ClassName.method()</code> 调用；不能直接访问非静态成员（因无 this）。</li><li><strong>static 代码块</strong>：类加载时执行一次（用于静态初始化）。</li><li><strong>static 嵌套类</strong>：可以声明为静态的内部类（静态嵌套类），没有外部实例引用。</li></ul><hr><h2 id="16-static-修饰变量、方法、代码块分别意味着什么？"><a href="#16-static-修饰变量、方法、代码块分别意味着什么？" class="headerlink" title="16. static 修饰变量、方法、代码块分别意味着什么？"></a>16. <code>static</code> 修饰变量、方法、代码块分别意味着什么？</h2><ul><li><strong>static 变量（类变量）</strong>：<ul><li>随类加载而创建，所有对象共享同一份数据。</li><li>可通过 <code>ClassName.field</code> 或 <code>instance.field</code>（不推荐）访问。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于类，调用时无需实例。</li><li>不能使用 <code>this</code>、不能直接访问非静态成员。</li><li>可作为工具方法（如 <code>Math.abs()</code>）。</li></ul></li><li><strong>static 代码块</strong>：<ul><li>在类加载阶段执行一次，用于复杂静态初始化（比如初始化静态常量、加载本地库等）。</li><li>执行顺序：静态块按定义顺序执行，类加载时运行（在实例化之前）。</li></ul></li></ul><hr><h2 id="17-static-和-final-能一起用吗？"><a href="#17-static-和-final-能一起用吗？" class="headerlink" title="17. static 和 final 能一起用吗？"></a>17. <code>static</code> 和 <code>final</code> 能一起用吗？</h2><ul><li><p><strong>能</strong>。<code>static final</code> 常用于定义类常量（尤其是基本类型和 <code>String</code>），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final int MAX = 100;</span><br><span class="line">public static final String NAME = &quot;abc&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>区别</strong>：</p><ul><li>如果是编译期常量（<code>static final</code> 基本类型或 <code>String</code> 且在编译时可以确定），编译器会将其内联到使用处（被引用的类编译后看到的是常量值），注意跨模块修改可能导致需要重新编译引用方。</li><li>如果是 <code>static final</code> 引用对象且不是编译期常量，则引用本身不可变，但对象内容可能可变。</li></ul></li></ul><hr><h2 id="18-static-内部类和非静态内部类的区别？"><a href="#18-static-内部类和非静态内部类的区别？" class="headerlink" title="18. static 内部类和非静态内部类的区别？"></a>18. <code>static</code> 内部类和非静态内部类的区别？</h2><ul><li><strong>静态内部类（static nested class）</strong>：<ul><li>相当于外部类的一个静态成员。</li><li><strong>没有</strong>对外部类实例的隐式引用（不能直接访问外部类的非静态成员）。</li><li>可以像普通类那样实例化：<code>Outer.StaticInner inner = new Outer.StaticInner();</code></li></ul></li><li><strong>非静态内部类（inner class）</strong>：<ul><li>每个实例隐式持有一个外部类实例引用（<code>Outer.this</code>），可以直接访问外部类的所有成员（包括私有成员）。</li><li>创建方式：<code>Outer outer = new Outer(); Outer.Inner inner = outer.new Inner();</code></li><li>占用外部类对象的内存引用，可能导致内存泄露（如果长期持有内部类实例导致外部类不能被回收）。</li></ul></li><li><strong>选择原则</strong>：如果内部类不需要访问外部实例成员，优先使用 <code>static</code> 嵌套类，避免额外引用。</li></ul><hr><h2 id="19-Java-中的-this-和-super-的区别？"><a href="#19-Java-中的-this-和-super-的区别？" class="headerlink" title="19. Java 中的 this 和 super 的区别？"></a>19. Java 中的 <code>this</code> 和 <code>super</code> 的区别？</h2><ul><li><strong>this</strong>：<ul><li>引用当前对象的引用。</li><li>用于访问当前类的实例变量、调用当前类的其他构造器（<code>this(...)</code>）、或传递当前对象引用。</li></ul></li><li><strong>super</strong>：<ul><li>引用当前对象的父类部分。</li><li>用于访问父类被覆盖的方法（<code>super.method()</code>）、父类字段（若有同名字段）、以及在子类构造器第一行调用父类构造器（<code>super(...)</code>）。</li></ul></li><li><strong>注意</strong>：<ul><li><code>this()</code> 或 <code>super()</code> 必须在构造器的第一行（两者不能同时出现）。</li><li><code>super</code> 不能用于访问父类的 private 成员（编译期限制）。</li></ul></li></ul><hr><h2 id="20-Java-中构造方法能否被重写？"><a href="#20-Java-中构造方法能否被重写？" class="headerlink" title="20. Java 中构造方法能否被重写？"></a>20. Java 中构造方法能否被重写？</h2><ul><li><strong>不能</strong>。重写（override）适用于实例方法，构造方法不是继承的成员，子类不能重写父类的构造器。</li><li><strong>可以重载（overload）</strong>：在同一类中同名构造器有不同参数列表属于重载。</li><li>子类构造器可通过 <code>super(...)</code> 显式调用父类构造器来完成父类初始化。</li></ul><hr><h2 id="21-接口和抽象类的区别？"><a href="#21-接口和抽象类的区别？" class="headerlink" title="21. 接口和抽象类的区别？"></a>21. 接口和抽象类的区别？</h2><ul><li><strong>接口（interface）</strong>：<ul><li>早期（Java 7 之前）：只包含抽象方法（默认是 <code>public abstract</code>）和 <code>public static final</code> 常量。</li><li>Java 8+：可以包含 <code>default</code> 方法与 <code>static</code> 方法（可以有部分实现）；Java 9+ 允许 <code>private</code> 方法。</li><li>支持多继承（一个类可以实现多个接口）。</li><li>没有实例字段（除 <code>static final</code> 常量外）。</li></ul></li><li><strong>抽象类（abstract class）</strong>：<ul><li>可以有实例字段（非静态成员变量）、已有实现的方法（具体方法）、构造器。</li><li>适合表示一类有共同行为并共享状态的类层次。</li><li>类只能单继承（只能继承一个抽象类）。</li></ul></li><li><strong>选择建议</strong>：<ul><li>如果需要多继承行为、只定义方法契约且不需要状态，使用接口。</li><li>如果需要提供共有实现和状态，使用抽象类。</li></ul></li></ul><hr><h2 id="22-接口中可以有-default-方法和-static-方法吗？"><a href="#22-接口中可以有-default-方法和-static-方法吗？" class="headerlink" title="22. 接口中可以有 default 方法和 static 方法吗？"></a>22. 接口中可以有 <code>default</code> 方法和 <code>static</code> 方法吗？</h2><ul><li><strong>可以（Java 8 起）</strong>。<ul><li><code>default</code> 方法：为实现类提供默认实现，避免破坏已有实现（接口演化）。实现类可以覆盖（override）。</li><li><code>static</code> 方法：属于接口自身，可以通过 <code>InterfaceName.method()</code> 调用，不能通过实例调用。</li></ul></li><li>Java 9 及以后还可有 <code>private</code> 方法，供接口内部复用实现逻辑。</li></ul><hr><h2 id="23-Java-8-接口新增了什么？"><a href="#23-Java-8-接口新增了什么？" class="headerlink" title="23. Java 8 接口新增了什么？"></a>23. Java 8 接口新增了什么？</h2><ul><li>Java 8 在接口中新增了 <strong>default 方法</strong> 和 <strong>static 方法</strong>，允许接口提供带实现的方法，从而便于接口的演化（向后兼容）。这也是 Java 8 引入函数式编程支持的基础之一（允许接口作为函数式接口）。</li></ul><hr><h2 id="24-Java-8-有什么新特性，并详细介绍（重点）"><a href="#24-Java-8-有什么新特性，并详细介绍（重点）" class="headerlink" title="24. Java 8 有什么新特性，并详细介绍（重点）"></a>24. Java 8 有什么新特性，并详细介绍（重点）</h2><h1 id="一、Java-8-新特性深入解析"><a href="#一、Java-8-新特性深入解析" class="headerlink" title="一、Java 8 新特性深入解析"></a>一、Java 8 新特性深入解析</h1><h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>匿名函数，允许把行为作为参数传递。</li><li>简化匿名内部类写法，实现函数式编程。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器生成静态&#x2F;实例方法 + <code>invokedynamic</code> 指令。</li><li>JVM 调用 <code>LambdaMetafactory</code> 动态生成函数对象，实现 <strong>函数式接口</strong>。</li><li>捕获外部变量通过闭包机制存储（必须是 <code>effectively final</code>）。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>语法简洁</li><li>可作为参数传递行为</li><li>性能高于匿名内部类（减少对象创建）</li></ul><hr><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>仅有一个抽象方法的接口，用作 Lambda 表达式的目标类型。</li><li>可用 <code>@FunctionalInterface</code> 标识。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; c = Integer::valueOf;</span><br><span class="line">System.out.println(c.convert(&quot;123&quot;)); // 123</span><br></pre></td></tr></table></figure><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Lambda 表达式编译时生成实现函数式接口的函数对象。</li><li>捕获变量通过闭包对象保存。</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>简化匿名类</li><li>支持函数式编程</li><li>可与 Stream &#x2F; Optional 等结合</li></ul><hr><h2 id="3-Stream-API"><a href="#3-Stream-API" class="headerlink" title="3. Stream API"></a>3. Stream API</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>对集合进行声明式操作（过滤、映射、归约）。</li><li>支持 <strong>惰性求值</strong> 和 <strong>并行处理</strong>。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; filtered = names.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(filtered); // [ALICE, CHARLIE]</span><br></pre></td></tr></table></figure><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Stream 是流水线对象，中间操作返回新的 Stream，终端操作触发计算。</li><li>串行流：顺序迭代器处理</li><li>并行流：ForkJoinPool 分块处理</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>声明式、链式操作</li><li>支持并行</li><li>可与 Lambda &#x2F; 方法引用结合</li></ul><hr><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>Lambda 表达式的简化写法，引用现有方法。</li><li>类型：<ol><li>静态方法引用：<code>ClassName::staticMethod</code></li><li>实例方法引用：<code>instance::method</code></li><li>构造器引用：<code>ClassName::new</code></li></ol></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;);</span><br><span class="line">names.forEach(System.out::println); // 实例方法引用</span><br><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new; // 构造器引用</span><br></pre></td></tr></table></figure><h3 id="底层原理-3"><a href="#底层原理-3" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器转成 Lambda 表达式 + invokedynamic。</li><li>JVM 生成实现函数式接口的函数对象，内部持有方法引用。</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>简洁直观</li><li>可减少 Lambda 代码</li><li>与 Stream &#x2F; Optional 配合使用</li></ul><hr><h2 id="5-java-time-API"><a href="#5-java-time-API" class="headerlink" title="5. java.time API"></a>5. java.time API</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul><li>替代 <code>Date</code> &#x2F; <code>Calendar</code>，不可变、线程安全。</li><li>核心类：<ul><li><code>LocalDate</code> &#x2F; <code>LocalTime</code> &#x2F; <code>LocalDateTime</code>（无时区）</li><li><code>ZonedDateTime</code>（带时区）</li><li><code>Duration</code> &#x2F; <code>Period</code>（时间段）</li></ul></li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;Asia/Singapore&quot;));</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line">System.out.println(zdt);</span><br></pre></td></tr></table></figure><h3 id="底层原理-4"><a href="#底层原理-4" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部字段 <code>final</code> 保存值，不可变。</li><li>工厂方法创建对象，链式操作返回新对象。</li><li>使用 enum + 整型&#x2F;字节优化存储（如 LocalDate 年月日用 int）。</li></ul><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>不可变，线程安全</li><li>链式操作，易组合</li><li>支持各种历法和时区计算</li></ul><hr><h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>容器对象，防止 <code>NullPointerException</code>。</li><li>可以包含值或为空（empty）。</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt1 = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(opt1.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(opt2.orElse(<span class="string">&quot;Default&quot;</span>)); <span class="comment">// Default</span></span><br><span class="line">opt1.map(String::toUpperCase).ifPresent(System.out::println); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure><h3 id="底层原理-5"><a href="#底层原理-5" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部 <code>value</code> 字段存储非空值，空值使用单例 <code>EMPTY</code>。</li><li><code>map</code> &#x2F; <code>flatMap</code> &#x2F; <code>filter</code> 返回新的 Optional，对象不可变。</li><li>与 Lambda &#x2F; 函数式接口结合实现链式安全操作。</li></ul><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>避免显式 null 判断</li><li>支持链式调用</li><li>可与 Stream &#x2F; Lambda 配合</li></ul><hr><h2 id="Java-8-六大核心特性底层对比表"><a href="#Java-8-六大核心特性底层对比表" class="headerlink" title="Java 8 六大核心特性底层对比表"></a>Java 8 六大核心特性底层对比表</h2><table><thead><tr><th>特性</th><th>底层实现</th><th>核心原理</th><th>优势</th></tr></thead><tbody><tr><td>Lambda</td><td>invokedynamic + LambdaMetafactory</td><td>动态生成函数对象</td><td>简洁、性能高</td></tr><tr><td>函数式接口</td><td>单抽象方法接口</td><td>捕获变量通过闭包存储</td><td>简化匿名类，函数式编程</td></tr><tr><td>Stream API</td><td>流水线 + 延迟求值</td><td>中间操作惰性，终端触发</td><td>声明式、可并行</td></tr><tr><td>方法引用</td><td>Lambda 简化语法 + invokedynamic</td><td>内部持有方法引用</td><td>简洁直观，减少代码</td></tr><tr><td>java.time</td><td>不可变对象 + 工厂方法</td><td>final字段保存值，链式返回新对象</td><td>线程安全，可组合</td></tr><tr><td>Optional</td><td>包装对象 + 单例 EMPTY</td><td>不可变容器，函数式链式调用</td><td>避免 NPE，安全链式操作</td></tr></tbody></table><hr><h1 id="二、synchronized-底层原理深入解析"><a href="#二、synchronized-底层原理深入解析" class="headerlink" title="二、synchronized 底层原理深入解析"></a>二、synchronized 底层原理深入解析</h1><h2 id="1-JVM-锁的类型"><a href="#1-JVM-锁的类型" class="headerlink" title="1. JVM 锁的类型"></a>1. JVM 锁的类型</h2><table><thead><tr><th>锁类型</th><th>特点</th><th>性能</th></tr></thead><tbody><tr><td>偏向锁 (Biased Lock)</td><td>无竞争时偏向第一个线程，轻量</td><td>高</td></tr><tr><td>轻量级锁 (Lightweight)</td><td>竞争少时使用 CAS 升级锁</td><td>中</td></tr><tr><td>重量级锁 (Monitor)</td><td>高竞争时使用 OS mutex，阻塞线程</td><td>低</td></tr></tbody></table><hr><h2 id="2-synchronized-对象头结构"><a href="#2-synchronized-对象头结构" class="headerlink" title="2. synchronized 对象头结构"></a>2. synchronized 对象头结构</h2><ul><li>每个对象在 JVM 内存中都有 <strong>对象头（Mark Word）</strong>，存储锁信息、哈希码、GC 标记等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象头 Mark Word (32/64bit)</span><br><span class="line">+----------------+----------------+----------------+</span><br><span class="line">| HashCode       | GC info        | Lock info      |</span><br><span class="line">+----------------+----------------+----------------+</span><br></pre></td></tr></table></figure><ul><li><strong>锁标记位</strong>：<ul><li>00：无锁</li><li>01：偏向锁</li><li>10：轻量级锁</li><li>11：重量级锁</li></ul></li></ul><hr><h2 id="3-synchronized-执行流程"><a href="#3-synchronized-执行流程" class="headerlink" title="3. synchronized 执行流程"></a>3. synchronized 执行流程</h2><h3 id="a-偏向锁（无竞争）"><a href="#a-偏向锁（无竞争）" class="headerlink" title="a) 偏向锁（无竞争）"></a>a) 偏向锁（无竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁 -&gt; 在对象头打上线程ID -&gt; 执行 -&gt; 释放锁 -&gt; 保持偏向状态</span><br></pre></td></tr></table></figure><h3 id="b-轻量级锁（CAS竞争）"><a href="#b-轻量级锁（CAS竞争）" class="headerlink" title="b) 轻量级锁（CAS竞争）"></a>b) 轻量级锁（CAS竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程尝试CAS抢锁 -&gt; 成功：持有锁 -&gt; 执行 -&gt; 释放</span><br><span class="line">                      |-&gt; 失败：升级为重量级锁</span><br></pre></td></tr></table></figure><h3 id="c-重量级锁（阻塞）"><a href="#c-重量级锁（阻塞）" class="headerlink" title="c) 重量级锁（阻塞）"></a>c) 重量级锁（阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程无法获取锁 -&gt; 阻塞（OS等待队列） -&gt; 被唤醒 -&gt; 获取锁 -&gt; 执行 -&gt; 释放锁</span><br></pre></td></tr></table></figure><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  synchronized()  |</span><br><span class="line">+------------------+</span><br><span class="line">          |</span><br><span class="line">    JVM对象头Mark Word</span><br><span class="line">          |</span><br><span class="line">+------------------------+</span><br><span class="line">| 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><hr><h2 id="4-synchronized-方法示例"><a href="#4-synchronized-方法示例" class="headerlink" title="4. synchronized 方法示例"></a>4. synchronized 方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>锁对象</strong>：实例方法锁住 <code>this</code>，静态方法锁住类对象 <code>ClassName.class</code>。</li><li><strong>效果</strong>：同一时间只有一个线程能进入 <code>increment()</code>，保证 <code>count++</code> 操作的原子性。</li></ul><hr><h2 id="5-JVM-优化"><a href="#5-JVM-优化" class="headerlink" title="5. JVM 优化"></a>5. JVM 优化</h2><ul><li><strong>锁消除</strong>：编译器或 JIT 可检测无竞争情况，消除同步锁。</li><li><strong>锁粗化</strong>：把多次连续的小范围锁合并，减少加锁次数。</li><li><strong>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁升级</strong>：动态适应竞争情况，兼顾性能与正确性。</li></ul><h2 id="25-多态的实现机制是什么？"><a href="#25-多态的实现机制是什么？" class="headerlink" title="25.多态的实现机制是什么？"></a>25.多态的实现机制是什么？</h2><ul><li><strong>概念</strong>：同一操作作用于不同对象时表现出不同的行为（主要表现为方法的动态绑定）。</li><li><strong>实现机制</strong>：<ul><li><strong>编译时</strong>：根据引用类型检查方法签名（静态类型检查）。</li><li><strong>运行时</strong>：实际调用的方法根据对象的实际类型（运行时类型）决定；即 <strong>动态绑定（dynamic dispatch）</strong>。</li><li>JVM 通常通过 <strong>虚方法表（vtable）&#x2F;方法查找机制</strong> 实现。调用一个非 <code>static</code>、非 <code>private</code>、非 <code>final</code> 的方法时，会在运行时查找实际类的实现并调用。</li></ul></li><li><strong>结果</strong>：子类可以覆盖父类方法，调用者使用父类引用指向子类对象时，调用的是子类的覆盖方法（运行时决定）。</li><li><strong>注意</strong>：<code>static</code>、<code>private</code>、<code>final</code> 方法不会被动态绑定（是静态绑定）。</li></ul><hr><h2 id="26-方法重载（overload）和方法重写（override）的区别？"><a href="#26-方法重载（overload）和方法重写（override）的区别？" class="headerlink" title="26. 方法重载（overload）和方法重写（override）的区别？"></a>26. 方法重载（overload）和方法重写（override）的区别？</h2><ul><li><p><strong>方法重载（Overloading）</strong>：</p><ul><li>同一类中方法名相同、参数列表不同（参数类型&#x2F;个数&#x2F;顺序），返回类型可以不同。</li><li>编译时决定（重载解析在编译期完成），与继承关系无关。</li></ul></li><li><p><strong>方法重写（Overriding）</strong>：</p><ul><li>子类定义与父类相同方法签名（方法名 + 参数类型相同）的实现，目的是改变&#x2F;扩展父类行为。</li><li>运行时动态绑定，必须满足访问权限不能更严格，抛出的受检异常不能超过父类版本等规则。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="meta">@Override</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="27-Java-支持多继承吗？如何实现类似效果？"><a href="#27-Java-支持多继承吗？如何实现类似效果？" class="headerlink" title="27. Java 支持多继承吗？如何实现类似效果？"></a>27. Java 支持多继承吗？如何实现类似效果？</h2><ul><li><strong>类的多继承</strong>：Java <strong>不支持类的多继承</strong>（不能继承多个类），以避免菱形继承问题（diamond problem）。</li><li><strong>实现类似效果的方法</strong>：<ul><li><strong>接口多实现</strong>：一个类可以实现多个接口（Java 8 的 <code>default</code> 方法也带来类似多继承方法实现的可能，但有冲突解决规则）。</li><li><strong>组合&#x2F;委托（composition&#x2F;delegation）</strong>：在类中持有其它类的实例并把调用委托给它们（优于继承的面向对象设计原则）。</li></ul></li><li><strong>接口冲突解决</strong>：若多个接口提供相同默认方法，类必须重写该方法并明确调用哪个接口的默认实现（<code>InterfaceName.super.method()</code>）。</li></ul><hr><h2 id="28-Java-的四种访问修饰符？"><a href="#28-Java-的四种访问修饰符？" class="headerlink" title="28. Java 的四种访问修饰符？"></a>28. Java 的四种访问修饰符？</h2><ul><li><code>public</code>：对所有类可见（任何包）。</li><li><code>protected</code>：对同包类和子类可见（即同包或子类可以访问）。</li><li><strong>默认（包私有，package-private）</strong>（不写修饰符）：对同包类可见，包外不可见。</li><li><code>private</code>：仅在本类内可见，包外&#x2F;子类不可访问（子类无法直接访问父类 private 成员）。</li><li><strong>注意</strong>：对类（顶层类）只能使用 <code>public</code> 或默认（包私有），不能声明为 <code>private</code>&#x2F;<code>protected</code>。</li></ul><hr><h2 id="29-transient-关键字的作用？"><a href="#29-transient-关键字的作用？" class="headerlink" title="29. transient 关键字的作用？"></a>29. <code>transient</code> 关键字的作用？</h2><ul><li>用于标记字段在 Java 序列化（<code>Serializable</code>）过程中<strong>不被序列化</strong>。</li><li>被标记为 <code>transient</code> 的字段在序列化后不会写入序列化流，反序列化时这些字段会以默认值恢复（基本类型 0，引用类型 <code>null</code>）。</li><li>常用于敏感信息（密码）、不需要持久化的缓存字段、或可重建的状态字段。</li><li>注意：<code>static</code> 字段本身也不会被序列化（因为是类级别，不属于实例状态）。</li></ul><hr><h2 id="30-volatile-关键字的作用？"><a href="#30-volatile-关键字的作用？" class="headerlink" title="30. volatile 关键字的作用？"></a>30. <code>volatile</code> 关键字的作用？</h2><ul><li><strong>可见性</strong>：保证对 <code>volatile</code> 变量的写入对其它线程立即可见（读取总是从主内存而不是线程缓存读取）。</li><li><strong>禁止指令重排序（部分）</strong>：读&#x2F;写 <code>volatile</code> 存在的内存屏障能保证一定的有序性（写 <code>volatile</code> 发生在后续读的可见性上，更多细节参考 JMM）。</li><li><strong>不保证原子性</strong>：对单次读&#x2F;写操作是原子的（对 <code>long</code>&#x2F;<code>double</code> 在 Java 5 后也保证原子），但非原子操作（如 <code>i++</code>）不是原子的。</li><li><strong>典型用途</strong>：<ul><li>状态标志（如 <code>volatile boolean running</code>）。</li><li>用于实现双重检查锁定（DCL）单例中的 <code>instance</code>（在 Java 5+ 环境下有效）。</li></ul></li><li><strong>与 synchronized 比较</strong>：<ul><li><code>volatile</code> 轻量，只保证可见性与部分有序性，不保证互斥；适用于简单状态通信。</li><li><code>synchronized</code> 提供互斥和可见性保证（更重），并可配合 <code>wait/notify</code>。</li></ul></li></ul><hr><h2 id="31-synchronized-的作用及底层原理？"><a href="#31-synchronized-的作用及底层原理？" class="headerlink" title="31. synchronized 的作用及底层原理？"></a>31. <code>synchronized</code> 的作用及底层原理？</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>互斥（排它）</strong>：保证同一时间只有一个线程可以执行被 <code>synchronized</code> 修饰的代码块或方法（针对同一把锁）。</li><li><strong>可见性</strong>：进入&#x2F;退出同步块会建立 happens-before 关系，确保锁释放前的写对随后获取该锁的线程可见。</li><li><strong>用途</strong>：保护临界区、确保多个线程对共享可变状态的安全访问。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li><strong>方法级别</strong>：<ul><li><code>synchronized void m() &#123; ... &#125;</code>：等价于 <code>synchronized(this)</code>（实例方法）或 <code>synchronized (ClassName.class)</code>（静态方法）。</li></ul></li><li><strong>代码块级别</strong>：<ul><li><code>synchronized(this) &#123; ... &#125;</code> 或 <code>synchronized(lockObj) &#123; ... &#125;</code> 更灵活，能减小锁的粒度。</li></ul></li></ul><h3 id="底层原理（HotSpot-实现概要）"><a href="#底层原理（HotSpot-实现概要）" class="headerlink" title="底层原理（HotSpot 实现概要）"></a>底层原理（HotSpot 实现概要）</h3><ul><li>JVM 使用对象头（object header）中的 <strong>mark word</strong> 和关联数据结构维护锁状态。</li><li>锁优化策略（为提升性能，HotSpot 引入若干优化）：<ol><li><strong>偏向锁（Biased Locking）</strong>：在没有竞争的情况下，锁会偏向于第一次获得它的线程，重复获取无需 CAS，减少开销。</li><li><strong>轻量级锁（Lightweight Locking）</strong>：使用 CAS 操作在栈上记录加锁记录，避免进入重量级监视器（monitor）。</li><li><strong>重量级锁（Monitor&#x2F;Mutex）</strong>：当竞争激烈或 CAS 失败时，升级为重量级锁，使用操作系统互斥量（可能涉及线程阻塞&#x2F;唤醒）。</li></ol></li><li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 是字节码指令（由编译器&#x2F;字节码生成器生成）。</li><li>JIT 编译器可进行锁消除、锁粗化、锁优化等（当能证明无并发访问或已外部同步时）。</li></ul><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify&#x2F;notifyAll"></a><code>wait/notify</code>&#x2F;<code>notifyAll</code></h3><ul><li><code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 必须在持有对象监视器（即在 <code>synchronized</code> 块内）时调用，用于线程间协作（条件等待&#x2F;通知）。</li><li><code>wait()</code> 会释放锁并进入等待队列；<code>notify()</code> 唤醒等待队列中的一个线程（被唤醒线程在重新获得锁后继续）。</li></ul><h3 id="注意与陷阱"><a href="#注意与陷阱" class="headerlink" title="注意与陷阱"></a>注意与陷阱</h3><ul><li>锁粒度：避免用过大锁（如 <code>synchronized</code> 在方法头部锁住大量操作），谨慎使用 <code>String</code> 或装箱对象作为锁（可能会导致多个实例共用同一锁或锁被外部持有）。</li><li>死锁：多线程锁顺序不当可能死锁；设计时谨防。</li><li>性能：在高并发下可考虑使用 <code>java.util.concurrent</code> 包（<code>ReentrantLock</code>、<code>ConcurrentHashMap</code>、<code>AtomicXxx</code>）等更细粒度、高性能的并发工具。</li></ul><hr><h2 id="二、面向对象编程（OOP）"><a href="#二、面向对象编程（OOP）" class="headerlink" title="二、面向对象编程（OOP）"></a>二、面向对象编程（OOP）</h2><hr><h2 id="1-面向对象的三大特性是什么？"><a href="#1-面向对象的三大特性是什么？" class="headerlink" title="1. 面向对象的三大特性是什么？"></a><strong>1. 面向对象的三大特性是什么？</strong></h2><ul><li><strong>封装（Encapsulation）</strong>：隐藏实现细节，只暴露必要接口。</li><li><strong>继承（Inheritance）</strong>：子类复用父类属性和方法，扩展功能。</li><li><strong>多态（Polymorphism）</strong>：同一接口，不同实现。表现为方法重写、方法重载。</li></ul><hr><h2 id="2-封装的作用是什么？"><a href="#2-封装的作用是什么？" class="headerlink" title="2. 封装的作用是什么？"></a><strong>2. 封装的作用是什么？</strong></h2><ul><li>隐藏对象内部实现细节，只暴露必要接口。</li><li>提高代码复用性、安全性，避免数据被随意修改。</li><li>例如：类的成员变量用 <code>private</code>，提供 <code>getter/setter</code> 访问。</li></ul><hr><h2 id="3-多态的优点是什么？"><a href="#3-多态的优点是什么？" class="headerlink" title="3. 多态的优点是什么？"></a><strong>3. 多态的优点是什么？</strong></h2><ul><li><strong>接口统一</strong>：不同实现类可通过父类&#x2F;接口操作。</li><li><strong>可扩展性强</strong>：新增子类不影响原有代码。</li><li><strong>解耦</strong>：调用方只依赖抽象，而不依赖具体实现。</li><li>例：<code>List list = new ArrayList();</code>，后续可换成 <code>LinkedList</code>。</li></ul><hr><h2 id="4-重写方法时返回值能否不同？"><a href="#4-重写方法时返回值能否不同？" class="headerlink" title="4. 重写方法时返回值能否不同？"></a><strong>4. 重写方法时返回值能否不同？</strong></h2><ul><li><strong>不能完全不同</strong>。</li><li>Java 允许 <strong>协变返回类型</strong>：子类方法的返回值类型可以是父类方法返回值的子类。</li><li>例如：父类返回 <code>Number</code>，子类可以返回 <code>Integer</code>。</li></ul><hr><h2 id="5-构造函数能否被继承？"><a href="#5-构造函数能否被继承？" class="headerlink" title="5. 构造函数能否被继承？"></a><strong>5. 构造函数能否被继承？</strong></h2><ul><li><strong>不能继承</strong>，因为构造函数名必须与类名相同。</li><li>但子类可通过 <code>super(...)</code> 调用父类构造方法。</li></ul><hr><h2 id="6-构造函数能否-private？"><a href="#6-构造函数能否-private？" class="headerlink" title="6. 构造函数能否 private？"></a><strong>6. 构造函数能否 private？</strong></h2><ul><li><strong>可以</strong>，常见于单例模式（饿汉&#x2F;懒汉&#x2F;枚举单例）。</li><li>作用：禁止外部 <code>new</code>，只能通过类提供的方法获取实例。</li></ul><hr><h2 id="7-单例模式的几种实现方式？"><a href="#7-单例模式的几种实现方式？" class="headerlink" title="7. 单例模式的几种实现方式？"></a><strong>7. 单例模式的几种实现方式？</strong></h2><ol><li>饿汉式（类加载即实例化，线程安全，但可能浪费内存）。</li><li>懒汉式（延迟加载，需加 <code>synchronized</code> 保证线程安全）。</li><li>双重检查锁（DCL，volatile + synchronized，性能优）。</li><li>静态内部类（推荐，利用类加载机制，线程安全）。</li><li>枚举单例（最佳实践，防止反射和反序列化攻击）。</li></ol><hr><h2 id="8-饿汉式和懒汉式单例的区别？"><a href="#8-饿汉式和懒汉式单例的区别？" class="headerlink" title="8. 饿汉式和懒汉式单例的区别？"></a><strong>8. 饿汉式和懒汉式单例的区别？</strong></h2><ul><li><strong>饿汉式</strong>：类加载时实例化 → 线程安全，启动时可能浪费内存。</li><li><strong>懒汉式</strong>：第一次使用时才实例化 → 节省资源，但需加锁保证线程安全。</li></ul><hr><h2 id="9-为什么要使用内部类？"><a href="#9-为什么要使用内部类？" class="headerlink" title="9. 为什么要使用内部类？"></a><strong>9. 为什么要使用内部类？</strong></h2><ul><li>内部类可以 <strong>访问外部类的私有成员</strong>。</li><li>更好地组织代码，使逻辑更紧密。</li><li>在需要回调或事件监听时常用。</li></ul><hr><h2 id="10-成员内部类、局部内部类、静态内部类的区别？"><a href="#10-成员内部类、局部内部类、静态内部类的区别？" class="headerlink" title="10. 成员内部类、局部内部类、静态内部类的区别？"></a><strong>10. 成员内部类、局部内部类、静态内部类的区别？</strong></h2><ul><li><strong>成员内部类</strong>：依附于外部类实例，可以访问外部类实例变量。</li><li><strong>局部内部类</strong>：定义在方法内部，作用范围仅在方法内。</li><li><strong>静态内部类</strong>：不依赖外部类实例，只能访问外部类静态成员。</li></ul><hr><h2 id="11-Java-中对象的创建方式有哪些？"><a href="#11-Java-中对象的创建方式有哪些？" class="headerlink" title="11. Java 中对象的创建方式有哪些？"></a><strong>11. Java 中对象的创建方式有哪些？</strong></h2><ol><li><code>new</code> 关键字。</li><li>反射 <code>Class.newInstance()</code>。</li><li><code>Constructor.newInstance()</code>。</li><li>通过 <code>clone()</code>。</li><li>通过反序列化 <code>ObjectInputStream.readObject()</code>。</li></ol><hr><h2 id="12-对象之间的浅拷贝和深拷贝的区别？"><a href="#12-对象之间的浅拷贝和深拷贝的区别？" class="headerlink" title="12. 对象之间的浅拷贝和深拷贝的区别？"></a><strong>12. 对象之间的浅拷贝和深拷贝的区别？</strong></h2><ul><li><strong>浅拷贝</strong>：只复制对象本身，引用字段仍指向同一对象。</li><li><strong>深拷贝</strong>：连引用对象也复制一份，完全独立。</li></ul><hr><h2 id="13-clone-方法的原理？"><a href="#13-clone-方法的原理？" class="headerlink" title="13. clone() 方法的原理？"></a><strong>13. clone() 方法的原理？</strong></h2><ul><li>来自 <code>Object</code> 类，默认是 <strong>浅拷贝</strong>。</li><li>必须实现 <code>Cloneable</code> 接口，否则抛出 <code>CloneNotSupportedException</code>。</li><li>可重写 <code>clone()</code> 实现深拷贝。</li></ul><hr><h2 id="14-为什么-Java-不支持多继承？"><a href="#14-为什么-Java-不支持多继承？" class="headerlink" title="14. 为什么 Java 不支持多继承？"></a><strong>14. 为什么 Java 不支持多继承？</strong></h2><ul><li>为了避免 <strong>菱形继承问题</strong>（多个父类方法冲突）。</li><li>Java 使用 <strong>接口</strong> 来实现多继承特性。</li></ul><hr><h2 id="15-Java-是值传递还是引用传递？"><a href="#15-Java-是值传递还是引用传递？" class="headerlink" title="15. Java 是值传递还是引用传递？"></a><strong>15. Java 是值传递还是引用传递？</strong></h2><ul><li>Java <strong>只有值传递</strong>。</li><li>对象参数传递的是 <strong>引用的副本</strong>（值），但指向同一对象。</li></ul><hr><h2 id="16-方法参数传递时是如何处理对象的？"><a href="#16-方法参数传递时是如何处理对象的？" class="headerlink" title="16. 方法参数传递时是如何处理对象的？"></a><strong>16. 方法参数传递时是如何处理对象的？</strong></h2><ul><li>方法内修改对象的字段 → 会影响外部对象。</li><li>方法内给引用变量重新赋值 → 不会影响外部对象。</li></ul><hr><h2 id="17-封装性体现在哪些方面？"><a href="#17-封装性体现在哪些方面？" class="headerlink" title="17. 封装性体现在哪些方面？"></a><strong>17. 封装性体现在哪些方面？</strong></h2><ul><li>使用 <code>private</code> 修饰成员变量。</li><li>提供 <code>getter/setter</code> 控制访问权限。</li><li>使用访问修饰符（public&#x2F;protected&#x2F;default&#x2F;private）控制类和方法的可见性。</li></ul><hr><h2 id="18-为什么需要继承？"><a href="#18-为什么需要继承？" class="headerlink" title="18. 为什么需要继承？"></a><strong>18. 为什么需要继承？</strong></h2><ul><li>代码复用（减少重复）。</li><li>提高扩展性（子类扩展父类功能）。</li><li>实现多态，解耦业务逻辑。</li></ul><hr><h2 id="19-重写-Object-类的-toString-方法的意义？"><a href="#19-重写-Object-类的-toString-方法的意义？" class="headerlink" title="19. 重写 Object 类的 toString 方法的意义？"></a><strong>19. 重写 Object 类的 toString 方法的意义？</strong></h2><ul><li>提高可读性，方便调试和日志记录。</li><li>默认 <code>toString()</code> 打印类名+hashcode，不直观。</li><li>重写后可打印对象核心字段信息。</li></ul><hr><h2 id="20-重写-Object-类的-equals-方法时需要注意什么？"><a href="#20-重写-Object-类的-equals-方法时需要注意什么？" class="headerlink" title="20. 重写 Object 类的 equals 方法时需要注意什么？"></a><strong>20. 重写 Object 类的 equals 方法时需要注意什么？</strong></h2><ul><li>必须满足 <strong>自反性、对称性、传递性、一致性</strong>。</li><li>与 <code>hashCode()</code> 保持一致：相等对象必须有相同的 hashCode。</li><li>避免 <code>NullPointerException</code>。</li></ul><hr><h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><hr><h3 id="1-Java-的异常体系结构？"><a href="#1-Java-的异常体系结构？" class="headerlink" title="1. Java 的异常体系结构？"></a>1. Java 的异常体系结构？</h3><ul><li><strong>顶层类</strong>：<code>Throwable</code><ul><li><strong>Error</strong>（错误，程序无法处理，通常由 JVM 抛出）<ul><li>如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li></ul></li><li><strong>Exception</strong>（异常，程序可处理）<ul><li><strong>Checked Exception</strong>（受检异常，编译期检查）<ul><li>如：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>Unchecked Exception</strong>（运行时异常，编译器不强制处理）<ul><li>如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code></li></ul></li></ul></li></ul></li></ul><p>👉 结构图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line"> ├── Error</span><br><span class="line"> └── Exception</span><br><span class="line">      ├── Checked Exception</span><br><span class="line">      └── Unchecked Exception (RuntimeException)</span><br></pre></td></tr></table></figure><hr><h3 id="2-Checked-Exception-和-Unchecked-Exception-的区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-的区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 的区别？"></a>2. Checked Exception 和 Unchecked Exception 的区别？</h3><ul><li><strong>Checked Exception（受检异常）</strong><ul><li>必须显式处理（try-catch 或 throws 声明）。</li><li>编译器强制检查，否则无法通过编译。</li><li>典型场景：IO、数据库、网络调用。</li></ul></li><li><strong>Unchecked Exception（非受检异常 &#x2F; 运行时异常）</strong><ul><li>不强制处理，编译器不检查。</li><li>通常由程序逻辑错误导致。</li><li>典型场景：NPE、除零、数组越界。</li></ul></li></ul><hr><h3 id="3-throw-和-throws-的区别？"><a href="#3-throw-和-throws-的区别？" class="headerlink" title="3. throw 和 throws 的区别？"></a>3. throw 和 throws 的区别？</h3><ul><li><strong>throw</strong><ul><li>用于方法体内部，<strong>抛出具体的异常对象</strong>。</li><li>语法：<code>throw new Exception(&quot;msg&quot;);</code></li></ul></li><li><strong>throws</strong><ul><li>用于方法声明处，<strong>标识该方法可能抛出的异常类型</strong>。</li><li>语法：<code>public void test() throws IOException &#123;&#125;</code></li></ul></li></ul><p>👉 总结：</p><ul><li><code>throw</code> &#x3D; 抛出异常实例。</li><li><code>throws</code> &#x3D; 声明可能抛出的异常类型。</li></ul><hr><h3 id="4-try-catch-finally-的执行顺序？"><a href="#4-try-catch-finally-的执行顺序？" class="headerlink" title="4. try-catch-finally 的执行顺序？"></a>4. try-catch-finally 的执行顺序？</h3><ol><li><code>try</code> 块先执行。</li><li>如果发生异常，跳到对应 <code>catch</code> 执行。</li><li><code>finally</code> <strong>一定会执行</strong>（除非 <code>System.exit()</code>）。</li><li>如果 <code>try</code> 或 <code>catch</code> 有 <code>return</code>，会先执行 <code>finally</code>，再返回结果。</li></ol><hr><h3 id="5-finally-中的-return-会覆盖-try-中的-return-吗？"><a href="#5-finally-中的-return-会覆盖-try-中的-return-吗？" class="headerlink" title="5. finally 中的 return 会覆盖 try 中的 return 吗？"></a>5. finally 中的 return 会覆盖 try 中的 return 吗？</h3><p>✅ <strong>会覆盖</strong>。</p><ul><li>如果 <code>try</code> 中有 <code>return</code>，但 <code>finally</code> 中也有 <code>return</code>，最终返回的是 <code>finally</code> 的结果。<br> 👉 因此实际开发中 <strong>不推荐在 finally 中写 return</strong>。</li></ul><hr><h3 id="6-try-with-resources-的作用？"><a href="#6-try-with-resources-的作用？" class="headerlink" title="6. try-with-resources 的作用？"></a>6. try-with-resources 的作用？</h3><ul><li>Java 7 引入，简化资源管理（如流、数据库连接）。</li><li>自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源。</li><li>避免忘记 <code>finally &#123; resource.close(); &#125;</code>。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-自定义异常类如何实现？"><a href="#7-自定义异常类如何实现？" class="headerlink" title="7. 自定义异常类如何实现？"></a>7. 自定义异常类如何实现？</h3><ul><li>继承 <code>Exception</code>（Checked）或 <code>RuntimeException</code>（Unchecked）。</li><li>提供构造方法：无参、带 message、带 cause。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-Error-和-Exception-的区别？"><a href="#8-Error-和-Exception-的区别？" class="headerlink" title="8. Error 和 Exception 的区别？"></a>8. Error 和 Exception 的区别？</h3><ul><li><strong>Error</strong>：系统级错误，JVM 无法恢复，程序不应该捕获。<ul><li>如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code>。</li></ul></li><li><strong>Exception</strong>：应用级异常，程序应该处理。<ul><li>如 <code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>。</li></ul></li></ul><hr><h3 id="9-NullPointerException-常见场景有哪些？"><a href="#9-NullPointerException-常见场景有哪些？" class="headerlink" title="9. NullPointerException 常见场景有哪些？"></a>9. NullPointerException 常见场景有哪些？</h3><ol><li>调用空对象的方法：<code>obj.toString()</code>。</li><li>访问空数组：<code>arr.length</code>。</li><li>访问空集合：<code>list.size()</code>。</li><li>自动拆箱：<code>Integer num = null; int n = num;</code>。</li><li>Map 查找为 null，再调用方法：<code>map.get(&quot;key&quot;).toString()</code>。</li><li>依赖注入&#x2F;未初始化的对象。</li></ol><hr><h3 id="10-运行时异常需要捕获吗？为什么"><a href="#10-运行时异常需要捕获吗？为什么" class="headerlink" title="10. 运行时异常需要捕获吗？为什么"></a>10. 运行时异常需要捕获吗？为什么</h3><ul><li><strong>通常不需要显式捕获</strong>，因为它们多由逻辑错误导致（如 NPE、除零）。</li><li>捕获运行时异常并不能解决问题，应该<strong>通过修改代码逻辑</strong>避免。</li><li>但在某些关键服务（如 API 层）可以用统一异常处理（如 Spring @ControllerAdvice）拦截，避免程序直接崩溃。</li></ul><hr><h2 id="四、集合框架（Collections）"><a href="#四、集合框架（Collections）" class="headerlink" title="四、集合框架（Collections）"></a>四、集合框架（Collections）</h2><hr><h3 id="1-Collection-和-Collections-的区别？"><a href="#1-Collection-和-Collections-的区别？" class="headerlink" title="1. Collection 和 Collections 的区别？"></a>1. Collection 和 Collections 的区别？</h3><ul><li><strong>Collection</strong>：集合接口，是所有集合类的父接口（List、Set）。</li><li><strong>Collections</strong>：工具类，提供操作集合的静态方法（排序、搜索、同步包装等）。</li></ul><hr><h3 id="2-List、Set、Map-的区别？"><a href="#2-List、Set、Map-的区别？" class="headerlink" title="2. List、Set、Map 的区别？"></a>2. List、Set、Map 的区别？</h3><ul><li><strong>List</strong>：有序、可重复，按索引访问（ArrayList、LinkedList）。</li><li><strong>Set</strong>：无序、不可重复，基于哈希或树（HashSet、TreeSet）。</li><li><strong>Map</strong>：键值对存储，Key 不可重复，Value 可重复（HashMap、TreeMap）。</li></ul><hr><h3 id="3-ArrayList-和-LinkedList-的区别？"><a href="#3-ArrayList-和-LinkedList-的区别？" class="headerlink" title="3. ArrayList 和 LinkedList 的区别？"></a>3. ArrayList 和 LinkedList 的区别？</h3><ul><li><strong>ArrayList</strong>：基于动态数组，查询快（O(1)），增删慢（O(n)）。</li><li><strong>LinkedList</strong>：基于双向链表，增删快（O(1)），查询慢（O(n)）。</li></ul><hr><h3 id="4-HashMap-的底层实现？"><a href="#4-HashMap-的底层实现？" class="headerlink" title="4. HashMap 的底层实现？"></a>4. HashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：数组 + 链表。</li><li><strong>JDK 1.8</strong>：数组 + 链表 + 红黑树（链表长度 ≥ 8 时转为树）。</li></ul><hr><h3 id="5-HashMap-1-7-和-1-8-的区别？"><a href="#5-HashMap-1-7-和-1-8-的区别？" class="headerlink" title="5. HashMap 1.7 和 1.8 的区别？"></a>5. HashMap 1.7 和 1.8 的区别？</h3><ol><li>1.7：数组 + 链表，采用头插法，易出现并发死循环。</li><li>1.8：数组 + 链表&#x2F;红黑树，尾插法，避免死循环，提高性能。</li><li>1.8 引入红黑树，查找效率从 O(n) 优化为 O(log n)。</li></ol><hr><h3 id="6-HashMap-如何解决哈希冲突？"><a href="#6-HashMap-如何解决哈希冲突？" class="headerlink" title="6. HashMap 如何解决哈希冲突？"></a>6. HashMap 如何解决哈希冲突？</h3><ul><li>方法：拉链法（链表）+ 红黑树。</li><li>冲突时，将元素挂到链表&#x2F;树上。</li></ul><hr><h3 id="7-HashSet-的底层实现？"><a href="#7-HashSet-的底层实现？" class="headerlink" title="7. HashSet 的底层实现？"></a>7. HashSet 的底层实现？</h3><ul><li>基于 <strong>HashMap</strong> 实现。</li><li><code>HashSet</code> 的元素存储在 <code>HashMap</code> 的 key 上，value 为一个固定对象 <code>PRESENT</code>。</li></ul><hr><h3 id="8-ConcurrentHashMap-的底层实现？"><a href="#8-ConcurrentHashMap-的底层实现？" class="headerlink" title="8. ConcurrentHashMap 的底层实现？"></a>8. ConcurrentHashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：分段锁（Segment + HashEntry）。</li><li><strong>JDK 1.8</strong>：CAS + synchronized，数据结构与 HashMap 类似，数组 + 链表 + 红黑树。</li></ul><hr><h3 id="9-Hashtable-和-HashMap-的区别？"><a href="#9-Hashtable-和-HashMap-的区别？" class="headerlink" title="9. Hashtable 和 HashMap 的区别？"></a>9. Hashtable 和 HashMap 的区别？</h3><ul><li><strong>线程安全性</strong>：Hashtable 是同步的，HashMap 不是。</li><li><strong>null</strong>：Hashtable 不允许 key、value 为 null；HashMap 允许一个 null key 和多个 null value。</li><li><strong>效率</strong>：HashMap 更高效。</li></ul><hr><h3 id="10-TreeMap-和-HashMap-的区别？"><a href="#10-TreeMap-和-HashMap-的区别？" class="headerlink" title="10. TreeMap 和 HashMap 的区别？"></a>10. TreeMap 和 HashMap 的区别？</h3><ul><li><strong>TreeMap</strong>：基于红黑树，有序（按 Key 排序）。</li><li><strong>HashMap</strong>：基于哈希表，无序。</li></ul><hr><h3 id="11-WeakHashMap-的特点？"><a href="#11-WeakHashMap-的特点？" class="headerlink" title="11. WeakHashMap 的特点？"></a>11. WeakHashMap 的特点？</h3><ul><li>Key 使用 <strong>弱引用</strong>，当没有强引用指向该 Key 时，会被 GC 回收。</li><li>常用于缓存。</li></ul><hr><h3 id="12-CopyOnWriteArrayList-的应用场景？"><a href="#12-CopyOnWriteArrayList-的应用场景？" class="headerlink" title="12. CopyOnWriteArrayList 的应用场景？"></a>12. CopyOnWriteArrayList 的应用场景？</h3><ul><li>写时复制：写操作时复制新数组，读操作不加锁。</li><li>适用于 <strong>读多写少</strong> 的并发场景，比如缓存、订阅列表。</li></ul><hr><h3 id="13-LinkedHashMap-的底层原理？"><a href="#13-LinkedHashMap-的底层原理？" class="headerlink" title="13. LinkedHashMap 的底层原理？"></a>13. LinkedHashMap 的底层原理？</h3><ul><li>基于 HashMap + 双向链表。</li><li>保证插入顺序（或 LRU 顺序）。</li></ul><hr><h3 id="14-Map-的-key-是否可以为-null？"><a href="#14-Map-的-key-是否可以为-null？" class="headerlink" title="14. Map 的 key 是否可以为 null？"></a>14. Map 的 key 是否可以为 null？</h3><ul><li><strong>HashMap</strong>：允许一个 null key。</li><li><strong>Hashtable &#x2F; TreeMap</strong>：不允许 null key。</li></ul><hr><h3 id="15-ArrayList-扩容机制？"><a href="#15-ArrayList-扩容机制？" class="headerlink" title="15. ArrayList 扩容机制？"></a>15. ArrayList 扩容机制？</h3><ul><li>初始容量 10，超过容量时扩容为原来的 1.5 倍。</li><li>通过 <code>Arrays.copyOf()</code> 实现数组复制。</li></ul><hr><h3 id="16-Vector-和-ArrayList-的区别？"><a href="#16-Vector-和-ArrayList-的区别？" class="headerlink" title="16. Vector 和 ArrayList 的区别？"></a>16. Vector 和 ArrayList 的区别？</h3><ul><li><strong>Vector</strong>：线程安全（方法加 synchronized），扩容为 2 倍。</li><li><strong>ArrayList</strong>：非线程安全，扩容为 1.5 倍。</li></ul><hr><h3 id="17-PriorityQueue-的底层实现？"><a href="#17-PriorityQueue-的底层实现？" class="headerlink" title="17. PriorityQueue 的底层实现？"></a>17. PriorityQueue 的底层实现？</h3><ul><li>基于 <strong>二叉小顶堆</strong>，保证队头元素是最小值。</li><li>插入、删除操作时间复杂度 O(log n)。</li></ul><hr><h3 id="18-BlockingQueue-的几种实现类？"><a href="#18-BlockingQueue-的几种实现类？" class="headerlink" title="18. BlockingQueue 的几种实现类？"></a>18. BlockingQueue 的几种实现类？</h3><ul><li><strong>ArrayBlockingQueue</strong>：数组结构，有界。</li><li><strong>LinkedBlockingQueue</strong>：链表结构，可选容量。</li><li><strong>PriorityBlockingQueue</strong>：优先级队列。</li><li><strong>DelayQueue</strong>：延时队列。</li><li><strong>SynchronousQueue</strong>：不存储元素，直接移交。</li></ul><hr><h3 id="19-HashMap-死循环问题出现在哪个版本？"><a href="#19-HashMap-死循环问题出现在哪个版本？" class="headerlink" title="19. HashMap 死循环问题出现在哪个版本？"></a>19. HashMap 死循环问题出现在哪个版本？</h3><ul><li><strong>JDK 1.7</strong> 多线程扩容时，链表采用头插法，可能形成环，导致死循环。</li><li><strong>JDK 1.8</strong> 使用尾插法，解决该问题。</li></ul><hr><h3 id="20-fail-fast-和-fail-safe-的区别？"><a href="#20-fail-fast-和-fail-safe-的区别？" class="headerlink" title="20. fail-fast 和 fail-safe 的区别？"></a>20. fail-fast 和 fail-safe 的区别？</h3><ul><li><strong>fail-fast</strong>：迭代过程中结构被修改，会抛出 <code>ConcurrentModificationException</code>。如：ArrayList、HashMap。</li><li><strong>fail-safe</strong>：迭代基于副本，不会抛异常。如：CopyOnWriteArrayList、ConcurrentHashMap。</li></ul><hr><h2 id="五、并发编程（JUC）"><a href="#五、并发编程（JUC）" class="headerlink" title="五、并发编程（JUC）"></a>五、并发编程（JUC）</h2><hr><h3 id="1-Java-中的线程生命周期？"><a href="#1-Java-中的线程生命周期？" class="headerlink" title="1. Java 中的线程生命周期？"></a>1. Java 中的线程生命周期？</h3><ul><li><strong>NEW（新建）</strong>：<code>new Thread()</code> 后，还没调用 <code>start()</code>。</li><li><strong>RUNNABLE（就绪&#x2F;运行中）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li><li><strong>BLOCKED（阻塞）</strong>：等待锁。</li><li><strong>WAITING（无限等待）</strong>：调用 <code>wait()</code>、<code>join()</code>，需其他线程唤醒。</li><li><strong>TIMED_WAITING（限时等待）</strong>：调用 <code>sleep()</code>、<code>wait(timeout)</code>。</li><li><strong>TERMINATED（终止）</strong>：线程执行完毕或异常退出。</li></ul><hr><h3 id="2-Runnable-和-Callable-的区别？"><a href="#2-Runnable-和-Callable-的区别？" class="headerlink" title="2. Runnable 和 Callable 的区别？"></a>2. Runnable 和 Callable 的区别？</h3><ul><li><strong>Runnable</strong>：无返回值，不能抛出受检异常。</li><li><strong>Callable</strong>：有返回值（Future 获取），可抛出异常。</li></ul><hr><h3 id="3-ThreadPoolExecutor-的参数有哪些？"><a href="#3-ThreadPoolExecutor-的参数有哪些？" class="headerlink" title="3. ThreadPoolExecutor 的参数有哪些？"></a>3. ThreadPoolExecutor 的参数有哪些？</h3><ul><li><strong>corePoolSize</strong>：核心线程数。</li><li><strong>maximumPoolSize</strong>：最大线程数。</li><li><strong>keepAliveTime</strong>：非核心线程存活时间。</li><li><strong>unit</strong>：时间单位。</li><li><strong>workQueue</strong>：任务队列（BlockingQueue）。</li><li><strong>threadFactory</strong>：线程工厂（自定义线程名）。</li><li><strong>handler</strong>：拒绝策略。</li></ul><hr><h3 id="4-线程池的拒绝策略有哪些？"><a href="#4-线程池的拒绝策略有哪些？" class="headerlink" title="4. 线程池的拒绝策略有哪些？"></a>4. 线程池的拒绝策略有哪些？</h3><ul><li><strong>AbortPolicy</strong>（默认）：抛 <code>RejectedExecutionException</code>。</li><li><strong>CallerRunsPolicy</strong>：任务交给提交任务的线程执行。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列里最旧的任务，再尝试提交。</li></ul><hr><h3 id="5-创建线程的四种方式？"><a href="#5-创建线程的四种方式？" class="headerlink" title="5. 创建线程的四种方式？"></a>5. 创建线程的四种方式？</h3><ol><li>继承 Thread 类。</li><li>实现 Runnable 接口。</li><li>实现 Callable + FutureTask。</li><li>使用线程池（ExecutorService）。</li></ol><hr><h3 id="6-synchronized-的底层实现原理？"><a href="#6-synchronized-的底层实现原理？" class="headerlink" title="6. synchronized 的底层实现原理？"></a>6. synchronized 的底层实现原理？</h3><ul><li>基于 <strong>对象头 (Mark Word)</strong> 和 <strong>Monitor（管程）</strong>。</li><li>进入同步块时，尝试获取对象的 Monitor，获取不到则阻塞。</li><li>底层依赖 <strong>JVM 指令</strong>：<code>monitorenter</code>、<code>monitorexit</code>。</li></ul><hr><h3 id="7-synchronized-和-ReentrantLock-的区别？"><a href="#7-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别？"></a>7. synchronized 和 ReentrantLock 的区别？</h3><ul><li><strong>锁类型</strong>：synchronized 是 JVM 级别，ReentrantLock 是 JUC 提供的 API。</li><li><strong>功能</strong>：ReentrantLock 支持公平锁&#x2F;非公平锁、可中断、尝试加锁、条件变量。</li><li><strong>可重入性</strong>：两者都可重入。</li><li><strong>性能</strong>：synchronized 在 JDK1.6 之后优化（偏向锁、轻量级锁）性能已提升。</li></ul><hr><h3 id="8-公平锁和非公平锁的区别？"><a href="#8-公平锁和非公平锁的区别？" class="headerlink" title="8. 公平锁和非公平锁的区别？"></a>8. 公平锁和非公平锁的区别？</h3><ul><li><strong>公平锁</strong>：按照等待顺序获取锁。</li><li><strong>非公平锁</strong>：允许“插队”，减少上下文切换，提高吞吐量。</li><li>ReentrantLock 默认非公平。</li></ul><hr><h3 id="9-AQS-的原理？"><a href="#9-AQS-的原理？" class="headerlink" title="9. AQS 的原理？"></a>9. AQS 的原理？</h3><ul><li><strong>AQS（AbstractQueuedSynchronizer）</strong> 是构建锁和同步器的框架。</li><li>内部维护一个 <strong>state</strong>（表示资源数量）和 <strong>FIFO 双向队列</strong>。</li><li>通过 CAS 修改 state，失败则将线程加入等待队列，挂起阻塞，等资源释放再唤醒。</li></ul><hr><h3 id="10-CountDownLatch-的应用场景？"><a href="#10-CountDownLatch-的应用场景？" class="headerlink" title="10. CountDownLatch 的应用场景？"></a>10. CountDownLatch 的应用场景？</h3><ul><li>倒计数器：一个线程等待多个线程完成后再执行。</li><li>例子：主线程等待多个子任务执行完毕。</li></ul><hr><h3 id="11-CyclicBarrier-的应用场景？"><a href="#11-CyclicBarrier-的应用场景？" class="headerlink" title="11. CyclicBarrier 的应用场景？"></a>11. CyclicBarrier 的应用场景？</h3><ul><li>栅栏：一组线程互相等待，直到所有线程到达屏障点再继续。</li><li>例子：多人游戏，所有玩家都准备好再开始。</li></ul><hr><h3 id="12-Semaphore-的应用场景？"><a href="#12-Semaphore-的应用场景？" class="headerlink" title="12. Semaphore 的应用场景？"></a>12. Semaphore 的应用场景？</h3><ul><li>信号量：控制并发访问的线程数量。</li><li>例子：停车场限制车位数、数据库连接池。</li></ul><hr><h3 id="13-Exchanger-的应用场景？"><a href="#13-Exchanger-的应用场景？" class="headerlink" title="13. Exchanger 的应用场景？"></a>13. Exchanger 的应用场景？</h3><ul><li>线程间数据交换：两个线程配对交换数据。</li><li>例子：生产者和消费者交换缓冲区。</li></ul><hr><h3 id="14-volatile-能保证原子性吗？"><a href="#14-volatile-能保证原子性吗？" class="headerlink" title="14. volatile 能保证原子性吗？"></a>14. volatile 能保证原子性吗？</h3><ul><li><strong>不能</strong>，只能保证可见性和禁止指令重排。</li><li>例子：<code>count++</code> 在多线程下仍然不安全。</li></ul><hr><h3 id="15-CAS-的原理？"><a href="#15-CAS-的原理？" class="headerlink" title="15. CAS 的原理？"></a>15. CAS 的原理？</h3><ul><li>Compare And Swap：比较内存值是否为预期值，如果是则更新，否则重试。</li><li>底层依赖 CPU 的 <strong>cmpxchg</strong> 指令，保证原子性。</li></ul><hr><h3 id="16-ABA-问题是什么？怎么解决？"><a href="#16-ABA-问题是什么？怎么解决？" class="headerlink" title="16. ABA 问题是什么？怎么解决？"></a>16. ABA 问题是什么？怎么解决？</h3><ul><li><strong>问题</strong>：CAS 只比较值，无法感知值被改过。例如 A→B→A。</li><li><strong>解决</strong>：使用 <strong>版本号&#x2F;时间戳</strong>（AtomicStampedReference、AtomicMarkableReference）。</li></ul><hr><h3 id="17-ThreadLocal-的作用及原理？"><a href="#17-ThreadLocal-的作用及原理？" class="headerlink" title="17. ThreadLocal 的作用及原理？"></a>17. ThreadLocal 的作用及原理？</h3><ul><li><strong>作用</strong>：为每个线程提供独立变量副本，避免共享数据冲突。</li><li><strong>原理</strong>：Thread 内部有个 ThreadLocalMap，以 ThreadLocal 为 key 存储变量。</li></ul><hr><h3 id="18-ThreadLocal-内存泄漏的原因？"><a href="#18-ThreadLocal-内存泄漏的原因？" class="headerlink" title="18. ThreadLocal 内存泄漏的原因？"></a>18. ThreadLocal 内存泄漏的原因？</h3><ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong>，可能被回收，value 却还存在，导致泄漏。</li><li>解决：用完及时 <code>remove()</code>。</li></ul><hr><h3 id="19-JUC-中的原子类有哪些？"><a href="#19-JUC-中的原子类有哪些？" class="headerlink" title="19. JUC 中的原子类有哪些？"></a>19. JUC 中的原子类有哪些？</h3><ul><li><strong>基本类型原子类</strong>：AtomicInteger、AtomicLong、AtomicBoolean。</li><li><strong>引用类型原子类</strong>：AtomicReference、AtomicStampedReference。</li><li><strong>数组原子类</strong>：AtomicIntegerArray、AtomicLongArray。</li><li><strong>对象属性更新器</strong>：AtomicIntegerFieldUpdater 等。</li></ul><hr><h3 id="20-乐观锁和悲观锁的区别？"><a href="#20-乐观锁和悲观锁的区别？" class="headerlink" title="20. 乐观锁和悲观锁的区别？"></a>20. 乐观锁和悲观锁的区别？</h3><ul><li><strong>悲观锁</strong>：假设会发生冲突，先加锁再操作（synchronized、ReentrantLock）。</li><li><strong>乐观锁</strong>：假设不会冲突，先操作再检查（CAS）。</li></ul><hr><h2 id="六、JVM-内存模型"><a href="#六、JVM-内存模型" class="headerlink" title="六、JVM &amp; 内存模型"></a>六、JVM &amp; 内存模型</h2><hr><h3 id="1-JVM-内存结构？"><a href="#1-JVM-内存结构？" class="headerlink" title="1. JVM 内存结构？"></a>1. JVM 内存结构？</h3><p>JVM 运行时主要分为：</p><ul><li><strong>堆（Heap）</strong>：存放对象实例，垃圾回收的主要区域。</li><li><strong>虚拟机栈（Stack）</strong>：存放方法调用的局部变量、操作数栈、动态链接、返回地址。</li><li><strong>本地方法栈（Native Method Stack）</strong>：为 native 方法服务。</li><li><strong>程序计数器（PC Register）</strong>：记录线程当前执行的字节码位置。</li><li><strong>方法区（Method Area &#x2F; Metaspace）</strong>：存放类元数据、常量池、静态变量、JIT 编译后的代码。</li></ul><hr><h3 id="2-堆和栈的区别？"><a href="#2-堆和栈的区别？" class="headerlink" title="2. 堆和栈的区别？"></a>2. 堆和栈的区别？</h3><ul><li><strong>堆</strong>：存放对象实例，线程共享，需垃圾回收。</li><li><strong>栈</strong>：存放方法帧、局部变量，线程私有，生命周期随线程结束。</li></ul><hr><h3 id="3-堆内存的分代模型？"><a href="#3-堆内存的分代模型？" class="headerlink" title="3. 堆内存的分代模型？"></a>3. 堆内存的分代模型？</h3><ul><li><strong>新生代（Young Generation）</strong>：Eden + Survivor（S0&#x2F;S1）。</li><li><strong>老年代（Old Generation）</strong>：存放长生命周期对象。</li><li><strong>永久代&#x2F;元空间</strong>：存放类元信息、常量池。</li></ul><hr><h3 id="4-新生代、老年代、永久代的区别？"><a href="#4-新生代、老年代、永久代的区别？" class="headerlink" title="4. 新生代、老年代、永久代的区别？"></a>4. 新生代、老年代、永久代的区别？</h3><ul><li><strong>新生代</strong>：对象新建时分配，大部分对象“朝生夕死”。</li><li><strong>老年代</strong>：存活时间长或大对象直接进入。</li><li><strong>永久代（JDK 7 及之前）</strong>：存放类信息、静态变量。</li><li><strong>元空间（JDK 8 之后）</strong>：替代永久代，使用本地内存，避免 OOM: PermGen。</li></ul><hr><h3 id="5-元空间和永久代的区别？"><a href="#5-元空间和永久代的区别？" class="headerlink" title="5. 元空间和永久代的区别？"></a>5. 元空间和永久代的区别？</h3><ul><li>永久代（PermGen）：使用 JVM 内存，容易 OOM。</li><li>元空间（Metaspace）：使用本地内存，理论上更大，更灵活。</li></ul><hr><h3 id="6-对象在堆中的分配过程？"><a href="#6-对象在堆中的分配过程？" class="headerlink" title="6. 对象在堆中的分配过程？"></a>6. 对象在堆中的分配过程？</h3><ol><li>在 Eden 区分配。</li><li>Minor GC 时，幸存的对象进入 Survivor 区。</li><li>多次 Minor GC 仍存活 → 晋升老年代。</li><li>大对象（如大数组）可能直接进入老年代。</li></ol><hr><h3 id="7-对象什么时候进入老年代？"><a href="#7-对象什么时候进入老年代？" class="headerlink" title="7. 对象什么时候进入老年代？"></a>7. 对象什么时候进入老年代？</h3><ul><li>在 Survivor 区经过多次 Minor GC，达到晋升阈值（默认 15 次）。</li><li>大对象超过阈值，直接进入老年代。</li><li>Survivor 区放不下，直接进入老年代。</li></ul><hr><h3 id="8-JVM-的垃圾回收算法？"><a href="#8-JVM-的垃圾回收算法？" class="headerlink" title="8. JVM 的垃圾回收算法？"></a>8. JVM 的垃圾回收算法？</h3><ul><li><strong>标记-清除</strong>：标记存活对象，清除未标记。缺点：碎片多。</li><li><strong>标记-整理</strong>：标记存活对象并移动，整理内存，避免碎片。</li><li><strong>复制算法</strong>：将活对象复制到新区域，清空旧区域，适合新生代。</li></ul><hr><h3 id="9-垃圾收集器有哪些？"><a href="#9-垃圾收集器有哪些？" class="headerlink" title="9. 垃圾收集器有哪些？"></a>9. 垃圾收集器有哪些？</h3><ul><li><strong>Serial</strong>（单线程，适合小内存）。</li><li><strong>ParNew</strong>（多线程版 Serial）。</li><li><strong>Parallel Scavenge（吞吐量优先）</strong>。</li><li><strong>CMS（低延迟，响应快）</strong>。</li><li><strong>G1（区域化，均衡停顿时间）</strong>。</li><li><strong>ZGC、Shenandoah（超低延迟，适合大内存场景）</strong>。</li></ul><hr><h3 id="10-CMS-和-G1-的区别？"><a href="#10-CMS-和-G1-的区别？" class="headerlink" title="10. CMS 和 G1 的区别？"></a>10. CMS 和 G1 的区别？</h3><ul><li><strong>CMS</strong>：并发收集，低延迟，但可能产生内存碎片。</li><li><strong>G1</strong>：基于分区（Region），可预测停顿时间，整理内存，适合大堆内存。</li></ul><hr><h3 id="11-Minor-GC-和-Full-GC-的区别？"><a href="#11-Minor-GC-和-Full-GC-的区别？" class="headerlink" title="11. Minor GC 和 Full GC 的区别？"></a>11. Minor GC 和 Full GC 的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，速度快，频繁。</li><li><strong>Full GC</strong>：回收整个堆（新生代 + 老年代 + 元空间），耗时长，频率低。</li></ul><hr><h3 id="12-什么是-Stop-The-World？"><a href="#12-什么是-Stop-The-World？" class="headerlink" title="12. 什么是 Stop The World？"></a>12. 什么是 Stop The World？</h3><ul><li>GC 期间，所有工作线程必须停下来等待，造成应用暂停（STW）。</li><li>STW 是不可避免的，只能尽量减少时长。</li></ul><hr><h3 id="13-JVM-常见的调优参数？"><a href="#13-JVM-常见的调优参数？" class="headerlink" title="13. JVM 常见的调优参数？"></a>13. JVM 常见的调优参数？</h3><ul><li><code>-Xms</code> 初始堆大小。</li><li><code>-Xmx</code> 最大堆大小。</li><li><code>-Xmn</code> 新生代大小。</li><li><code>-XX:SurvivorRatio</code> Eden:Survivor 比例。</li><li><code>-XX:+PrintGCDetails</code> 打印 GC 日志。</li><li><code>-XX:+UseG1GC</code> 指定垃圾收集器。</li><li><code>-XX:MaxMetaspaceSize</code> 元空间大小。</li></ul><hr><h3 id="14-类加载的双亲委派机制？"><a href="#14-类加载的双亲委派机制？" class="headerlink" title="14. 类加载的双亲委派机制？"></a>14. 类加载的双亲委派机制？</h3><ul><li><strong>过程</strong>：加载请求先交给父加载器，如果父加载器无法加载，再由子加载器加载。</li></ul><hr><h3 id="15-双亲委派的好处？"><a href="#15-双亲委派的好处？" class="headerlink" title="15. 双亲委派的好处？"></a>15. 双亲委派的好处？</h3><ul><li>避免类重复加载。</li><li>保证核心类（如 java.lang.String）不会被篡改。</li></ul><hr><h3 id="16-类加载器的种类？"><a href="#16-类加载器的种类？" class="headerlink" title="16. 类加载器的种类？"></a>16. 类加载器的种类？</h3><ul><li><strong>Bootstrap ClassLoader</strong>：加载核心类库。</li><li><strong>Extension ClassLoader</strong>：加载扩展类。</li><li><strong>Application ClassLoader</strong>：加载用户应用类。</li><li><strong>自定义 ClassLoader</strong>：用户自己扩展。</li></ul><hr><h3 id="17-OOM-的常见类型？"><a href="#17-OOM-的常见类型？" class="headerlink" title="17. OOM 的常见类型？"></a>17. OOM 的常见类型？</h3><ul><li><strong>Java heap space</strong>：堆溢出。</li><li><strong>GC overhead limit exceeded</strong>：GC 回收无效。</li><li><strong>Metaspace</strong>：元空间溢出。</li><li><strong>Direct buffer memory</strong>：直接内存溢出。</li><li><strong>Unable to create new native thread</strong>：线程数过多。</li></ul><hr><h3 id="18-内存泄漏和内存溢出的区别？"><a href="#18-内存泄漏和内存溢出的区别？" class="headerlink" title="18. 内存泄漏和内存溢出的区别？"></a>18. 内存泄漏和内存溢出的区别？</h3><ul><li><strong>内存泄漏</strong>：不再使用的对象仍然被引用，不能被 GC 回收。</li><li><strong>内存溢出</strong>：内存不足，申请不到更多空间。</li></ul><hr><h3 id="19-finalize-方法的作用？"><a href="#19-finalize-方法的作用？" class="headerlink" title="19. finalize() 方法的作用？"></a>19. finalize() 方法的作用？</h3><ul><li>对象被 GC 前执行一次清理逻辑。</li><li>缺点：执行不确定、性能差，JDK9 开始废弃，推荐使用 <strong>try-with-resources&#x2F;AutoCloseable</strong>。</li></ul><hr><h3 id="20-Java-内存模型（JMM）的核心内容？"><a href="#20-Java-内存模型（JMM）的核心内容？" class="headerlink" title="20. Java 内存模型（JMM）的核心内容？"></a>20. Java 内存模型（JMM）的核心内容？</h3><ul><li>定义了多线程如何共享内存。</li><li>关键点：<ul><li><strong>主内存</strong>：存放共享变量。</li><li><strong>工作内存</strong>：每个线程的本地副本。</li><li><strong>happens-before 规则</strong>：保证可见性、有序性。</li><li><strong>volatile、synchronized、final</strong> 提供内存语义。</li></ul></li></ul><hr><h2 id="七、泛型、注解、反射"><a href="#七、泛型、注解、反射" class="headerlink" title="七、泛型、注解、反射"></a>七、泛型、注解、反射</h2><hr><h3 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h3><ul><li><p><strong>定义</strong>：泛型（Generic）是 <strong>参数化类型</strong>，让类、接口、方法可以操作不同类型的数据，而不用编写重复代码。</p></li><li><p><strong>好处</strong>：</p><ol><li><strong>类型安全</strong>（编译期检查，避免 <code>ClassCastException</code>）。</li><li><strong>代码复用</strong>（相同逻辑可适配多种类型）。</li><li><strong>可读性高</strong>（类型明确）。</li></ol></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 编译期检查类型</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-泛型的类型擦除机制？"><a href="#2-泛型的类型擦除机制？" class="headerlink" title="2. 泛型的类型擦除机制？"></a>2. 泛型的类型擦除机制？</h3><ul><li><p><strong>原理</strong>：Java 的泛型是 <strong>伪泛型</strong>，只在 <strong>编译期有效</strong>，编译后泛型信息被擦除（Type Erasure）。</p></li><li><p><strong>结果</strong>：</p><ul><li><code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时是同一个类型：<code>List</code>。</li><li>泛型方法的类型参数会被擦除为 <strong>上界（extends）或 Object</strong>。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-泛型通配符-extends-和-super-的区别？"><a href="#3-泛型通配符-extends-和-super-的区别？" class="headerlink" title="3. 泛型通配符 ? extends 和 ? super 的区别？"></a>3. 泛型通配符 ? extends 和 ? super 的区别？</h3><ul><li><code>? extends T</code>：表示类型的 <strong>上界</strong>，接受 <code>T</code> 及其子类。<ul><li>适合 <strong>生产者（Producer）</strong>，只读，不可写。</li></ul></li><li><code>? super T</code>：表示类型的 <strong>下界</strong>，接受 <code>T</code> 及其父类。<ul><li>适合 <strong>消费者（Consumer）</strong>，可以写入 T 及其子类对象。</li></ul></li><li><strong>口诀</strong>：PECS（Producer Extends, Consumer Super）。</li></ul><hr><h3 id="4-注解的作用是什么？"><a href="#4-注解的作用是什么？" class="headerlink" title="4. 注解的作用是什么？"></a>4. 注解的作用是什么？</h3><ul><li><strong>作用</strong>：注解（Annotation）是 <strong>元数据</strong>，为代码提供说明信息。</li><li><strong>分类</strong>：<ul><li>编译期使用（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li><li>运行时使用（结合反射，驱动框架逻辑，如 <code>@Autowired</code>）。</li></ul></li><li><strong>应用场景</strong>：框架开发（Spring、Hibernate）、编译器检查、文档生成等。</li></ul><hr><h3 id="5-元注解有哪些？"><a href="#5-元注解有哪些？" class="headerlink" title="5. 元注解有哪些？"></a>5. 元注解有哪些？</h3><p>Java 提供了四个元注解（注解的注解）：</p><ol><li><code>@Target</code> —— 指定注解可用的位置（类、方法、字段、参数等）。</li><li><code>@Retention</code> —— 指定注解的生命周期（源码&#x2F;编译期&#x2F;运行时）。</li><li><code>@Documented</code> —— 是否包含在 javadoc 中。</li><li><code>@Inherited</code> —— 子类是否能继承父类的注解。</li></ol><hr><h3 id="6-自定义注解如何实现？"><a href="#6-自定义注解如何实现？" class="headerlink" title="6. 自定义注解如何实现？"></a>6. 自定义注解如何实现？</h3><ul><li><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析</strong>（反射）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">ann</span> <span class="operator">=</span> m.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(ann.value());</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-反射的作用？"><a href="#7-反射的作用？" class="headerlink" title="7. 反射的作用？"></a>7. 反射的作用？</h3><ul><li><strong>定义</strong>：反射（Reflection）允许程序在 <strong>运行时</strong> 获取类的信息，并操作其属性、方法、构造器。</li><li><strong>作用</strong>：<ul><li>框架（如 Spring、MyBatis）自动注入和配置。</li><li>动态代理。</li><li>动态加载类。</li></ul></li></ul><hr><h3 id="8-反射的性能问题？"><a href="#8-反射的性能问题？" class="headerlink" title="8. 反射的性能问题？"></a>8. 反射的性能问题？</h3><ul><li><strong>原因</strong>：<ul><li>反射调用方法比直接调用多了安全检查、方法查找，性能差 10~20 倍。</li></ul></li><li><strong>优化</strong>：<ul><li>使用 <code>setAccessible(true)</code> 关闭安全检查。</li><li>使用 <code>MethodHandle</code>（JDK7+）。</li><li>使用 <code>LambdaMetafactory</code>（JDK8+）做动态代理。</li></ul></li></ul><hr><h3 id="9-反射能否访问私有字段？"><a href="#9-反射能否访问私有字段？" class="headerlink" title="9. 反射能否访问私有字段？"></a>9. 反射能否访问私有字段？</h3><ul><li><p><strong>能</strong>，需要 <code>setAccessible(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(obj, <span class="string">&quot;newValue&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：JDK 9 模块化后，跨模块访问可能会有 <code>InaccessibleObjectException</code>。</p></li></ul><hr><h3 id="10-动态代理的两种实现方式？"><a href="#10-动态代理的两种实现方式？" class="headerlink" title="10. 动态代理的两种实现方式？"></a>10. 动态代理的两种实现方式？</h3><ol><li><strong>JDK 动态代理</strong>：基于 <code>InvocationHandler + Proxy</code>，只能代理 <strong>接口</strong>。</li><li><strong>CGLIB 动态代理</strong>：基于 ASM 字节码生成，继承目标类，能代理 <strong>类</strong>。</li></ol><hr><h3 id="11-JDK-动态代理和-CGLIB-的区别？"><a href="#11-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="11. JDK 动态代理和 CGLIB 的区别？"></a>11. JDK 动态代理和 CGLIB 的区别？</h3><ul><li><strong>JDK 动态代理</strong>：<ul><li>代理接口。</li><li>JDK 自带，无需依赖。</li><li>性能略低。</li></ul></li><li><strong>CGLIB</strong>：<ul><li>代理类（生成子类）。</li><li>不能代理 <code>final</code> 类&#x2F;方法。</li><li>性能更高（字节码生成）。</li></ul></li></ul><hr><h3 id="12-反射如何创建对象？"><a href="#12-反射如何创建对象？" class="headerlink" title="12. 反射如何创建对象？"></a>12. 反射如何创建对象？</h3><ol><li><p><strong>使用 Class 的 <code>newInstance()</code></strong>（已废弃）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Constructor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; ctor = clazz.getConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctor.newInstance(<span class="string">&quot;param&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="13-Class-forName-和-ClassLoader-loadClass-的区别？"><a href="#13-Class-forName-和-ClassLoader-loadClass-的区别？" class="headerlink" title="13. Class.forName 和 ClassLoader.loadClass 的区别？"></a>13. Class.forName 和 ClassLoader.loadClass 的区别？</h3><ul><li><strong>Class.forName</strong>：加载并 <strong>初始化</strong> 类（会执行静态代码块）。</li><li><strong>ClassLoader.loadClass</strong>：仅加载，不初始化（延迟执行 <code>&lt;clinit&gt;</code>）。</li></ul><hr><h3 id="14-注解和反射结合能实现哪些功能？"><a href="#14-注解和反射结合能实现哪些功能？" class="headerlink" title="14. 注解和反射结合能实现哪些功能？"></a>14. 注解和反射结合能实现哪些功能？</h3><ul><li>IOC &#x2F; DI（依赖注入，Spring 的 <code>@Autowired</code>）。</li><li>ORM 框架（MyBatis 的 <code>@Mapper</code>，JPA 的 <code>@Entity</code>）。</li><li>AOP（<code>@Aspect</code>）。</li><li>配置驱动开发（<code>@Configuration</code>, <code>@Value</code>）。</li></ul><hr><h3 id="15-注解处理器（APT）的作用？"><a href="#15-注解处理器（APT）的作用？" class="headerlink" title="15. 注解处理器（APT）的作用？"></a>15. 注解处理器（APT）的作用？</h3><ul><li><strong>APT（Annotation Processing Tool）</strong>：编译期扫描注解并生成代码。</li><li><strong>典型应用</strong>：<ul><li>Dagger2（依赖注入）。</li><li>ButterKnife（视图注入）。</li><li>Lombok（自动生成 getter&#x2F;setter&#x2F;toString 等）。</li></ul></li></ul><hr><h2 id="八、Java-8-新特性"><a href="#八、Java-8-新特性" class="headerlink" title="八、Java 8+ 新特性"></a>八、Java 8+ 新特性</h2><ol><li>Lambda 表达式的作用？</li><li>函数式接口有哪些？</li><li>Stream 流的常见操作？</li><li>Optional 的作用？</li><li>CompletableFuture 的作用？</li><li>Java 8 接口的默认方法和静态方法？</li><li>forEach 和传统 for 的区别？</li><li>parallelStream 的原理？</li><li>Java 9 模块化系统（Jigsaw）是什么？</li><li>Java 14 的 switch 表达式增强？</li><li>Java 16 的 record 特性？</li><li>Java 17 的 sealed class 特性？</li><li>var 关键字是什么？</li><li>ZGC 的特性？</li><li>Project Loom 的虚拟线程是什么？</li></ol><h2 id="九、IO"><a href="#九、IO" class="headerlink" title="九、IO"></a>九、IO</h2><hr><h2 id="一、Java-IO-基础与流（1–20）"><a href="#一、Java-IO-基础与流（1–20）" class="headerlink" title="一、Java IO 基础与流（1–20）"></a>一、Java IO 基础与流（1–20）</h2><hr><h3 id="1-Java-IO-的总体体系结构是什么？"><a href="#1-Java-IO-的总体体系结构是什么？" class="headerlink" title="1. Java IO 的总体体系结构是什么？"></a>1. Java IO 的总体体系结构是什么？</h3><ul><li><strong>IO 的两大基类</strong>：<ul><li>字节流：<code>InputStream</code>、<code>OutputStream</code>（处理二进制数据）。</li><li>字符流：<code>Reader</code>、<code>Writer</code>（处理文本字符）。</li></ul></li><li><strong>按功能划分</strong>：<ul><li>节点流（直接对接数据源，如 <code>FileInputStream</code>、<code>FileReader</code>）。</li><li>处理流（包装其他流，如 <code>BufferedReader</code>、<code>DataInputStream</code>）。</li></ul></li><li><strong>核心设计模式</strong>：装饰器模式（Decorator Pattern），通过层层包装增强功能。</li></ul><hr><h3 id="2-InputStream-OutputStream-的常见子类有哪些？"><a href="#2-InputStream-OutputStream-的常见子类有哪些？" class="headerlink" title="2. InputStream &#x2F; OutputStream 的常见子类有哪些？"></a>2. InputStream &#x2F; OutputStream 的常见子类有哪些？</h3><ul><li><strong>InputStream</strong>：<code>FileInputStream</code>、<code>BufferedInputStream</code>、<code>DataInputStream</code>、<code>ObjectInputStream</code>、<code>ByteArrayInputStream</code>。</li><li><strong>OutputStream</strong>：<code>FileOutputStream</code>、<code>BufferedOutputStream</code>、<code>DataOutputStream</code>、<code>ObjectOutputStream</code>、<code>ByteArrayOutputStream</code>。</li></ul><hr><h3 id="3-Reader-Writer-的常见子类有哪些？"><a href="#3-Reader-Writer-的常见子类有哪些？" class="headerlink" title="3. Reader &#x2F; Writer 的常见子类有哪些？"></a>3. Reader &#x2F; Writer 的常见子类有哪些？</h3><ul><li><strong>Reader</strong>：<code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>、<code>CharArrayReader</code>、<code>StringReader</code>。</li><li><strong>Writer</strong>：<code>FileWriter</code>、<code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>CharArrayWriter</code>、<code>StringWriter</code>。</li></ul><hr><h3 id="4-字节流与字符流的本质区别和使用场景？"><a href="#4-字节流与字符流的本质区别和使用场景？" class="headerlink" title="4. 字节流与字符流的本质区别和使用场景？"></a>4. 字节流与字符流的本质区别和使用场景？</h3><ul><li><strong>字节流</strong>（8bit）：面向二进制数据，如图片、音视频、压缩文件。</li><li><strong>字符流</strong>（16bit，基于 Unicode）：面向文本，自动处理字符编码。</li><li><strong>联系</strong>：字符流常常通过 <code>InputStreamReader/OutputStreamWriter</code> 包装字节流并指定编码。</li></ul><hr><h3 id="5-为什么要有缓冲流？"><a href="#5-为什么要有缓冲流？" class="headerlink" title="5. 为什么要有缓冲流？"></a>5. 为什么要有缓冲流？</h3><ul><li><strong>原因</strong>：文件 IO 属于系统调用，每次读写代价高。</li><li><strong>作用</strong>：减少磁盘交互次数，提高性能。</li><li><strong>例子</strong>：<code>BufferedReader.readLine()</code> 能按行读取，效率远高于 <code>FileReader.read()</code>。</li></ul><hr><h3 id="6-flush-与-close-的区别？"><a href="#6-flush-与-close-的区别？" class="headerlink" title="6. flush() 与 close() 的区别？"></a>6. flush() 与 close() 的区别？</h3><ul><li><strong>flush()</strong>：将内存缓冲区数据立刻写入目标（但不关闭流）。</li><li><strong>close()</strong>：先执行 <code>flush()</code>，然后释放底层资源。</li><li><strong>注意点</strong>：<ul><li>若忘记 <code>flush()</code>，可能导致部分数据未写入文件。</li><li><code>close()</code> 后再调用 <code>write()</code> 会抛异常。</li></ul></li></ul><hr><h3 id="7-try-with-resources-的工作原理？"><a href="#7-try-with-resources-的工作原理？" class="headerlink" title="7. try-with-resources 的工作原理？"></a>7. try-with-resources 的工作原理？</h3><ul><li><strong>语法糖</strong>：<code>try (Resource r = ...) &#123;&#125;</code>，要求资源实现 <code>AutoCloseable</code>。</li><li><strong>原理</strong>：编译器自动生成 <code>finally &#123; r.close() &#125;</code>。</li><li><strong>suppressed exceptions</strong>：如果 <code>try</code> 和 <code>close()</code> 都抛异常，关闭时的异常会被标记为 <strong>suppressed</strong>，可通过 <code>Throwable.getSuppressed()</code> 获取。</li></ul><hr><h3 id="8-装饰器模式在-Java-IO-中如何体现？"><a href="#8-装饰器模式在-Java-IO-中如何体现？" class="headerlink" title="8. 装饰器模式在 Java IO 中如何体现？"></a>8. 装饰器模式在 Java IO 中如何体现？</h3><ul><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure></li><li><p><strong>本质</strong>：每层流只关心自己的功能（缓冲、解码、行读取），通过链式组合增强能力。</p></li></ul><hr><h3 id="9-File-类的能力与限制？"><a href="#9-File-类的能力与限制？" class="headerlink" title="9. File 类的能力与限制？"></a>9. File 类的能力与限制？</h3><ul><li><strong>能做的</strong>：文件&#x2F;目录的元数据操作（路径、存在性、权限、大小、修改时间等）。</li><li><strong>不能做的</strong>：不支持读写文件内容，需结合 <code>InputStream/OutputStream</code>。</li></ul><hr><h3 id="10-RandomAccessFile-的用途？"><a href="#10-RandomAccessFile-的用途？" class="headerlink" title="10. RandomAccessFile 的用途？"></a>10. RandomAccessFile 的用途？</h3><ul><li><strong>功能</strong>：支持随机读写，内部有一个文件指针，可 <code>seek()</code> 到任意位置读写。</li><li><strong>典型场景</strong>：日志文件、数据库存储文件。</li><li><strong>并发问题</strong>：不是线程安全的，多线程写需加锁。</li></ul><hr><h3 id="11-FileInputStream-与-FileReader-的区别？"><a href="#11-FileInputStream-与-FileReader-的区别？" class="headerlink" title="11. FileInputStream 与 FileReader 的区别？"></a>11. FileInputStream 与 FileReader 的区别？</h3><ul><li><strong>FileInputStream</strong>：字节流，直接读二进制。</li><li><strong>FileReader</strong>：字符流，内部用 <code>InputStreamReader</code> 并默认使用平台编码。</li><li><strong>使用建议</strong>：<ul><li>非文本 → <code>FileInputStream</code>。</li><li>文本（需编码处理） → <code>FileReader</code>（但最好用 <code>InputStreamReader</code> 显式指定编码）。</li></ul></li></ul><hr><h3 id="12-常见文件拷贝方式性能对比"><a href="#12-常见文件拷贝方式性能对比" class="headerlink" title="12. 常见文件拷贝方式性能对比"></a>12. 常见文件拷贝方式性能对比</h3><ol><li><strong>裸 read&#x2F;write</strong>：逐字节拷贝，最慢。</li><li><strong>带缓冲</strong>：<code>BufferedInputStream/BufferedOutputStream</code>，性能提升 5~10 倍。</li><li><strong>NIO <code>FileChannel.transferTo()</code></strong>：利用零拷贝，性能最高。</li></ol><hr><h3 id="13-如何安全处理字符编码？"><a href="#13-如何安全处理字符编码？" class="headerlink" title="13. 如何安全处理字符编码？"></a>13. 如何安全处理字符编码？</h3><ul><li><p><strong>方式</strong>：使用 <code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code> 并显式指定编码。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="14-字符编码常见坑？"><a href="#14-字符编码常见坑？" class="headerlink" title="14. 字符编码常见坑？"></a>14. 字符编码常见坑？</h3><ul><li>UTF-8 vs GBK 混用：解码错误，出现乱码。</li><li>BOM（Byte Order Mark）：部分 UTF-8 文件前 3 字节 BOM 可能导致解析失败。</li><li>截断：写入时按字节截断 UTF-8 多字节字符 → 乱码。</li><li><strong>解决</strong>：统一编码（UTF-8），避免隐式编码。</li></ul><hr><h3 id="15-文件追加（append）方式？"><a href="#15-文件追加（append）方式？" class="headerlink" title="15. 文件追加（append）方式？"></a>15. 文件追加（append）方式？</h3><ul><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>原子性问题</strong>：多线程写入需加锁，否则可能交叉覆盖。</p></li></ul><hr><h3 id="16-如何判断并处理文件状态？"><a href="#16-如何判断并处理文件状态？" class="headerlink" title="16. 如何判断并处理文件状态？"></a>16. 如何判断并处理文件状态？</h3><ul><li><strong>存在性</strong>：<code>file.exists()</code>。</li><li><strong>权限</strong>：<code>file.canRead()</code>, <code>file.canWrite()</code>。</li><li><strong>占用</strong>：只能通过打开尝试，若被占用会抛异常。</li></ul><hr><h3 id="17-File-mkdirs-与-mkdir-区别？"><a href="#17-File-mkdirs-与-mkdir-区别？" class="headerlink" title="17. File.mkdirs() 与 mkdir() 区别？"></a>17. File.mkdirs() 与 mkdir() 区别？</h3><ul><li><strong>mkdir()</strong>：只创建当前目录，父目录不存在则失败。</li><li><strong>mkdirs()</strong>：会递归创建所有不存在的父目录。</li><li><strong>返回值</strong>：成功返回 <code>true</code>，否则 <code>false</code>。</li></ul><hr><h3 id="18-临时文件（createTempFile）的用途？"><a href="#18-临时文件（createTempFile）的用途？" class="headerlink" title="18. 临时文件（createTempFile）的用途？"></a>18. 临时文件（createTempFile）的用途？</h3><ul><li><strong>方法</strong>：<code>File.createTempFile(&quot;prefix&quot;, &quot;.tmp&quot;)</code>。</li><li><strong>特点</strong>：自动生成唯一文件名。</li><li><strong>删除策略</strong>：<code>file.deleteOnExit()</code> JVM 退出时删除，但依赖于正常退出。</li></ul><hr><h3 id="19-文件的读写锁与并发访问？"><a href="#19-文件的读写锁与并发访问？" class="headerlink" title="19. 文件的读写锁与并发访问？"></a>19. 文件的读写锁与并发访问？</h3><ul><li><strong>Java NIO</strong>：<code>FileChannel.lock()</code> 提供文件锁（独占锁、共享锁）。</li><li><strong>注意</strong>：文件锁是 OS 级别，跨进程生效；性能开销较大，不适合频繁操作。</li></ul><hr><h3 id="20-流关闭异常处理最佳实践"><a href="#20-流关闭异常处理最佳实践" class="headerlink" title="20. 流关闭异常处理最佳实践"></a>20. 流关闭异常处理最佳实践</h3><ul><li><strong>传统写法</strong>：try-finally 手动关闭流。</li><li><strong>推荐</strong>：try-with-resources，避免遗漏关闭。</li><li><strong>关闭异常</strong>：只 log，不影响主要业务异常处理。</li></ul><hr><h2 id="二、Java-IO-设计与模式（21–40）"><a href="#二、Java-IO-设计与模式（21–40）" class="headerlink" title="二、Java IO 设计与模式（21–40）"></a>二、Java IO 设计与模式（21–40）</h2><ol><li>InputStream&#x2F;OutputStream 的装饰器链常见组合（Buffered -&gt; GZIP -&gt; Cipher 等）。</li><li>PushbackInputStream、SequenceInputStream 的作用与应用场景。</li><li>PipedInputStream &#x2F; PipedOutputStream（管道流）的使用与线程注意点。</li><li>FilterInputStream&#x2F;FilterOutputStream 的设计与扩展。</li><li>IO 与异常处理：IOException 的常见子类与处理策略。</li><li>流复制的常见实现模板（模板方法式代码）。</li><li>NIO 引入前的 IO 局限性（可扩展性、线程模型）。</li><li>如何实现一个带超时的读操作（Socket&#x2F;Channel）？</li><li>流式处理与内存友好型处理（流式处理大文件）实践。</li><li>Base64 编解码在流中的高效集成方法。</li><li>加密&#x2F;解密流（CipherInputStream&#x2F;CipherOutputStream）如何正确关闭？</li><li>GZIPInputStream&#x2F;GZIPOutputStream 的压缩流使用注意事项。</li><li>ObjectInputStream&#x2F;ObjectOutputStream 的工作机制（类元数据、句柄表）。</li><li>如何实现跨语言的序列化兼容（JSON&#x2F;Protobuf&#x2F;Avro）？</li><li>实现自定义 InputStream 子类时需要注意什么（read 方法语义）？</li><li>设计用于日志写入的高吞吐 IO 模式（异步批量写）。</li><li>流复制时如何统计速率与进度（带进度回调）？</li><li>如何安全处理二进制文件（流边界、magic header）？</li><li>大对象&#x2F;大数组写入流时的内存优化策略（分块、流化）。</li><li>如何实现可重入&#x2F;可恢复的断点续传文件写入？</li></ol><hr><h2 id="三、文件系统、锁与操作（41–60）"><a href="#三、文件系统、锁与操作（41–60）" class="headerlink" title="三、文件系统、锁与操作（41–60）"></a>三、文件系统、锁与操作（41–60）</h2><ol><li>Java 中文件锁 FileLock 的类型（共享&#x2F;独占）及实现原理。</li><li>FileLock 的局限性（跨 JVM、跨 OS 行为差异）。</li><li>文件描述符泄露的常见原因与定位方法。</li><li>文件句柄上限（ulimit）对 Java 服务的影响与排查。</li><li>硬链接与软链接在 Java 中如何区分与操作？</li><li>MappedByteBuffer（内存映射文件）的优劣与风险（内存回收、文件锁）。</li><li>大文件分片读取与并发合并策略。</li><li>如何高效统计大日志文件中某条件的行数（分块 + 并行）？</li><li>文件系统缓存（PageCache）对读写性能的影响机制。</li><li>fsync &#x2F; FileDescriptor.sync 在持久化保障上的作用。</li><li>文件顺序写与随机写的性能差异与优化建议。</li><li>磁盘类型（SSD vs HDD）对 IO 策略的影响。</li><li>原子重命名（renameTo&#x2F;Files.move）的跨平台差异。</li><li>文件监控（WatchService）的实现限制与替代方案。</li><li>处理日志切割（rotation）时的文件句柄管理策略。</li><li>如何实现零停机部署中对文件的平滑迁移？</li><li>软删除（标记删除）与物理删除的 IO 考量。</li><li>备份&#x2F;快照策略对 IO 的影响（冷备 vs 热备）。</li><li>大文件校验（MD5&#x2F;SHA）在流式处理中的实现。</li><li>文件系统一致性问题（写入后立即读取到不同步）如何诊断。</li></ol><hr><h2 id="四、序列化与反序列化（61–75）"><a href="#四、序列化与反序列化（61–75）" class="headerlink" title="四、序列化与反序列化（61–75）"></a>四、序列化与反序列化（61–75）</h2><ol><li>Java 原生序列化（Serializable）的机制和对象写入格式。</li><li>serialVersionUID 的作用、自动生成与兼容性策略。</li><li>transient 字段、static 字段在序列化中的处理。</li><li>Externalizable 与 Serializable 的区别与使用场景。</li><li>Java 序列化的安全风险（反序列化漏洞）与防护措施。</li><li>高性能二进制序列化方案对比：Kryo、Protostuff、Protobuf、Avro。</li><li>JSON 和二进制序列化的权衡（可读性 vs 性能&#x2F;大小）。</li><li>如何实现可演化的序列化协议（向前&#x2F;向后兼容）？</li><li>对象图序列化时循环引用的处理（句柄机制）。</li><li>对象序列化性能调优要点（缓冲、对象重用）。</li><li>在分布式系统中如何管理序列化策略（跨服务版本）？</li><li>自定义序列化（writeObject&#x2F;readObject）常见陷阱。</li><li>序列化时如何处理类加载器问题？</li><li>大对象序列化时的内存与 GC 风险如何降低？</li><li>使用序列化作为缓存（Redis&#x2F;Memcached）时的注意事项。</li></ol><hr><h2 id="五、NIO-深入：Buffer-Channel-Selector（76–100）"><a href="#五、NIO-深入：Buffer-Channel-Selector（76–100）" class="headerlink" title="五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）"></a>五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）</h2><hr><h3 id="1-NIO-三大核心（Buffer、Channel、Selector）"><a href="#1-NIO-三大核心（Buffer、Channel、Selector）" class="headerlink" title="1. NIO 三大核心（Buffer、Channel、Selector）"></a>1. NIO 三大核心（Buffer、Channel、Selector）</h3><ul><li><strong>Buffer</strong>：数据容器，所有读写操作都要通过它完成。</li><li><strong>Channel</strong>：通道，连接数据源与 Buffer，支持双向读写。</li><li><strong>Selector</strong>：多路复用器，检测多个 Channel 的事件（读、写、连接等），实现非阻塞 IO。</li></ul><hr><h3 id="2-ByteBuffer-的-position-limit-capacity"><a href="#2-ByteBuffer-的-position-limit-capacity" class="headerlink" title="2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity"></a>2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity</h3><ul><li><strong>capacity</strong>：缓冲区的总容量，创建时确定。</li><li><strong>position</strong>：当前读写指针，表示下一个操作的位置。</li><li><strong>limit</strong>：可操作的边界，写模式下&#x3D;capacity，读模式下&#x3D;写入的数据量。</li></ul><hr><h3 id="3-flip-clear-rewind-compact"><a href="#3-flip-clear-rewind-compact" class="headerlink" title="3. flip(), clear(), rewind(), compact()"></a>3. flip(), clear(), rewind(), compact()</h3><ul><li><strong>flip()</strong>：切换写 → 读模式（limit&#x3D;position，position&#x3D;0）。</li><li><strong>clear()</strong>：清空缓冲，准备写（position&#x3D;0，limit&#x3D;capacity）。</li><li><strong>rewind()</strong>：重新读（position&#x3D;0，limit 不变）。</li><li><strong>compact()</strong>：未读数据前移，position 指向未读数据末尾。</li></ul><hr><h3 id="4-DirectByteBuffer-vs-HeapByteBuffer"><a href="#4-DirectByteBuffer-vs-HeapByteBuffer" class="headerlink" title="4. DirectByteBuffer vs HeapByteBuffer"></a>4. DirectByteBuffer vs HeapByteBuffer</h3><ul><li><strong>HeapByteBuffer</strong>：数据在 JVM 堆内存，GC 管理，拷贝到内核态多一份。</li><li><strong>DirectByteBuffer</strong>：数据在堆外内存，IO 时零拷贝，性能更高，但分配释放代价大。</li></ul><hr><h3 id="5-ByteBuffer-slice-asReadOnlyBuffer"><a href="#5-ByteBuffer-slice-asReadOnlyBuffer" class="headerlink" title="5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()"></a>5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()</h3><ul><li><strong>slice()</strong>：共享底层数据，新的缓冲区 position&#x3D;0，limit&#x3D;剩余。</li><li><strong>asReadOnlyBuffer()</strong>：生成只读视图，修改会抛 <code>ReadOnlyBufferException</code>。</li></ul><hr><h3 id="6-Scatter-Gather-IO"><a href="#6-Scatter-Gather-IO" class="headerlink" title="6. Scatter&#x2F;Gather IO"></a>6. Scatter&#x2F;Gather IO</h3><ul><li><strong>Scatter Read</strong>：一个 Channel → 多个 Buffer（适合固定头+体）。</li><li><strong>Gather Write</strong>：多个 Buffer → 一个 Channel（避免拼接）。</li></ul><hr><h3 id="7-FileChannel-的关键方法"><a href="#7-FileChannel-的关键方法" class="headerlink" title="7. FileChannel 的关键方法"></a>7. FileChannel 的关键方法</h3><ul><li><strong>position()</strong>：获取&#x2F;设置文件指针。</li><li><strong>size()</strong>：返回文件大小。</li><li><strong>truncate(long size)</strong>：截断文件。</li><li><strong>force(boolean metaData)</strong>：强制写入磁盘。</li></ul><hr><h3 id="8-MappedByteBuffer（内存映射）"><a href="#8-MappedByteBuffer（内存映射）" class="headerlink" title="8. MappedByteBuffer（内存映射）"></a>8. MappedByteBuffer（内存映射）</h3><ul><li><strong>创建</strong>：<code>FileChannel.map(mode, position, size)</code></li><li><strong>优点</strong>：直接操作内存映射，效率高。</li><li><strong>释放</strong>：JDK 无直接 API，通常通过反射 <code>Cleaner.clean()</code>，需注意内存泄露。</li></ul><hr><h3 id="9-Channel-vs-Stream"><a href="#9-Channel-vs-Stream" class="headerlink" title="9. Channel vs Stream"></a>9. Channel vs Stream</h3><ul><li><strong>Stream</strong>：单向、阻塞。</li><li><strong>Channel</strong>：双向、可非阻塞，可和 Selector 配合。</li></ul><hr><h3 id="10-Selector-工作流程"><a href="#10-Selector-工作流程" class="headerlink" title="10. Selector 工作流程"></a>10. Selector 工作流程</h3><ol><li><strong>注册</strong>：<code>channel.register(selector, ops)</code></li><li><strong>选择</strong>：<code>selector.select(timeout)</code></li><li><strong>遍历</strong>：<code>selectedKeys()</code> 遍历处理</li><li><strong>取消</strong>：调用 <code>key.cancel()</code></li></ol><hr><h3 id="11-Selector-底层实现"><a href="#11-Selector-底层实现" class="headerlink" title="11. Selector 底层实现"></a>11. Selector 底层实现</h3><ul><li><strong>Linux</strong>：epoll</li><li><strong>Windows</strong>：select</li><li><strong>macOS</strong>：kqueue<br> 影响性能和可扩展性（epoll 适合高并发）。</li></ul><hr><h3 id="12-非阻塞-Channel-的-read-write-返回值"><a href="#12-非阻塞-Channel-的-read-write-返回值" class="headerlink" title="12. 非阻塞 Channel 的 read&#x2F;write 返回值"></a>12. 非阻塞 Channel 的 read&#x2F;write 返回值</h3><ul><li><p><strong>read</strong>：</p><ul><li><blockquote><p>0：读取字节数</p></blockquote></li><li><p>0：无数据</p></li><li><p>-1：EOF（关闭）</p></li></ul></li><li><p><strong>write</strong>：</p><ul><li><blockquote><p>0：写入字节数</p></blockquote></li><li><p>0：内核缓冲区满</p></li></ul></li></ul><hr><h3 id="13-粘包-拆包问题"><a href="#13-粘包-拆包问题" class="headerlink" title="13. 粘包&#x2F;拆包问题"></a>13. 粘包&#x2F;拆包问题</h3><p>原因：TCP 流式传输无边界。<br> 解决策略：</p><ul><li>固定长度（定长协议）</li><li>分隔符（如 <code>\n</code>）</li><li>长度前置（常见）</li></ul><hr><h3 id="14-超时断开-心跳检测"><a href="#14-超时断开-心跳检测" class="headerlink" title="14. 超时断开 &amp; 心跳检测"></a>14. 超时断开 &amp; 心跳检测</h3><ul><li><strong>超时断开</strong>：在 <code>select(timeout)</code> 中检测长时间无读写的连接。</li><li><strong>心跳检测</strong>：客户端&#x2F;服务端定期发送 <code>PING</code>，无响应则断开。</li></ul><hr><h3 id="15-Pipe-在-NIO-中的作用"><a href="#15-Pipe-在-NIO-中的作用" class="headerlink" title="15. Pipe 在 NIO 中的作用"></a>15. Pipe 在 NIO 中的作用</h3><ul><li>单向通信（写端 → 读端），常用于线程间通信。</li><li>但性能不如 BlockingQueue。</li></ul><hr><h3 id="16-多-Selector-多-Reactor"><a href="#16-多-Selector-多-Reactor" class="headerlink" title="16. 多 Selector &#x2F; 多 Reactor"></a>16. 多 Selector &#x2F; 多 Reactor</h3><ul><li><strong>单 Reactor</strong>：一个线程负责 Selector。</li><li><strong>多 Reactor</strong>：主 Reactor 处理 accept，子 Reactor 处理 read&#x2F;write。</li><li><strong>多 Selector</strong>：线程池分担 Channel 负载。</li></ul><hr><h3 id="17-ByteBuffer-多线程问题"><a href="#17-ByteBuffer-多线程问题" class="headerlink" title="17. ByteBuffer 多线程问题"></a>17. ByteBuffer 多线程问题</h3><ul><li><strong>不是线程安全的</strong>。</li><li>解决：每个线程独立 Buffer，或外部加锁。</li></ul><hr><h3 id="18-DirectByteBuffer-避免泄露"><a href="#18-DirectByteBuffer-避免泄露" class="headerlink" title="18. DirectByteBuffer 避免泄露"></a>18. DirectByteBuffer 避免泄露</h3><ul><li>使用 <code>ByteBuffer.allocateDirect()</code> 代价大。</li><li>建议：使用 <code>-XX:+UseLargePages</code>、池化管理（Netty 的 <code>PooledByteBufAllocator</code>）。</li></ul><hr><h3 id="19-Selector-selectedKeys-正确用法"><a href="#19-Selector-selectedKeys-正确用法" class="headerlink" title="19. Selector selectedKeys 正确用法"></a>19. Selector selectedKeys 正确用法</h3><ul><li>遍历 <code>selectedKeys()</code></li><li>处理完一个 key → <code>iterator.remove()</code></li><li>否则下次循环仍会触发。</li></ul><hr><h3 id="20-NIO-高效读写循环模板"><a href="#20-NIO-高效读写循环模板" class="headerlink" title="20. NIO 高效读写循环模板"></a>20. NIO 高效读写循环模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) sc.close();</span><br><span class="line">            <span class="keyword">else</span> &#123; buf.flip(); sc.write(buf); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-transferTo-transferFrom（零拷贝）"><a href="#21-transferTo-transferFrom（零拷贝）" class="headerlink" title="21. transferTo&#x2F;transferFrom（零拷贝）"></a>21. transferTo&#x2F;transferFrom（零拷贝）</h3><ul><li>直接在内核空间完成文件复制（减少用户态拷贝）。</li><li>局限：Windows 一次传输大小有限，需循环。</li></ul><hr><h3 id="22-FileChannel-高效复制"><a href="#22-FileChannel-高效复制" class="headerlink" title="22. FileChannel 高效复制"></a>22. FileChannel 高效复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel()) &#123;</span><br><span class="line">    in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-高并发服务器瓶颈"><a href="#23-高并发服务器瓶颈" class="headerlink" title="23. 高并发服务器瓶颈"></a>23. 高并发服务器瓶颈</h3><ul><li>单线程 Selector 性能不足。</li><li>Buffer&#x2F;Direct 内存泄露。</li><li>大量小包（TCP 粘拆包）。</li><li>epoll 空轮询 bug（CPU 飙高）。</li></ul><hr><h3 id="24-Windows-vs-Linux"><a href="#24-Windows-vs-Linux" class="headerlink" title="24. Windows vs Linux"></a>24. Windows vs Linux</h3><ul><li><strong>Linux</strong>：epoll，可伸缩到百万连接。</li><li><strong>Windows</strong>：select，fd 数量受限，扩展性差。</li></ul><hr><h3 id="25-简单-Echo-Server-思路"><a href="#25-简单-Echo-Server-思路" class="headerlink" title="25. 简单 Echo Server 思路"></a>25. 简单 Echo Server 思路</h3><ol><li>创建 <code>Selector</code></li><li>注册 <code>ServerSocketChannel</code></li><li>循环 <code>select()</code></li><li>处理 <code>accept</code> → 注册 SocketChannel</li><li>处理 <code>read</code> → 回写数据</li></ol><hr><p>⚡总结：NIO 的核心是 <strong>缓冲区管理</strong>（ByteBuffer）、<strong>多路复用</strong>（Selector）、<strong>零拷贝优化</strong>（FileChannel.transferTo&#x2F;MappedByteBuffer）。<br> 在高并发系统里（如 Netty），这些 API 会结合线程模型和内存池进一步优化。</p><hr><h2 id="六、Socket-TCP-UDP-WebSocket（101–140）"><a href="#六、Socket-TCP-UDP-WebSocket（101–140）" class="headerlink" title="六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）"></a>六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）</h2><ol><li>Socket 的基本概念：端点、三元组&#x2F;四元组（IP:port + peer）。</li><li>Java 中 Socket、ServerSocket、DatagramSocket 的主要 API 区别。</li><li>TCP 与 UDP 的核心差异（可靠性、有序性、连接性）。</li><li>TCP 三次握手（SYN、SYN-ACK、ACK）与四次挥手流程详解。</li><li>TIME_WAIT、CLOSE_WAIT、FIN_WAIT1&#x2F;2 等 TCP 状态含义与产生原因。</li><li>半开连接（half-open）是什么，如何检测与恢复？</li><li>TCP 的流量控制（窗口）与拥塞控制（慢启动、拥塞避免、快重传、快恢复）基础。</li><li>Nagle 算法（TCP_NODELAY）的原理和在延迟场景下的影响。</li><li>TCP 延迟确认（delayed ACK）对交互型应用的影响。</li><li>Socket 选项 SO_TIMEOUT、SO_KEEPALIVE、SO_REUSEADDR、SO_REUSEPORT、SO_LINGER 含义与使用场景。</li><li>backlog 参数（ServerSocket 构造或 listen）与 accept 队列（syn, accept 队列）区别。</li><li>ephemeral port（短暂端口）与端口耗尽问题及解决办法。</li><li>SYN flood 攻击的原理和防护（SYN cookies、firewall）。</li><li>TCP 快速打开（TCP Fast Open）是什么，有何优劣？（简述）</li><li>MTU、MSS 与 IP 分片对传输的影响与诊断方法。</li><li>UDP 的组播（Multicast）与广播（Broadcast）机制与 Java 支持（MulticastSocket）。</li><li>UDP 丢包、乱序、包大小限制（最佳实践）。</li><li>UDP 穿透 NAT（STUN&#x2F;ICE）的基本原理。</li><li>如何在 Java 中实现高性能 UDP 服务器？（NIO + DatagramChannel）</li><li>WebSocket 协议基础（握手、帧格式、ping&#x2F;pong、close）。</li><li>Java 实现 WebSocket 的常见库（javax.websocket、Netty websocket、Undertow）。</li><li>TLS over TCP（HTTPS）的握手流程要点（证书验证、对称密钥协商）。</li><li>使用 SSLSocket &#x2F; SSLServerSocket 和 SSLEngine 的差别及适用场景。</li><li>SSL&#x2F;TLS 握手的重用（session resumption）与性能优化。</li><li>中间人攻击（MITM）与证书链、CA、信任根的角色。</li><li>如何在 Socket 程序中实现心跳、超时与断线重连？</li><li>TCP Keepalive 与应用层心跳的区别和协同使用。</li><li>如何通过抓包（tcpdump&#x2F;wireshark）诊断 Socket 连接问题？</li><li>Socket 的非阻塞 accept&#x2F;read&#x2F;write 实现注意点（资源&#x2F;异步安全）。</li><li>如何避免 TCP 粘包&#x2F;拆包在 Socket 原生编程中的影响（流式协议设计）？</li><li>实战：实现一个带长度前缀的 TCP 协议的 Java 服务端&#x2F;客户端（思路）。</li><li>如何优雅处理大量短连接的场景？（连接池、HTTP keep-alive）</li><li>Socket 端口复用（SO_REUSEADDR vs SO_REUSEPORT）在负载均衡中的用法。</li><li>多路复用（select&#x2F;poll&#x2F;epoll）与 socket 大连接数的处理。</li><li>网络字节序（big-endian）与数据编解码注意点。</li><li>使用 TCP_NODELAY（禁用 Nagle）时的 CPU&#x2F;网络 trade-off。</li><li>如何在 Java 中做到零拷贝文件传输（Socket + FileChannel.transferTo）？</li><li>Socket 关闭流程中遇到阻塞（SO_LINGER）的处理办法。</li><li>如何防止或检测 “socket half-closed” 的资源泄漏？</li><li>实战题：用 BIO、NIO、Netty 各实现一个简易的聊天服务器，比较性能与代码复杂度（思路要点）。</li></ol><hr><h2 id="七、异步-IO、IO-模型与高阶模式（141–150）"><a href="#七、异步-IO、IO-模型与高阶模式（141–150）" class="headerlink" title="七、异步 IO、IO 模型与高阶模式（141–150）"></a>七、异步 IO、IO 模型与高阶模式（141–150）</h2><ol><li>IO 模型分类：同步阻塞、同步非阻塞、IO 多路复用、信号驱动、异步（AIO）。</li><li>Reactor 模式与 Proactor 模式的原理与区别。</li><li>Java AIO（AsynchronousChannel、AsynchronousSocketChannel）API 介绍。</li><li>CompletionHandler 与 Future 风格的异步回调比较。</li><li>高并发下选择 NIO 还是 AIO 的实际考量（实现复杂度、平台支持）。</li><li>事件驱动系统的 back-pressure 设计（流控、速率限制）。</li><li>线程模型设计：acceptors &#x2F; io workers &#x2F; business workers 的权衡。</li><li>RCU、无锁队列在高并发 IO 框架中的应用场景。</li><li>如何在应用层实现请求队列与排队策略来缓解突发流量？</li><li>实战题：设计一个支持百万连接的服务器架构（核心组件与 IO 策略）。</li></ol><hr><h2 id="八、零拷贝、内核与性能调优（151–160）"><a href="#八、零拷贝、内核与性能调优（151–160）" class="headerlink" title="八、零拷贝、内核与性能调优（151–160）"></a>八、零拷贝、内核与性能调优（151–160）</h2><ol><li>零拷贝（zero-copy）概念和常见实现（sendfile, mmap, splice）。</li><li>FileChannel.transferTo&#x2F;transferFrom 在 Linux 下如何利用 sendfile 实现零拷贝？</li><li>mmap（内存映射文件）的实现原理与 GC &#x2F;回收问题。</li><li>DMA（Direct Memory Access）在零拷贝中的作用与限制。</li><li>内核态 &#x2F; 用户态拷贝次数与零拷贝带来的减少效果。</li><li>TCP 窗口、拥塞控制调优参数（net.ipv4.tcp_* 系列常见项）。</li><li>系统级调优：文件描述符上限（ulimit -n）、somaxconn、backlog、epoll_limits 等。</li><li>高并发网络服务的监控指标（fd 使用、accept latency、context switch、cpu steal）。</li><li>性能诊断工具与流程：iostat, vmstat, sar, perf, tcpdump, ss, strace。</li><li>实战题：如何定位并修复一个高并发服务器的 accept 阻塞 &#x2F; 连接丢失 问题（诊断步骤）。</li></ol><hr><h1 id="Java-基础面试题"><a href="#Java-基础面试题" class="headerlink" title="Java 基础面试题"></a>Java 基础面试题</h1><h3 id="一、语言特性-基础语法"><a href="#一、语言特性-基础语法" class="headerlink" title="一、语言特性 &amp; 基础语法"></a>一、语言特性 &amp; 基础语法</h3><hr><h3 id="1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？"><a href="#1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？" class="headerlink" title="1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？"></a>1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？</h3><ul><li><strong>&#x3D;&#x3D;</strong><ul><li>对于基本数据类型：比较值是否相等。</li><li>对于引用类型：比较两个引用是否指向同一块内存地址（即是否是同一个对象）。</li></ul></li><li><strong>equals()</strong><ul><li>定义在 <code>Object</code> 类中，默认实现也是 <code>==</code>。</li><li>一般会被类（如 <code>String</code>、<code>Integer</code> 等）重写，用来比较“内容”是否相同，而不是内存地址。</li></ul></li></ul><p>👉 正确重写 <code>equals()</code> 要满足 <strong>自反性、对称性、传递性、一致性</strong>，并且和 <code>null</code> 比较时返回 <code>false</code>。<br> 典型实现步骤：</p><ol><li>判断 <code>this == obj</code>，若相等直接返回 <code>true</code>。</li><li>判断 <code>obj</code> 是否为同类实例。</li><li>强制类型转换后逐个比较关键字段。</li></ol><hr><h3 id="2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？"><a href="#2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？" class="headerlink" title="2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？"></a>2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？</h3><ul><li><strong>原因</strong>：因为 <code>HashMap</code>、<code>HashSet</code> 等基于哈希表的集合使用 <code>hashCode()</code> 来决定元素存放位置，然后再用 <code>equals()</code> 判断元素是否相同。</li><li><strong>契约</strong>（JDK 文档规定）：<ul><li>如果两个对象 <code>equals()</code> 相等，那么它们的 <code>hashCode()</code> 必须相等。</li><li>反之，<code>hashCode()</code> 相等并不一定意味着 <code>equals()</code> 相等。</li></ul></li><li><strong>不重写会怎样</strong>：<ul><li>两个内容相同的对象可能 <code>equals()</code> 为 true，但 <code>hashCode()</code> 不同，导致放进 <code>HashSet</code> 时被当作两个对象存储，违背集合“不重复”的原则。</li></ul></li></ul><hr><h3 id="3-Object-类有哪些方法？哪些方法经常需要重写？"><a href="#3-Object-类有哪些方法？哪些方法经常需要重写？" class="headerlink" title="3. Object 类有哪些方法？哪些方法经常需要重写？"></a>3. Object 类有哪些方法？哪些方法经常需要重写？</h3><ul><li><strong>常用方法</strong>：<ul><li><code>equals()</code>：对象内容比较。</li><li><code>hashCode()</code>：哈希值，配合 <code>equals</code>。</li><li><code>toString()</code>：对象的字符串表示。</li><li><code>clone()</code>：对象克隆（浅拷贝，需实现 <code>Cloneable</code>）。</li><li><code>finalize()</code>：对象被 GC 前调用（已不推荐使用）。</li></ul></li><li><strong>同步方法</strong>：<ul><li><code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：线程通信。</li></ul></li><li><strong>类相关方法</strong>：<ul><li><code>getClass()</code>：获取对象的运行时类型。</li></ul></li></ul><p>👉 经常需要重写的：<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>。</p><hr><h3 id="4-final、finally、finalize-有什么区别？"><a href="#4-final、finally、finalize-有什么区别？" class="headerlink" title="4. final、finally、finalize() 有什么区别？"></a>4. final、finally、finalize() 有什么区别？</h3><ul><li><strong>final</strong>：关键字<ul><li>修饰类：类不能被继承。</li><li>修饰方法：方法不能被重写。</li><li>修饰变量：变量成为常量，只能赋值一次。</li></ul></li><li><strong>finally</strong>：关键字<ul><li>用于 <code>try-catch-finally</code>，无论是否有异常，<code>finally</code> 块中的代码一定会执行（除非 <code>System.exit(0)</code>）。</li></ul></li><li><strong>finalize()</strong>：方法<ul><li><code>Object</code> 类定义，在 GC 前调用，常用于释放非托管资源。</li><li>已被标记为废弃（Java 9 开始），因为不可预测、不可靠。</li></ul></li></ul><hr><h3 id="5-Java-中的-instanceof-关键字是如何实现的？"><a href="#5-Java-中的-instanceof-关键字是如何实现的？" class="headerlink" title="5. Java 中的 instanceof 关键字是如何实现的？"></a>5. Java 中的 instanceof 关键字是如何实现的？</h3><ul><li><strong>作用</strong>：判断某个对象是否为某个类或其子类的实例。</li><li><strong>实现原理</strong>：<ul><li>JVM 在对象头中存储了对象所属的类的元数据指针。</li><li><code>instanceof</code> 实际是检查该类元数据是否是指定类或其子类。</li><li>编译器会将 <code>obj instanceof A</code> 转换为字节码 <code>instanceof</code> 指令，由 JVM 在运行时判断。</li></ul></li></ul><hr><h3 id="6-接口和抽象类的区别？接口能不能有构造函数？"><a href="#6-接口和抽象类的区别？接口能不能有构造函数？" class="headerlink" title="6. 接口和抽象类的区别？接口能不能有构造函数？"></a>6. 接口和抽象类的区别？接口能不能有构造函数？</h3><ul><li><strong>接口</strong>：<ul><li>只能定义方法（Java 8 之后可有 <code>default</code> 和 <code>static</code> 方法）。</li><li>不能有构造函数（因为接口不能直接实例化）。</li><li>可以实现 <strong>多继承</strong>（一个类可以实现多个接口）。</li></ul></li><li><strong>抽象类</strong>：<ul><li>可以有普通方法、抽象方法、成员变量。</li><li>可以有构造函数（但不能直接 new，用于子类构造时调用）。</li><li>只能单继承。</li></ul></li></ul><hr><h3 id="7-接口可以多继承吗？抽象类可以实现接口吗？"><a href="#7-接口可以多继承吗？抽象类可以实现接口吗？" class="headerlink" title="7. 接口可以多继承吗？抽象类可以实现接口吗？"></a>7. 接口可以多继承吗？抽象类可以实现接口吗？</h3><ul><li><strong>接口可以多继承</strong>：<code>interface A extends B, C &#123;&#125;</code></li><li><strong>抽象类可以实现接口</strong>：可以选择性实现接口的方法，未实现的方法仍保持 <code>abstract</code>，由子类实现。</li></ul><hr><h3 id="8-default-方法和-static-方法在接口中的意义是什么？"><a href="#8-default-方法和-static-方法在接口中的意义是什么？" class="headerlink" title="8. default 方法和 static 方法在接口中的意义是什么？"></a>8. default 方法和 static 方法在接口中的意义是什么？</h3><ul><li><strong>default 方法</strong>：<ul><li>Java 8 引入，接口中可以有默认实现的方法。</li><li>解决接口扩展的兼容性问题（给老接口新增方法不会导致所有实现类报错）。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于接口本身，而不是实现类。</li><li>用于提供工具方法或公共逻辑（类似 <code>Collections</code> 的工具类方法）。</li></ul></li></ul><hr><h3 id="9-什么是内部类？分为哪几种？"><a href="#9-什么是内部类？分为哪几种？" class="headerlink" title="9. 什么是内部类？分为哪几种？"></a>9. 什么是内部类？分为哪几种？</h3><ul><li><strong>内部类</strong>：定义在类中的类，可以访问外部类的成员。</li><li><strong>种类</strong>：<ol><li><strong>成员内部类</strong>（非静态内部类）<ul><li>依赖外部类实例，不能有 <code>static</code> 成员。</li></ul></li><li><strong>静态内部类</strong><ul><li>类似普通类，但作用域在外部类内，可以有 <code>static</code> 成员。</li></ul></li><li><strong>局部内部类</strong><ul><li>定义在方法体或代码块中，只能在该范围内使用。</li></ul></li><li><strong>匿名内部类</strong><ul><li>没有名字，通常在需要“临时实现接口或继承类”的场景使用。</li></ul></li></ol></li></ul><hr><h3 id="10-匿名内部类和-Lambda-表达式的区别？"><a href="#10-匿名内部类和-Lambda-表达式的区别？" class="headerlink" title="10. 匿名内部类和 Lambda 表达式的区别？"></a>10. 匿名内部类和 Lambda 表达式的区别？</h3><ul><li><strong>匿名内部类</strong>：<ul><li>实现接口&#x2F;继承抽象类的 <strong>具体匿名类对象</strong>。</li><li>可以有多个方法，但通常只重写需要的方法。</li><li>生成 <code>.class</code> 文件（额外开销）。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>仅能用于 <strong>函数式接口</strong>（只有一个抽象方法的接口）。</li><li>更简洁，本质是语法糖，编译后生成 <code>invokedynamic</code> 字节码指令，调用运行时生成的函数对象。</li><li>不会创建新的 <code>.class</code> 文件，更轻量。</li></ul></li></ul><hr><h3 id="二、数据类型-内存"><a href="#二、数据类型-内存" class="headerlink" title="二、数据类型 &amp; 内存"></a>二、数据类型 &amp; 内存</h3><hr><h3 id="1-Java-中的基本数据类型和包装类型有哪些区别？"><a href="#1-Java-中的基本数据类型和包装类型有哪些区别？" class="headerlink" title="1. Java 中的基本数据类型和包装类型有哪些区别？"></a>1. Java 中的基本数据类型和包装类型有哪些区别？</h3><ul><li><strong>基本数据类型</strong>（primitive）：<code>byte, short, int, long, float, double, char, boolean</code><ul><li>存储在栈上（或寄存器），效率高，空间占用固定。</li><li>不能为 <code>null</code>，默认值固定（如 <code>int</code> 默认 <code>0</code>，<code>boolean</code> 默认 <code>false</code>）。</li></ul></li><li><strong>包装类型</strong>（wrapper）：<code>Byte, Short, Integer, Long, Float, Double, Character, Boolean</code><ul><li>是对象，存储在堆中。</li><li>可以为 <code>null</code>，有丰富的 API。</li><li>可以参与集合类（如 <code>ArrayList</code> 只能存对象）。</li></ul></li><li><strong>自动装箱&#x2F;拆箱</strong>：Java 会在基本类型和包装类之间自动转换。</li></ul><hr><h3 id="2-为什么-Integer-有缓存机制？范围是多少？"><a href="#2-为什么-Integer-有缓存机制？范围是多少？" class="headerlink" title="2. 为什么 Integer 有缓存机制？范围是多少？"></a>2. 为什么 Integer 有缓存机制？范围是多少？</h3><ul><li><strong>原因</strong>：<ul><li>为了避免频繁创建对象，提高性能。</li><li>小整数使用频率高（如循环、下标），所以缓存常用的整数。</li></ul></li><li><strong>范围</strong>：<code>-128 ~ 127</code>。</li><li><strong>实现</strong>：<ul><li><code>IntegerCache</code> 静态内部类在类加载时初始化缓存数组。</li><li><code>Integer.valueOf(int i)</code> 方法会先查缓存，再决定是否 new 对象。</li></ul></li></ul><hr><h3 id="3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？"><a href="#3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？" class="headerlink" title="3. 为什么 new Integer(127) == new Integer(127) 为 false，而 Integer.valueOf(127) == Integer.valueOf(127) 为 true？"></a>3. 为什么 <code>new Integer(127) == new Integer(127)</code> 为 false，而 <code>Integer.valueOf(127) == Integer.valueOf(127)</code> 为 true？</h3><ul><li><code>new Integer(127)</code>：每次都会创建新对象，内存地址不同，所以 <code>==</code> 为 false。</li><li><code>Integer.valueOf(127)</code>：会查缓存，<code>127</code> 在 <code>-128~127</code> 范围内，返回同一个对象引用，所以 <code>==</code> 为 true。</li></ul><p>👉 <strong>总结</strong>：</p><ul><li><code>==</code> 比较的是引用地址。</li><li><code>equals()</code> 才是比较数值。</li></ul><hr><h3 id="4-NaN-和-Infinity-在-Java-中如何表示？"><a href="#4-NaN-和-Infinity-在-Java-中如何表示？" class="headerlink" title="4. NaN 和 Infinity 在 Java 中如何表示？"></a>4. NaN 和 Infinity 在 Java 中如何表示？</h3><ul><li><strong>NaN（Not a Number）</strong>：<ul><li>如 <code>0.0 / 0.0</code> 或 <code>Math.sqrt(-1)</code>。</li><li>特点：<code>NaN != NaN</code>，要用 <code>Double.isNaN()</code> 检测。</li></ul></li><li><strong>Infinity（正&#x2F;负无穷大）</strong>：<ul><li>如 <code>1.0 / 0.0 = Infinity</code>，<code>-1.0 / 0.0 = -Infinity</code>。</li><li>用 <code>Double.isInfinite()</code> 检测。</li></ul></li></ul><hr><h3 id="5-为什么浮点数计算有精度问题？如何避免？"><a href="#5-为什么浮点数计算有精度问题？如何避免？" class="headerlink" title="5. 为什么浮点数计算有精度问题？如何避免？"></a>5. 为什么浮点数计算有精度问题？如何避免？</h3><ul><li><strong>原因</strong>：<ul><li>浮点数采用 <strong>IEEE 754 二进制浮点表示</strong>，大多数十进制小数（如 <code>0.1</code>）不能精确表示，只能存储近似值。</li><li>计算时会累积误差。</li></ul></li><li><strong>避免方法</strong>：<ul><li>使用 <code>BigDecimal</code>（推荐）。</li><li>或使用整数替代（如金额用分而不是元）。</li></ul></li></ul><hr><h3 id="6-BigDecimal-为什么能解决浮点数精度问题？"><a href="#6-BigDecimal-为什么能解决浮点数精度问题？" class="headerlink" title="6. BigDecimal 为什么能解决浮点数精度问题？"></a>6. BigDecimal 为什么能解决浮点数精度问题？</h3><ul><li><strong>原理</strong>：<ul><li>内部使用 <strong>BigInteger + 精度标识 scale</strong> 表示任意精度的十进制数。</li><li>不依赖二进制浮点存储，而是基于字符串或整数进行精确计算。</li></ul></li><li><strong>注意</strong>：<ul><li>不能用 <code>new BigDecimal(double)</code>（会带入二进制误差）。</li><li>推荐 <code>BigDecimal.valueOf(double)</code> 或 <code>new BigDecimal(String)</code>。</li></ul></li></ul><hr><h3 id="7-Java-中的字符集默认是什么？在不同平台上会不一样吗？"><a href="#7-Java-中的字符集默认是什么？在不同平台上会不一样吗？" class="headerlink" title="7. Java 中的字符集默认是什么？在不同平台上会不一样吗？"></a>7. Java 中的字符集默认是什么？在不同平台上会不一样吗？</h3><ul><li>Java 内部使用 <strong>UTF-16（Unicode）</strong> 存储 <code>char</code> 和 <code>String</code>。</li><li>默认字符集（<code>Charset.defaultCharset()</code>）会随平台不同而不同：<ul><li>Windows（中文环境）：<code>GBK</code> 或 <code>GB2312</code>。</li><li>Linux &#x2F; macOS：通常是 <code>UTF-8</code>。<br> 👉 这会影响文件读写、网络传输等。</li></ul></li></ul><hr><h3 id="8-String、StringBuilder、StringBuffer-区别？线程安全性？"><a href="#8-String、StringBuilder、StringBuffer-区别？线程安全性？" class="headerlink" title="8. String、StringBuilder、StringBuffer 区别？线程安全性？"></a>8. String、StringBuilder、StringBuffer 区别？线程安全性？</h3><ul><li><strong>String</strong><ul><li>不可变类（底层 <code>final char[]</code>），每次拼接都会生成新对象。</li></ul></li><li><strong>StringBuilder</strong><ul><li>可变字符序列（底层 <code>char[]</code>），高效，<strong>非线程安全</strong>。</li></ul></li><li><strong>StringBuffer</strong><ul><li>可变字符序列，方法加了 <code>synchronized</code>，<strong>线程安全</strong>，效率比 <code>StringBuilder</code> 低。</li></ul></li></ul><p>👉 单线程推荐 <code>StringBuilder</code>，多线程推荐 <code>StringBuffer</code>。</p><hr><h3 id="9-为什么-String-是不可变的？背后实现细节？"><a href="#9-为什么-String-是不可变的？背后实现细节？" class="headerlink" title="9. 为什么 String 是不可变的？背后实现细节？"></a>9. 为什么 String 是不可变的？背后实现细节？</h3><ul><li><strong>原因</strong>：<ol><li><strong>安全性</strong>：如网络请求 URL、文件路径、ClassLoader 名称等，一旦创建不可修改，避免被篡改。</li><li><strong>线程安全</strong>：不可变对象天然线程安全。</li><li><strong>哈希值缓存</strong>：<code>String</code> 缓存了 <code>hashCode</code>，不可变保证哈希值不会变化。</li><li><strong>字符串常量池优化</strong>：不可变对象可被复用。</li></ol></li><li><strong>实现</strong>：<ul><li><code>private final char[] value</code>（JDK 9 以后改成 <code>byte[]</code> + <code>coder</code>，节省内存）。</li></ul></li></ul><hr><h3 id="10-intern-方法的作用是什么？"><a href="#10-intern-方法的作用是什么？" class="headerlink" title="10. intern() 方法的作用是什么？"></a>10. intern() 方法的作用是什么？</h3><ul><li><p><strong>作用</strong>：</p><ul><li>将字符串放入 <strong>字符串常量池</strong>，返回池中的引用。</li><li>若池中已有等值字符串，则返回已有对象引用。</li></ul></li><li><p><strong>意义</strong>：</p><ul><li>减少内存占用，提高比较效率（常量池中的 <code>String</code> 可以直接用 <code>==</code> 比较）。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="三、集合框架"><a href="#三、集合框架" class="headerlink" title="三、集合框架"></a>三、集合框架</h3><hr><h2 id="1-ArrayList-和-Vector-的区别"><a href="#1-ArrayList-和-Vector-的区别" class="headerlink" title="1. ArrayList 和 Vector 的区别"></a><strong>1. ArrayList 和 Vector 的区别</strong></h2><table><thead><tr><th>特性</th><th>ArrayList</th><th>Vector</th></tr></thead><tbody><tr><td>线程安全</td><td>非线程安全</td><td>线程安全（方法加 synchronized）</td></tr><tr><td>扩容机制</td><td>默认 1.5 倍</td><td>默认 2 倍</td></tr><tr><td>性能</td><td>高（无锁）</td><td>低（同步开销）</td></tr><tr><td>用途</td><td>多线程外部不安全</td><td>适合多线程共享场景，但现在较少使用</td></tr><tr><td>面试拓展</td><td>如何在多线程下安全使用 ArrayList？可用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code></td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>都基于动态数组实现</li><li>添加元素时如果容量不够，会创建一个新的数组并复制原数组内容</li></ul><hr><h2 id="2-为什么-ArrayList-的扩容是-1-5-倍？"><a href="#2-为什么-ArrayList-的扩容是-1-5-倍？" class="headerlink" title="2. 为什么 ArrayList 的扩容是 1.5 倍？"></a><strong>2. 为什么 ArrayList 的扩容是 1.5 倍？</strong></h2><ul><li><p><strong>目的</strong>：平衡 <strong>内存消耗</strong> 和 <strong>扩容频率</strong></p></li><li><p><strong>原理</strong>：</p><ul><li>过小扩容：频繁创建新数组，复制开销大</li><li>过大扩容：浪费内存</li></ul></li><li><p>JDK 1.8 的扩容公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 1.5 倍</span></span><br></pre></td></tr></table></figure></li><li><p>面试点：</p><ul><li>LinkedList 不需要扩容，因为链表动态增长</li><li>如何自定义扩容策略？</li></ul></li></ul><hr><h2 id="3-LinkedList-是双向链表还是单向链表？"><a href="#3-LinkedList-是双向链表还是单向链表？" class="headerlink" title="3. LinkedList 是双向链表还是单向链表？"></a><strong>3. LinkedList 是双向链表还是单向链表？</strong></h2><ul><li><p><strong>Java 中 LinkedList 是双向链表</strong></p></li><li><p><strong>结构</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：</p><ul><li>支持快速插入&#x2F;删除（O(1)）</li><li>支持从头尾遍历</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>随机访问慢（O(n)）</li><li>内存占用大（需要 prev 指针）</li></ul></li></ul><hr><h2 id="4-HashSet-底层实现"><a href="#4-HashSet-底层实现" class="headerlink" title="4. HashSet 底层实现"></a><strong>4. HashSet 底层实现</strong></h2><ul><li><strong>底层使用 HashMap 实现</strong></li><li><strong>原理</strong>：<ul><li>每个元素作为 <code>HashMap</code> 的 key</li><li>value 使用一个固定的 Object 对象 <code>PRESENT</code></li></ul></li><li><strong>特点</strong>：<ul><li>不允许重复</li><li>无序存储</li></ul></li><li><strong>性能</strong>：<ul><li>插入、删除、查找均 O(1) 平均</li></ul></li><li>面试拓展：HashSet 和 LinkedHashSet 的区别？<ul><li>LinkedHashSet 维护了插入顺序</li></ul></li></ul><hr><h2 id="5-TreeSet-和-TreeMap-的底层实现"><a href="#5-TreeSet-和-TreeMap-的底层实现" class="headerlink" title="5. TreeSet 和 TreeMap 的底层实现"></a><strong>5. TreeSet 和 TreeMap 的底层实现</strong></h2><ul><li><strong>TreeMap</strong>：基于 <strong>红黑树</strong> 实现</li><li><strong>TreeSet</strong>：内部使用 TreeMap 存储元素</li><li><strong>特点</strong>：<ul><li>自动排序（自然排序或 Comparator）</li><li>查找、插入、删除 O(log n)</li></ul></li><li><strong>红黑树特性</strong>：<ul><li>自平衡二叉搜索树</li><li>插入&#x2F;删除保持平衡，通过旋转和染色操作</li></ul></li></ul><hr><h2 id="6-PriorityQueue-的底层数据结构"><a href="#6-PriorityQueue-的底层数据结构" class="headerlink" title="6. PriorityQueue 的底层数据结构"></a><strong>6. PriorityQueue 的底层数据结构</strong></h2><ul><li><p><strong>基于堆实现</strong>（默认最小堆）</p></li><li><p><strong>特性</strong>：</p><ul><li>插入 O(log n)</li><li>取出最小值 O(log n)</li></ul></li><li><p><strong>内部实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] queue; <span class="comment">// 动态数组存储堆</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用</strong>：</p><ul><li>定时任务调度</li><li>Dijkstra 算法</li></ul></li><li><p>面试拓展：如何实现最大堆？</p><ul><li>使用 Comparator 或覆写 compare 方法</li></ul></li></ul><hr><h2 id="7-ConcurrentSkipListMap-的底层原理"><a href="#7-ConcurrentSkipListMap-的底层原理" class="headerlink" title="7. ConcurrentSkipListMap 的底层原理"></a><strong>7. ConcurrentSkipListMap 的底层原理</strong></h2><ul><li><strong>基于跳表实现</strong></li><li><strong>特点</strong>：<ul><li>有序 Map，支持并发操作</li><li>读操作无锁（lock-free），写操作使用 CAS&#x2F;锁粒度较小</li></ul></li><li><strong>跳表原理</strong>：<ul><li>多层链表</li><li>顶层链表间隔大</li><li>查找、插入、删除 O(log n) 平均</li></ul></li></ul><hr><h2 id="8-CopyOnWriteArrayList-的写时复制"><a href="#8-CopyOnWriteArrayList-的写时复制" class="headerlink" title="8. CopyOnWriteArrayList 的写时复制"></a><strong>8. CopyOnWriteArrayList 的写时复制</strong></h2><ul><li><strong>原理</strong>：<ul><li>每次写操作（add、remove）都会复制一份底层数组</li><li>读操作不加锁，直接读取旧数组</li></ul></li><li><strong>优点</strong>：<ul><li>高度并发读性能</li><li>避免 ConcurrentModificationException</li></ul></li><li><strong>缺点</strong>：<ul><li>写操作成本高（数组复制）</li><li>内存开销大</li></ul></li><li><strong>应用场景</strong>：<ul><li>读多写少（如监听器列表、配置缓存）</li></ul></li></ul><hr><h2 id="9-EnumMap-和-EnumSet"><a href="#9-EnumMap-和-EnumSet" class="headerlink" title="9. EnumMap 和 EnumSet"></a><strong>9. EnumMap 和 EnumSet</strong></h2><ul><li><strong>EnumMap</strong>：<ul><li>Key 是枚举类型</li><li>底层使用数组存储，效率高</li></ul></li><li><strong>EnumSet</strong>：<ul><li>元素为枚举</li><li>底层使用 <strong>位向量(bit vector)</strong> 存储</li></ul></li><li><strong>特点</strong>：<ul><li>高效，占用内存小</li><li>遍历速度快</li></ul></li><li><strong>应用</strong>：<ul><li>状态机、标志位集合</li></ul></li></ul><hr><h2 id="10-WeakHashMap-和-HashMap-的区别"><a href="#10-WeakHashMap-和-HashMap-的区别" class="headerlink" title="10. WeakHashMap 和 HashMap 的区别"></a><strong>10. WeakHashMap 和 HashMap 的区别</strong></h2><table><thead><tr><th>特性</th><th>HashMap</th><th>WeakHashMap</th></tr></thead><tbody><tr><td>Key 引用类型</td><td>强引用</td><td>弱引用</td></tr><tr><td>GC 行为</td><td>不受垃圾回收影响</td><td>Key 被回收时自动删除 Entry</td></tr><tr><td>用途</td><td>普通 Map</td><td>缓存、内存敏感对象的映射</td></tr><tr><td>面试点</td><td>WeakHashMap 如何防止内存泄漏？</td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>WeakHashMap 的 key 是 <code>WeakReference</code></li><li>当 key 不再被外部强引用时，垃圾回收器回收，并通过 ReferenceQueue 清理 Entry</li></ul><hr><h3 id="四、异常-错误处理"><a href="#四、异常-错误处理" class="headerlink" title="四、异常 &amp; 错误处理"></a>四、异常 &amp; 错误处理</h3><hr><h2 id="1-Java-中的异常分为哪两大类？"><a href="#1-Java-中的异常分为哪两大类？" class="headerlink" title="1. Java 中的异常分为哪两大类？"></a><strong>1. Java 中的异常分为哪两大类？</strong></h2><ul><li><strong>Error（错误）</strong>：<ul><li>系统级错误，通常无法恢复</li><li>例子：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li><li>不建议捕获</li></ul></li><li><strong>Exception（异常）</strong>：<ul><li>程序可以捕获、处理</li><li>子类：<ol><li><strong>受检异常（CheckedException）</strong>：必须 try&#x2F;catch 或 throws 抛出<ul><li>例子：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>非受检异常（UncheckedException &#x2F; RuntimeException）</strong>：可选择捕获<ul><li>例子：<code>NullPointerException</code>、<code>IllegalArgumentException</code></li></ul></li></ol></li></ul></li></ul><p><strong>面试点</strong>：</p><ul><li>Checked vs Unchecked 异常的设计初衷：<ul><li>Checked 异常强制处理，提高程序健壮性</li><li>RuntimeException 用于编程错误，不必强制捕获</li></ul></li></ul><hr><h2 id="2-Error-和-Exception-的区别"><a href="#2-Error-和-Exception-的区别" class="headerlink" title="2. Error 和 Exception 的区别"></a><strong>2. Error 和 Exception 的区别</strong></h2><table><thead><tr><th>特性</th><th>Error</th><th>Exception</th></tr></thead><tbody><tr><td>是否可恢复</td><td>不可恢复</td><td>可恢复（程序可处理）</td></tr><tr><td>捕获建议</td><td>不建议捕获</td><td>建议捕获和处理</td></tr><tr><td>子类示例</td><td>OutOfMemoryError</td><td>IOException, SQLException</td></tr><tr><td>使用场景</td><td>JVM 内部错误</td><td>应用程序异常处理</td></tr></tbody></table><hr><h2 id="3-受检异常和非受检异常区别"><a href="#3-受检异常和非受检异常区别" class="headerlink" title="3. 受检异常和非受检异常区别"></a><strong>3. 受检异常和非受检异常区别</strong></h2><table><thead><tr><th>特性</th><th>CheckedException</th><th>UncheckedException</th></tr></thead><tbody><tr><td>编译器检查</td><td>编译器强制要求处理</td><td>编译器不要求</td></tr><tr><td>继承关系</td><td>Exception 除 RuntimeException</td><td>RuntimeException 子类</td></tr><tr><td>使用场景</td><td>可恢复异常，如文件不存在</td><td>编程错误，如空指针</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>Checked 异常在 API 设计中可提示调用者</li><li>RuntimeException 多用于程序逻辑错误，防止过多 try&#x2F;catch</li></ul><hr><h2 id="4-throw-和-throws-的区别"><a href="#4-throw-和-throws-的区别" class="headerlink" title="4. throw 和 throws 的区别"></a><strong>4. throw 和 throws 的区别</strong></h2><table><thead><tr><th>特性</th><th>throw</th><th>throws</th></tr></thead><tbody><tr><td>位置</td><td>方法体内</td><td>方法声明上</td></tr><tr><td>用途</td><td>抛出具体异常实例</td><td>声明方法可能抛出的异常类型</td></tr><tr><td>个数限制</td><td>一次抛出一个</td><td>可声明多个异常</td></tr><tr><td>面试示例</td><td><code>throw new IOException()</code></td><td><code>void read() throws IOException</code></td></tr></tbody></table><hr><h2 id="5-try-with-resources-的底层原理"><a href="#5-try-with-resources-的底层原理" class="headerlink" title="5. try-with-resources 的底层原理"></a><strong>5. try-with-resources 的底层原理</strong></h2><ul><li><p><strong>语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>底层实现</strong>：</p><ul><li><p>自动调用资源的 <code>close()</code> 方法</p></li><li><p>资源必须实现 <strong>AutoCloseable</strong> 接口</p></li><li><p>编译器将其转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>优势</strong>：</p><ul><li>自动关闭资源，避免资源泄漏</li><li>支持多个资源声明</li></ul></li><li><p><strong>面试拓展</strong>：多资源关闭的异常抑制机制 (<code>addSuppressed</code>)</p></li></ul><hr><h2 id="6-自定义异常如何设计？继承哪个类"><a href="#6-自定义异常如何设计？继承哪个类" class="headerlink" title="6. 自定义异常如何设计？继承哪个类"></a><strong>6. 自定义异常如何设计？继承哪个类</strong></h2><ul><li><p><strong>继承 RuntimeException</strong>：</p><ul><li>用于非受检异常（编程错误、业务逻辑异常）</li></ul></li><li><p><strong>继承 Exception</strong>：</p><ul><li>用于受检异常（需要调用者处理）</li></ul></li><li><p><strong>实现建议</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>面试点</strong>：</p><ul><li>自定义异常加上异常链（cause）</li><li>规范异常信息，便于日志追踪</li></ul></li></ul><hr><h2 id="7-为什么不建议捕获-Throwable？"><a href="#7-为什么不建议捕获-Throwable？" class="headerlink" title="7. 为什么不建议捕获 Throwable？"></a><strong>7. 为什么不建议捕获 Throwable？</strong></h2><ul><li>Throwable 包含 Error 和 Exception</li><li>捕获 Throwable 会：<ul><li>捕获系统级错误（OutOfMemoryError）</li><li>破坏 JVM 正常工作</li></ul></li><li><strong>最佳实践</strong>：<ul><li>只捕获可恢复的 Exception 或 RuntimeException</li><li>捕获 Throwable 仅用于日志收集或监控</li></ul></li></ul><hr><h2 id="8-异常链（Exception-Chaining）是什么"><a href="#8-异常链（Exception-Chaining）是什么" class="headerlink" title="8. 异常链（Exception Chaining）是什么"></a><strong>8. 异常链（Exception Chaining）是什么</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>在捕获一个异常时，将原异常封装在新异常中抛出</li></ul></li><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;读取文件失败&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>保留原始异常信息</li><li>便于调试和日志追踪</li></ul></li></ul><hr><h2 id="9-Java-8-之后对异常处理的改进"><a href="#9-Java-8-之后对异常处理的改进" class="headerlink" title="9. Java 8 之后对异常处理的改进"></a><strong>9. Java 8 之后对异常处理的改进</strong></h2><ul><li><p><strong>Lambda 表达式</strong>：</p><ul><li>对受检异常的处理更加简洁，但需要特殊处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; process(item); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Optional &amp; Streams</strong>：</p><ul><li>避免空指针异常</li><li>可以在 <code>map</code>&#x2F;<code>filter</code> 中处理异常</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>异常在并行 Stream 中如何传递</li><li><code>CompletableFuture</code> 异常处理</li></ul></li></ul><hr><h2 id="10-多线程环境下如何正确传递异常"><a href="#10-多线程环境下如何正确传递异常" class="headerlink" title="10. 多线程环境下如何正确传递异常"></a><strong>10. 多线程环境下如何正确传递异常</strong></h2><ul><li><p><strong>问题</strong>：</p><ul><li>子线程异常不会直接抛给主线程</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><p><strong>Future &#x2F; Callable</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>); &#125;);</span><br><span class="line">future.get(); <span class="comment">// 会抛 ExecutionException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Thread.UncaughtExceptionHandler</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler((t, e) -&gt; log.error(<span class="string">&quot;线程异常&quot;</span>, e));</span><br></pre></td></tr></table></figure></li><li><p><strong>CompletableFuture.exceptionally</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); &#125;)</span><br><span class="line">                 .exceptionally(ex -&gt; &#123; log.error(ex); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>面试拓展</strong>：</p><ul><li>如何处理线程池中未捕获异常</li><li>异步任务异常链追踪</li></ul></li></ul><hr><h3 id="五、JVM-内存管理"><a href="#五、JVM-内存管理" class="headerlink" title="五、JVM &amp; 内存管理"></a>五、JVM &amp; 内存管理</h3><hr><h2 id="1-Java-内存模型（JMM）是什么？"><a href="#1-Java-内存模型（JMM）是什么？" class="headerlink" title="1. Java 内存模型（JMM）是什么？"></a><strong>1. Java 内存模型（JMM）是什么？</strong></h2><ul><li><strong>定义</strong>：<ul><li>Java 内存模型（Java Memory Model，JMM）是 Java 虚拟机规范中定义的一套规范，用于描述 <strong>Java 程序中各个线程如何访问共享内存以及如何保证可见性、原子性、有序性</strong>。</li></ul></li><li><strong>核心作用</strong>：<ol><li><strong>解决多线程可见性问题</strong></li><li><strong>规定内存操作顺序</strong>（happens-before 原则）</li><li><strong>定义变量访问原子性</strong></li></ol></li><li><strong>关键概念</strong>：<ul><li><strong>主内存（Main Memory）</strong>：共享变量存储位置</li><li><strong>工作内存（Working Memory &#x2F; Thread Local Cache）</strong>：线程私有缓存</li><li><strong>volatile、synchronized、final</strong> 的语义保证不同层次的可见性和原子性</li></ul></li></ul><hr><h2 id="2-JVM-内存分为哪几个区域？每个区域的作用是什么？"><a href="#2-JVM-内存分为哪几个区域？每个区域的作用是什么？" class="headerlink" title="2. JVM 内存分为哪几个区域？每个区域的作用是什么？"></a><strong>2. JVM 内存分为哪几个区域？每个区域的作用是什么？</strong></h2><ol><li><strong>程序计数器（PC Register）</strong><ul><li>每个线程私有</li><li>保存当前线程执行的字节码指令地址</li><li>支持线程切换和方法调用返回</li></ul></li><li><strong>虚拟机栈（Stack）</strong><ul><li>每个线程私有</li><li>存储局部变量、操作栈、动态链接信息、方法出口</li><li>栈帧：方法执行的最小单位</li><li>异常：StackOverflowError</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong><ul><li>JVM 调用本地方法（C&#x2F;C++实现）使用</li><li>HotSpot 通常与虚拟机栈合并</li></ul></li><li><strong>堆（Heap）</strong><ul><li>所有线程共享</li><li>存储对象实例及数组</li><li>垃圾收集的主要区域</li><li>子区域：<ul><li><strong>年轻代（Young Generation）</strong>：Eden + Survivor0 + Survivor1</li><li><strong>老年代（Old Generation）</strong></li><li><strong>元空间（Metaspace &#x2F; 方法区）</strong>：存放类元信息</li></ul></li></ul></li><li><strong>方法区（Metaspace &#x2F; 以前称为 PermGen）</strong><ul><li>存储类信息、常量池、静态变量</li><li>Metaspace 从本地内存分配（不再受 JVM 堆大小限制）</li></ul></li><li><strong>运行时常量池</strong><ul><li>类加载时生成</li><li>存放字面量、符号引用、字符串常量等</li></ul></li></ol><hr><h2 id="3-为什么-String-常量池要放在堆里而不是方法区？"><a href="#3-为什么-String-常量池要放在堆里而不是方法区？" class="headerlink" title="3. 为什么 String 常量池要放在堆里而不是方法区？"></a><strong>3. 为什么 String 常量池要放在堆里而不是方法区？</strong></h2><ul><li><strong>历史原因</strong>：<ul><li>JDK 1.6 及以前：字符串常量池在永久代（PermGen），易导致 OOM</li></ul></li><li><strong>现代实现</strong>：<ul><li>JDK 7+ 将常量池移到堆</li></ul></li><li><strong>优势</strong>：<ol><li>垃圾回收可管理</li><li>内存分配灵活，避免方法区溢出</li><li>多线程访问安全性提升（与堆对象 GC 同步）</li></ol></li></ul><hr><h2 id="4-什么是垃圾回收（GC）的可达性分析算法？"><a href="#4-什么是垃圾回收（GC）的可达性分析算法？" class="headerlink" title="4. 什么是垃圾回收（GC）的可达性分析算法？"></a><strong>4. 什么是垃圾回收（GC）的可达性分析算法？</strong></h2><ul><li><p><strong>可达性分析（Reachability Analysis）</strong>：</p><ul><li>从 <strong>GC Roots</strong> 开始，通过引用链判断对象是否可达</li><li><strong>不可达对象</strong>即为垃圾，可以回收</li></ul></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC Roots</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">Object A --&gt; Object B</span><br></pre></td></tr></table></figure><ul><li>如果 Object B 无法通过 GC Roots 访问，则被回收</li></ul></li></ul><hr><h2 id="5-哪些对象可以作为-GC-Roots？"><a href="#5-哪些对象可以作为-GC-Roots？" class="headerlink" title="5. 哪些对象可以作为 GC Roots？"></a><strong>5. 哪些对象可以作为 GC Roots？</strong></h2><p>常见 GC Roots：</p><ol><li><strong>虚拟机栈中的引用</strong>（局部变量、方法参数）</li><li><strong>静态变量</strong>（类静态成员）</li><li><strong>常量引用</strong>（常量池引用）</li><li><strong>JNI 引用</strong>（本地方法栈中的引用）</li></ol><hr><h2 id="6-强引用、软引用、弱引用、虚引用的区别"><a href="#6-强引用、软引用、弱引用、虚引用的区别" class="headerlink" title="6. 强引用、软引用、弱引用、虚引用的区别"></a><strong>6. 强引用、软引用、弱引用、虚引用的区别</strong></h2><table><thead><tr><th>类型</th><th>特点</th><th>GC 行为</th><th>面试应用</th></tr></thead><tbody><tr><td>强引用（Strong Reference）</td><td>普通对象引用</td><td>不可回收</td><td>普通对象</td></tr><tr><td>软引用（Soft Reference）</td><td>通过 SoftReference 引用</td><td>内存不足时回收</td><td>缓存（Memory-sensitive cache）</td></tr><tr><td>弱引用（Weak Reference）</td><td>WeakReference 引用</td><td>GC 时立即回收</td><td>ThreadLocal 清理、缓存</td></tr><tr><td>虚引用（Phantom Reference）</td><td>PhantomReference 引用</td><td>仅做引用队列通知</td><td>对象回收前做清理、资源释放</td></tr></tbody></table><hr><h2 id="7-GC-算法"><a href="#7-GC-算法" class="headerlink" title="7. GC 算法"></a><strong>7. GC 算法</strong></h2><ol><li><strong>标记-清除（Mark-Sweep）</strong><ul><li>标记可达对象，清除未标记对象</li><li>优点：简单</li><li>缺点：产生碎片</li></ul></li><li><strong>标记-整理（Mark-Compact）</strong><ul><li>标记可达对象</li><li>将存活对象移动到一端</li><li>优点：解决碎片问题</li><li>缺点：移动对象成本高</li></ul></li><li><strong>复制算法（Copying）</strong><ul><li>将内存分为两块</li><li>将存活对象复制到另一块，清理旧块</li><li>优点：分配快，整理快</li><li>缺点：内存利用率低</li></ul></li></ol><hr><h2 id="8-常见的垃圾收集器"><a href="#8-常见的垃圾收集器" class="headerlink" title="8. 常见的垃圾收集器"></a><strong>8. 常见的垃圾收集器</strong></h2><table><thead><tr><th>垃圾收集器</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td>Serial GC</td><td>单核</td><td>STW 串行，简单、高吞吐量低</td></tr><tr><td>Parallel GC</td><td>多核</td><td>并行回收年轻代，高吞吐量</td></tr><tr><td>CMS GC</td><td>多核</td><td>并发回收老年代，减少 STW</td></tr><tr><td>G1 GC</td><td>大堆</td><td>分区回收，低延迟，预测停顿</td></tr><tr><td>ZGC</td><td>超大堆</td><td>并发标记-清理，低延迟</td></tr><tr><td>Shenandoah</td><td>大堆</td><td>并发标记-整理，减少 STW</td></tr></tbody></table><hr><h2 id="9-什么是-Stop-The-World-STW-？"><a href="#9-什么是-Stop-The-World-STW-？" class="headerlink" title="9. 什么是 Stop-The-World (STW)？"></a><strong>9. 什么是 Stop-The-World (STW)？</strong></h2><ul><li><strong>定义</strong>：JVM 暂停所有应用线程执行，专门进行 GC</li><li><strong>原因</strong>：<ul><li>防止对象被修改导致回收错误</li></ul></li><li><strong>面试拓展</strong>：<ul><li>G1&#x2F;ZGC&#x2F;Shenandoah 尽量缩短 STW 时间</li><li>并发 GC 与 STW 的折中</li></ul></li></ul><hr><h2 id="10-JVM-调优常见参数"><a href="#10-JVM-调优常见参数" class="headerlink" title="10. JVM 调优常见参数"></a><strong>10. JVM 调优常见参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-Xmx</code></td><td>最大堆大小</td></tr><tr><td><code>-Xms</code></td><td>初始堆大小</td></tr><tr><td><code>-Xmn</code></td><td>年轻代大小</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden&#x2F;Survivor 比例</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 GC</td></tr><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>最大停顿时间</td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>打印 GC 日志</td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时生成堆转储</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何调优老年代和年轻代比例？</li><li>GC 日志分析示例：年轻代满、老年代晋升、STW 停顿</li></ul><hr><h3 id="六、并发编程基础"><a href="#六、并发编程基础" class="headerlink" title="六、并发编程基础"></a>六、并发编程基础</h3><hr><h2 id="1-Java-中的-volatile-关键字的底层实现原理"><a href="#1-Java-中的-volatile-关键字的底层实现原理" class="headerlink" title="1. Java 中的 volatile 关键字的底层实现原理"></a><strong>1. Java 中的 volatile 关键字的底层实现原理</strong></h2><ul><li><strong>作用</strong>：<ol><li><strong>保证可见性</strong>：一个线程修改变量后，其他线程立即可见</li><li><strong>禁止指令重排</strong>：保证顺序性</li></ol></li><li><strong>原理</strong>：<ul><li>底层通过 <strong>内存屏障（Memory Barrier &#x2F; Fence）</strong> 实现</li><li><code>volatile</code> 读操作：<ul><li>加载屏障（LoadLoad + LoadStore）</li></ul></li><li><code>volatile</code> 写操作：<ul><li>写屏障（StoreStore + StoreLoad）</li></ul></li></ul></li><li><strong>注意</strong>：<ul><li>不能保证 <strong>原子性</strong></li><li>适合 <strong>状态标识、开关变量</strong></li></ul></li></ul><hr><h2 id="2-synchronized-的实现原理"><a href="#2-synchronized-的实现原理" class="headerlink" title="2. synchronized 的实现原理"></a><strong>2. synchronized 的实现原理</strong></h2><ul><li><strong>作用</strong>：<ul><li>保证 <strong>互斥访问</strong></li><li>保证 <strong>可见性</strong></li></ul></li><li><strong>底层机制</strong>：<ul><li>Java 对象头包含 <strong>Mark Word</strong></li><li>每个对象可以关联一个 <strong>Monitor</strong></li><li><strong>Monitor</strong> 用于管理线程的加锁、阻塞、唤醒</li></ul></li><li><strong>锁升级流程</strong>：<ol><li><strong>偏向锁</strong>（默认轻量级线程无竞争）</li><li><strong>轻量级锁</strong>（CAS 竞争，膨胀前）</li><li><strong>重量级锁</strong>（锁膨胀，阻塞其他线程）</li></ol></li></ul><hr><h2 id="3-偏向锁、轻量级锁、重量级锁"><a href="#3-偏向锁、轻量级锁、重量级锁" class="headerlink" title="3. 偏向锁、轻量级锁、重量级锁"></a><strong>3. 偏向锁、轻量级锁、重量级锁</strong></h2><table><thead><tr><th>锁类型</th><th>适用场景</th><th>实现方式</th><th>优缺点</th></tr></thead><tbody><tr><td>偏向锁</td><td>单线程</td><td>在对象头标记线程 ID</td><td>减少无竞争开销</td></tr><tr><td>轻量级锁</td><td>多线程竞争轻量</td><td>CAS 自旋 + 栈记录锁</td><td>高效，避免阻塞</td></tr><tr><td>重量级锁</td><td>多线程竞争严重</td><td>Monitor + 阻塞</td><td>开销大，可能 STW</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何通过 <code>-XX:+PrintFlagsFinal</code> 查看锁标志位</li><li>偏向锁默认延迟 4 秒启用</li></ul><hr><h2 id="4-什么是-CAS-操作？ABA-问题如何解决？"><a href="#4-什么是-CAS-操作？ABA-问题如何解决？" class="headerlink" title="4. 什么是 CAS 操作？ABA 问题如何解决？"></a><strong>4. 什么是 CAS 操作？ABA 问题如何解决？</strong></h2><ul><li><p><strong>CAS（Compare-And-Swap）</strong>：</p><ul><li>原子操作</li><li>比较内存值是否为预期值，如果是就更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V, A, B)</span><br></pre></td></tr></table></figure></li><li><p><strong>ABA 问题</strong>：</p><ul><li>值先从 A 改成 B，又改回 A</li><li>CAS 无法检测变化，可能出错</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>版本号机制</strong>（AtomicStampedReference）</li><li><strong>加锁</strong></li></ol></li></ul><hr><h2 id="5-什么是线程安全？举例线程安全类"><a href="#5-什么是线程安全？举例线程安全类" class="headerlink" title="5. 什么是线程安全？举例线程安全类"></a><strong>5. 什么是线程安全？举例线程安全类</strong></h2><ul><li><strong>定义</strong>：多个线程访问同一个对象时，不会破坏对象的状态，并保证正确性</li><li><strong>线程安全类示例</strong>：<ul><li>集合类：<code>Vector</code>, <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code></li><li>原子类：<code>AtomicInteger</code>, <code>AtomicReference</code></li><li>工具类：<code>ThreadLocal</code>, <code>BlockingQueue</code></li></ul></li></ul><hr><h2 id="6-ThreadLocal-的底层原理与内存泄漏问题"><a href="#6-ThreadLocal-的底层原理与内存泄漏问题" class="headerlink" title="6. ThreadLocal 的底层原理与内存泄漏问题"></a><strong>6. ThreadLocal 的底层原理与内存泄漏问题</strong></h2><ul><li><strong>原理</strong>：<ul><li>每个线程维护一个 <code>ThreadLocalMap</code></li><li>key 是 <strong>ThreadLocal 对象</strong></li><li>value 是对应的值</li></ul></li><li><strong>内存泄漏原因</strong>：<ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong></li><li>如果 ThreadLocal 对象被回收，但线程仍存活，value 仍然存在</li></ul></li><li><strong>解决方法</strong>：<ul><li>使用 <code>remove()</code> 方法</li><li>避免长生命周期线程存储大量 ThreadLocal</li></ul></li></ul><hr><h2 id="7-线程池的核心参数"><a href="#7-线程池的核心参数" class="headerlink" title="7. 线程池的核心参数"></a><strong>7. 线程池的核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数，常驻线程</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程空闲存活时间</td></tr><tr><td>workQueue</td><td>等待队列，用于存放任务</td></tr><tr><td>threadFactory</td><td>线程创建工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="8-什么是拒绝策略"><a href="#8-什么是拒绝策略" class="headerlink" title="8. 什么是拒绝策略"></a><strong>8. 什么是拒绝策略</strong></h2><ul><li><strong>触发场景</strong>：线程池满了，队列满了</li><li><strong>常见策略</strong>：<ol><li><strong>AbortPolicy</strong>：抛异常，默认</li><li><strong>CallerRunsPolicy</strong>：由调用线程执行任务</li><li><strong>DiscardPolicy</strong>：直接丢弃任务</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中最旧任务</li></ol></li></ul><hr><h2 id="9-Executors-提供的常见线程池"><a href="#9-Executors-提供的常见线程池" class="headerlink" title="9. Executors 提供的常见线程池"></a><strong>9. Executors 提供的常见线程池</strong></h2><table><thead><tr><th>线程池类型</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>FixedThreadPool</td><td>固定线程数</td><td>CPU密集型任务</td></tr><tr><td>CachedThreadPool</td><td>可扩容线程池</td><td>短生命周期任务</td></tr><tr><td>SingleThreadExecutor</td><td>单线程顺序执行</td><td>顺序任务</td></tr><tr><td>ScheduledThreadPool</td><td>支持定时&#x2F;周期执行</td><td>定时任务</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>Executors.newFixedThreadPool 会使用 <strong>LinkedBlockingQueue</strong></li><li>CachedThreadPool 使用 <strong>SynchronousQueue</strong>，任务直接交给线程</li></ul><hr><h2 id="10-Future-和-CompletableFuture-区别"><a href="#10-Future-和-CompletableFuture-区别" class="headerlink" title="10. Future 和 CompletableFuture 区别"></a><strong>10. Future 和 CompletableFuture 区别</strong></h2><table><thead><tr><th>特性</th><th>Future</th><th>CompletableFuture</th></tr></thead><tbody><tr><td>异步</td><td>提交任务后可阻塞获取结果</td><td>可链式异步操作</td></tr><tr><td>API</td><td>get() 阻塞</td><td>thenApply, thenAccept 等链式</td></tr><tr><td>异常处理</td><td>阻塞式，捕获 ExecutionException</td><td>支持 exceptionally&#x2F;handle</td></tr><tr><td>组合任务</td><td>组合困难</td><td>支持 allOf &#x2F; anyOf &#x2F; thenCombine</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>CompletableFuture 适合多异步任务组合</li><li>FutureTask 可作为 Future 的实现类</li></ul><hr><h3 id="七、编译-运行时"><a href="#七、编译-运行时" class="headerlink" title="七、编译 &amp; 运行时"></a>七、编译 &amp; 运行时</h3><hr><h2 id="1-Java-的反射机制是什么？底层原理？"><a href="#1-Java-的反射机制是什么？底层原理？" class="headerlink" title="1. Java 的反射机制是什么？底层原理？"></a><strong>1. Java 的反射机制是什么？底层原理？</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>反射机制允许在运行时 <strong>获取类的信息、实例化对象、访问字段和方法</strong>，而不需要在编译期知道具体类型</li></ul></li><li><p><strong>常用 API</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">method.invoke(obj, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>底层原理</strong>：</p><ul><li>JVM 中类对象 <code>Class</code> 对应内存中的元数据（方法表、字段表、常量池）</li><li>通过 <strong>Native 方法</strong> 调用，访问类的元数据和对象实例</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>反射可访问私有字段&#x2F;方法（<code>setAccessible(true)</code>）</li><li>反射适用于框架（Spring、MyBatis）</li></ul></li></ul><hr><h2 id="2-为什么反射性能差？JDK-9-之后如何优化？"><a href="#2-为什么反射性能差？JDK-9-之后如何优化？" class="headerlink" title="2. 为什么反射性能差？JDK 9 之后如何优化？"></a><strong>2. 为什么反射性能差？JDK 9 之后如何优化？</strong></h2><ul><li><strong>性能差原因</strong>：<ol><li>每次访问方法&#x2F;字段都要进行动态解析</li><li>JVM 无法做内联优化（方法调用不是静态绑定）</li><li>需要检查权限、类型转换</li></ol></li><li><strong>优化措施</strong>：<ul><li><strong>JDK 7 及以后</strong>：<code>MethodHandle</code> 和 <code>invokeDynamic</code></li><li><strong>JDK 9+</strong>：增强模块化（模块边界检查优化）</li><li><strong>热点编译器 JIT</strong> 可以对反射调用做内联</li></ul></li></ul><hr><h2 id="3-什么是动态代理？JDK-动态代理和-CGLIB-区别？"><a href="#3-什么是动态代理？JDK-动态代理和-CGLIB-区别？" class="headerlink" title="3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？"></a><strong>3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？</strong></h2><ul><li><p><strong>动态代理</strong>：</p><ul><li>在运行时生成代理对象，拦截方法调用，增强行为</li></ul></li><li><p><strong>JDK 动态代理</strong>：</p><ul><li>基于接口</li><li>使用 <code>Proxy.newProxyInstance</code></li><li>通过 <code>InvocationHandler.invoke</code> 调用</li></ul></li><li><p><strong>CGLIB</strong>：</p><ul><li>基于子类继承（无接口也可代理）</li><li>使用 ASM 字节码生成子类</li><li>注意 final 类&#x2F;方法不能被代理</li></ul></li><li><p><strong>对比</strong>：</p><table><thead><tr><th>特性</th><th>JDK 动态代理</th><th>CGLIB</th></tr></thead><tbody><tr><td>是否需要接口</td><td>必须</td><td>不需要</td></tr><tr><td>原理</td><td>Proxy + InvocationHandler</td><td>ASM 字节码生成子类</td></tr><tr><td>性能</td><td>略慢</td><td>较快</td></tr><tr><td>局限性</td><td>无</td><td>final 类&#x2F;方法不可代理</td></tr></tbody></table></li></ul><hr><h2 id="4-注解的底层原理是什么？运行时注解如何实现？"><a href="#4-注解的底层原理是什么？运行时注解如何实现？" class="headerlink" title="4. 注解的底层原理是什么？运行时注解如何实现？"></a><strong>4. 注解的底层原理是什么？运行时注解如何实现？</strong></h2><ul><li><strong>概念</strong>：<ul><li>注解是一种 <strong>元数据</strong>，用于给类、方法、字段等提供信息</li></ul></li><li><strong>底层原理</strong>：<ul><li>编译时生成 <code>.class</code> 文件中 <code>RuntimeVisibleAnnotations</code> 属性</li><li>JVM 通过 <code>java.lang.reflect.AnnotatedElement</code> 获取</li></ul></li><li><strong>运行时注解</strong>：<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code></li><li>通过反射 API 读取注解并执行逻辑</li></ul></li><li><strong>应用场景</strong>：<ul><li>Spring 注解（<code>@Autowired</code>、<code>@Service</code>）</li><li>JPA 注解（<code>@Entity</code>、<code>@Column</code>）</li></ul></li></ul><hr><h2 id="5-ClassLoader-的双亲委派模型是什么？"><a href="#5-ClassLoader-的双亲委派模型是什么？" class="headerlink" title="5. ClassLoader 的双亲委派模型是什么？"></a><strong>5. ClassLoader 的双亲委派模型是什么？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>当类加载请求到来时，<strong>先委托父 ClassLoader 加载</strong></li><li>如果父 ClassLoader 加载失败，再由子 ClassLoader 加载</li></ul></li><li><p><strong>优点</strong>：</p><ol><li>避免重复加载</li><li>保证核心类（如 <code>java.lang.*</code>）唯一性</li></ol></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap -&gt; Extension -&gt; App -&gt; Custom</span><br></pre></td></tr></table></figure></li><li><p><strong>面试拓展</strong>：</p><ul><li>双亲委派模型是保证 JVM 核心类安全的重要机制</li></ul></li></ul><hr><h2 id="6-如何打破双亲委派？"><a href="#6-如何打破双亲委派？" class="headerlink" title="6. 如何打破双亲委派？"></a><strong>6. 如何打破双亲委派？</strong></h2><ul><li>自定义 ClassLoader</li><li>在 <code>loadClass</code> 中先加载自己定义的类，再委派父类（逆向委派）</li><li>注意：破坏双亲委派可能引发类冲突、内存泄漏</li></ul><hr><h2 id="7-什么是-SPI（Service-Provider-Interface）机制？"><a href="#7-什么是-SPI（Service-Provider-Interface）机制？" class="headerlink" title="7. 什么是 SPI（Service Provider Interface）机制？"></a><strong>7. 什么是 SPI（Service Provider Interface）机制？</strong></h2><ul><li><strong>概念</strong>：<ul><li>Java 提供的一种服务发现机制</li><li>通过接口 + 配置文件，动态加载实现类</li></ul></li><li><strong>实现</strong>：<ol><li>接口 <code>MyService</code></li><li>文件 <code>META-INF/services/com.example.MyService</code><ul><li>内容：实现类全限定名</li></ul></li><li><code>ServiceLoader.load(MyService.class)</code> 自动加载实现类</li></ol></li><li><strong>应用</strong>：<ul><li>JDBC 驱动加载</li><li>Logging 框架（SLF4J）</li></ul></li></ul><hr><h2 id="8-Java-是如何实现跨平台的？"><a href="#8-Java-是如何实现跨平台的？" class="headerlink" title="8. Java 是如何实现跨平台的？"></a><strong>8. Java 是如何实现跨平台的？</strong></h2><ul><li><strong>原理</strong>：<ol><li>Java 代码 -&gt; 编译成 <strong>字节码（.class）</strong></li><li>JVM 负责字节码解释或即时编译（JIT）执行</li><li>JVM 将字节码映射到不同操作系统和 CPU</li></ol></li><li><strong>面试拓展</strong>：<ul><li>字节码验证机制确保安全性</li><li>HotSpot JIT 提供本地优化</li></ul></li></ul><hr><h2 id="9-JIT（即时编译器）优化了哪些东西？"><a href="#9-JIT（即时编译器）优化了哪些东西？" class="headerlink" title="9. JIT（即时编译器）优化了哪些东西？"></a><strong>9. JIT（即时编译器）优化了哪些东西？</strong></h2><ul><li><strong>JIT（Just-In-Time Compiler）</strong>：<ul><li>将热点字节码动态编译成本地机器码</li></ul></li><li><strong>优化策略</strong>：<ol><li><strong>方法内联</strong>：减少方法调用开销</li><li><strong>循环优化</strong>：消除冗余计算</li><li><strong>逃逸分析</strong>：栈上分配对象</li><li><strong>锁消除&#x2F;锁粗化</strong>：减少锁开销</li><li><strong>指令重排序优化</strong></li></ol></li></ul><hr><h2 id="10-什么是逃逸分析？"><a href="#10-什么是逃逸分析？" class="headerlink" title="10. 什么是逃逸分析？"></a><strong>10. 什么是逃逸分析？</strong></h2><ul><li><strong>概念</strong>：<ul><li>分析对象的引用范围</li><li>判断对象是否“逃逸”出方法或线程</li></ul></li><li><strong>优化应用</strong>：<ol><li><strong>栈上分配</strong>：对象不逃逸可以直接分配在栈上</li><li><strong>标量替换</strong>：将对象拆解为基本类型，提高缓存命中</li><li><strong>锁消除</strong>：对象不逃逸，synchronized 可被消除</li></ol></li><li><strong>面试拓展</strong>：<ul><li>JIT 结合逃逸分析可显著提升性能</li><li>适用于短生命周期对象</li></ul></li></ul><hr><h3 id="八、常见场景-设计"><a href="#八、常见场景-设计" class="headerlink" title="八、常见场景 &amp; 设计"></a>八、常见场景 &amp; 设计</h3><hr><h2 id="1-单例模式在-Java-中有哪些实现方式？哪种最优？"><a href="#1-单例模式在-Java-中有哪些实现方式？哪种最优？" class="headerlink" title="1. 单例模式在 Java 中有哪些实现方式？哪种最优？"></a><strong>1. 单例模式在 Java 中有哪些实现方式？哪种最优？</strong></h2><ul><li><p><strong>常见实现方式</strong>：</p><ol><li><p><strong>饿汉式（静态常量）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，简单</li><li>缺点：类加载即初始化，不支持延迟加载</li></ul></li><li><p><strong>懒汉式（加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：支持延迟加载</li><li>缺点：每次访问都有同步开销</li></ul></li><li><p><strong>双重检查锁（Double-Checked Locking）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全 + 延迟加载 + 高性能</li><li><strong>推荐</strong></li></ul></li><li><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> Holder.INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证类加载线程安全</li><li>优点：懒加载 + 高性能</li><li><strong>最佳实践之一</strong></li></ul></li><li><p><strong>枚举单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123; INSTANCE; &#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证枚举类型单例</li><li>优点：线程安全、防止反射和序列化破坏</li><li><strong>最佳实践</strong></li></ul></li></ol></li></ul><hr><h2 id="2-懒汉模式和饿汉模式的区别"><a href="#2-懒汉模式和饿汉模式的区别" class="headerlink" title="2. 懒汉模式和饿汉模式的区别"></a><strong>2. 懒汉模式和饿汉模式的区别</strong></h2><table><thead><tr><th>特性</th><th>懒汉模式</th><th>饿汉模式</th></tr></thead><tbody><tr><td>加载时机</td><td>延迟加载，第一次使用</td><td>类加载即初始化</td></tr><tr><td>线程安全</td><td>需加锁&#x2F;双重检查</td><td>天然线程安全</td></tr><tr><td>性能</td><td>多线程同步有开销</td><td>无额外开销</td></tr><tr><td>内存使用</td><td>按需分配</td><td>类加载时分配</td></tr></tbody></table><hr><h2 id="3-枚举单例为什么是最佳实践"><a href="#3-枚举单例为什么是最佳实践" class="headerlink" title="3. 枚举单例为什么是最佳实践"></a><strong>3. 枚举单例为什么是最佳实践</strong></h2><ul><li>JVM 保证枚举实例唯一性</li><li><strong>防止反射和序列化破坏</strong></li><li>实现简洁，无需手动同步</li><li>面试常考点：相比双重检查锁更安全</li></ul><hr><h2 id="4-为什么要用工厂模式？"><a href="#4-为什么要用工厂模式？" class="headerlink" title="4. 为什么要用工厂模式？"></a><strong>4. 为什么要用工厂模式？</strong></h2><ul><li><strong>作用</strong>：<ul><li>隐藏对象创建逻辑</li><li>解耦调用方和实现类</li></ul></li><li><strong>类型</strong>：<ol><li><strong>简单工厂</strong>：静态方法返回对象</li><li><strong>工厂方法</strong>：子类决定创建哪种对象</li><li><strong>抽象工厂</strong>：一组相关对象的创建</li></ol></li><li><strong>优势</strong>：<ul><li>可扩展性高</li><li>符合开闭原则</li></ul></li></ul><hr><h2 id="5-装饰器模式和代理模式区别"><a href="#5-装饰器模式和代理模式区别" class="headerlink" title="5. 装饰器模式和代理模式区别"></a><strong>5. 装饰器模式和代理模式区别</strong></h2><table><thead><tr><th>特性</th><th>装饰器模式</th><th>代理模式</th></tr></thead><tbody><tr><td>目的</td><td>动态增强对象功能</td><td>控制对象访问</td></tr><tr><td>结构</td><td>包装原对象，继承接口</td><td>持有原对象，方法委托</td></tr><tr><td>场景</td><td>IO 流（BufferedReader）</td><td>远程调用、权限控制</td></tr><tr><td>动态性</td><td>高</td><td>可以通过动态代理实现</td></tr></tbody></table><hr><h2 id="6-Java-中的事件监听模型是怎么实现的？"><a href="#6-Java-中的事件监听模型是怎么实现的？" class="headerlink" title="6. Java 中的事件监听模型是怎么实现的？"></a><strong>6. Java 中的事件监听模型是怎么实现的？</strong></h2><ul><li><strong>机制</strong>：<ol><li><strong>事件源（Event Source）</strong>：产生事件</li><li><strong>事件监听器（Listener）</strong>：接口，定义回调方法</li><li><strong>注册与触发</strong>：源对象维护监听器列表，事件发生时通知监听器</li></ol></li><li><strong>典型应用</strong>：<ul><li>Swing&#x2F;AWT 事件</li><li>Spring ApplicationEvent</li></ul></li></ul><hr><h2 id="7-为什么-Java-不支持多继承？"><a href="#7-为什么-Java-不支持多继承？" class="headerlink" title="7. 为什么 Java 不支持多继承？"></a><strong>7. 为什么 Java 不支持多继承？</strong></h2><ul><li><strong>原因</strong>：<ul><li>避免 <strong>钻石问题</strong>（多继承产生方法冲突）</li><li>简化对象模型，保证 JVM 类型安全</li></ul></li><li><strong>替代方案</strong>：<ul><li>接口多继承 + 默认方法（Java 8+）</li><li>组合设计模式（优先使用 has-a 而不是 is-a）</li></ul></li></ul><hr><h2 id="8-如何用-Java-实现回调机制？"><a href="#8-如何用-Java-实现回调机制？" class="headerlink" title="8. 如何用 Java 实现回调机制？"></a><strong>8. 如何用 Java 实现回调机制？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>将函数封装成对象或接口传递给另一个对象</li><li>由被调用对象在合适时机调用接口方法</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123; <span class="keyword">void</span> <span class="title function_">onDone</span><span class="params">(String result)</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">asyncProcess</span><span class="params">(Callback callback)</span> &#123; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; callback.onDone(<span class="string">&quot;ok&quot;</span>)).start(); &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="9-Java-中如何实现观察者模式？"><a href="#9-Java-中如何实现观察者模式？" class="headerlink" title="9. Java 中如何实现观察者模式？"></a><strong>9. Java 中如何实现观察者模式？</strong></h2><ul><li><p><strong>机制</strong>：</p><ol><li><strong>Subject（被观察者）</strong>：维护观察者列表，提供注册&#x2F;注销方法</li><li><strong>Observer（观察者）</strong>：接口，定义 update 方法</li><li><strong>触发事件</strong>：Subject 状态变化时调用所有 Observer 的 update</li></ol></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123; observers.add(o); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.update(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="10-Optional-的设计初衷是什么？"><a href="#10-Optional-的设计初衷是什么？" class="headerlink" title="10. Optional 的设计初衷是什么？"></a><strong>10. Optional 的设计初衷是什么？</strong></h2><ul><li><p><strong>目的</strong>：</p><ul><li>避免 null 值导致的 <strong>NullPointerException</strong></li><li>提供函数式 API，提高可读性</li></ul></li><li><p><strong>使用方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(getValue());</span><br><span class="line">optional.ifPresent(System.out::println);</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> optional.orElse(<span class="string">&quot;default&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>显示处理缺失值</li><li>支持链式调用、函数式风格</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>Optional 不适合用于集合属性，避免滥用</li></ul></li></ul><hr><h2 id="二、Java-并发编程（30题）"><a href="#二、Java-并发编程（30题）" class="headerlink" title="二、Java 并发编程（30题）"></a>二、Java 并发编程（30题）</h2><hr><h2 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1. 线程的生命周期"></a><strong>1. 线程的生命周期</strong></h2><ul><li><strong>状态</strong>：<ol><li><strong>NEW</strong>：创建后，未调用 <code>start()</code></li><li><strong>RUNNABLE</strong>：调用 <code>start()</code>，可运行（线程调度器决定何时执行）</li><li><strong>BLOCKED</strong>：等待锁</li><li><strong>WAITING</strong>：无限期等待（<code>Object.wait()</code> &#x2F; <code>LockSupport.park()</code>）</li><li><strong>TIMED_WAITING</strong>：超时等待（<code>sleep()</code>, <code>join(timeout)</code>）</li><li><strong>TERMINATED</strong>：执行完毕</li></ol></li></ul><hr><h2 id="2-创建线程的方式"><a href="#2-创建线程的方式" class="headerlink" title="2. 创建线程的方式"></a><strong>2. 创建线程的方式</strong></h2><ol><li><strong>继承 Thread 类</strong></li><li><strong>实现 Runnable 接口</strong></li><li><strong>实现 Callable + FutureTask</strong></li><li><strong>线程池（推荐）</strong></li></ol><hr><h2 id="3-Runnable-和-Callable-区别"><a href="#3-Runnable-和-Callable-区别" class="headerlink" title="3. Runnable 和 Callable 区别"></a><strong>3. Runnable 和 Callable 区别</strong></h2><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无</td><td>可以有返回值</td></tr><tr><td>异常</td><td>不可抛出检查异常</td><td>可以抛出异常</td></tr><tr><td>执行方式</td><td>new Thread(runnable)</td><td>ExecutorService.submit(callable)</td></tr></tbody></table><hr><h2 id="4-Future-和-CompletableFuture-区别"><a href="#4-Future-和-CompletableFuture-区别" class="headerlink" title="4. Future 和 CompletableFuture 区别"></a><strong>4. Future 和 CompletableFuture 区别</strong></h2><ul><li><strong>Future</strong>：<ul><li>阻塞式获取结果</li><li>不支持链式异步处理</li></ul></li><li><strong>CompletableFuture</strong>：<ul><li>支持链式异步处理（thenApply, thenCombine, exceptionally）</li><li>可组合多个异步任务</li></ul></li></ul><hr><h2 id="5-ThreadLocal-原理"><a href="#5-ThreadLocal-原理" class="headerlink" title="5. ThreadLocal 原理"></a><strong>5. ThreadLocal 原理</strong></h2><ul><li>每个线程持有一个 <strong>ThreadLocalMap</strong></li><li>key 是 <strong>ThreadLocal 对象</strong>，value 是线程私有变量</li><li>内存泄漏风险：<ul><li>ThreadLocal 弱引用被 GC，value 没有被回收</li></ul></li><li>解决方法：<ul><li>使用 <code>remove()</code> 清理</li></ul></li></ul><hr><h2 id="6-synchronized-的锁优化机制"><a href="#6-synchronized-的锁优化机制" class="headerlink" title="6. synchronized 的锁优化机制"></a><strong>6. synchronized 的锁优化机制</strong></h2><ol><li><strong>偏向锁</strong>：减少无竞争开销</li><li><strong>轻量级锁</strong>：CAS + 自旋</li><li><strong>重量级锁</strong>：Monitor 阻塞线程</li><li><strong>锁消除&#x2F;锁粗化</strong>：JIT 优化</li></ol><hr><h2 id="7-ReentrantLock-实现原理"><a href="#7-ReentrantLock-实现原理" class="headerlink" title="7. ReentrantLock 实现原理"></a><strong>7. ReentrantLock 实现原理</strong></h2><ul><li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong></li><li>内部维护一个 <strong>state</strong> 表示锁状态</li><li>队列 FIFO 管理等待线程</li><li>支持公平锁&#x2F;非公平锁</li></ul><hr><h2 id="8-公平锁和非公平锁区别"><a href="#8-公平锁和非公平锁区别" class="headerlink" title="8. 公平锁和非公平锁区别"></a><strong>8. 公平锁和非公平锁区别</strong></h2><table><thead><tr><th>特性</th><th>公平锁</th><th>非公平锁</th></tr></thead><tbody><tr><td>加锁顺序</td><td>FIFO</td><td>不保证</td></tr><tr><td>性能</td><td>低</td><td>高（线程争抢）</td></tr><tr><td>场景</td><td>避免饥饿</td><td>高性能锁场景</td></tr></tbody></table><hr><h2 id="9-乐观锁和悲观锁区别"><a href="#9-乐观锁和悲观锁区别" class="headerlink" title="9. 乐观锁和悲观锁区别"></a><strong>9. 乐观锁和悲观锁区别</strong></h2><ul><li><strong>悲观锁</strong>：假设会发生冲突，直接加锁（如 synchronized &#x2F; ReentrantLock）</li><li><strong>乐观锁</strong>：假设冲突少，使用 CAS（如 Atomic 类）</li></ul><hr><h2 id="10-AQS-原理"><a href="#10-AQS-原理" class="headerlink" title="10. AQS 原理"></a><strong>10. AQS 原理</strong></h2><ul><li><strong>核心</strong>：state + CLH 队列</li><li><strong>特性</strong>：<ul><li>独占模式 &#x2F; 共享模式</li><li>基于 FIFO 队列管理等待线程</li></ul></li><li><strong>应用</strong>：<ul><li>ReentrantLock、Semaphore、CountDownLatch、FutureTask</li></ul></li></ul><hr><h2 id="11-CountDownLatch-和-CyclicBarrier-区别"><a href="#11-CountDownLatch-和-CyclicBarrier-区别" class="headerlink" title="11. CountDownLatch 和 CyclicBarrier 区别"></a><strong>11. CountDownLatch 和 CyclicBarrier 区别</strong></h2><table><thead><tr><th>特性</th><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>使用次数</td><td>一次性</td><td>可重复使用</td></tr><tr><td>功能</td><td>等待线程完成</td><td>等待线程到达同一点</td></tr><tr><td>场景</td><td>线程结束同步</td><td>多线程并行分段</td></tr></tbody></table><hr><h2 id="12-Semaphore-的实现原理"><a href="#12-Semaphore-的实现原理" class="headerlink" title="12. Semaphore 的实现原理"></a><strong>12. Semaphore 的实现原理</strong></h2><ul><li>控制并发线程数量</li><li>基于 AQS 的共享锁</li><li>acquire() 获取许可，release() 释放许可</li></ul><hr><h2 id="13-Exchanger-的使用场景"><a href="#13-Exchanger-的使用场景" class="headerlink" title="13. Exchanger 的使用场景"></a><strong>13. Exchanger 的使用场景</strong></h2><ul><li>两个线程交换数据</li><li>典型场景：生产者-消费者线程交换缓冲区</li></ul><hr><h2 id="14-ForkJoinPool-的原理"><a href="#14-ForkJoinPool-的原理" class="headerlink" title="14. ForkJoinPool 的原理"></a><strong>14. ForkJoinPool 的原理</strong></h2><ul><li><strong>工作窃取算法</strong>：<ul><li>空闲线程从其他线程队列中窃取任务</li></ul></li><li>适合 <strong>递归任务</strong></li><li>通过 <strong>ForkJoinTask</strong> 递归拆分计算</li></ul><hr><h2 id="15-CAS-操作的底层实现"><a href="#15-CAS-操作的底层实现" class="headerlink" title="15. CAS 操作的底层实现"></a><strong>15. CAS 操作的底层实现</strong></h2><ul><li>基于 CPU <strong>原子指令（CMPXCHG）</strong></li><li>JVM <code>Unsafe</code> 提供支持</li><li><strong>优点</strong>：无锁、线程安全</li><li><strong>缺点</strong>：ABA 问题</li></ul><hr><h2 id="16-ABA-问题及解决"><a href="#16-ABA-问题及解决" class="headerlink" title="16. ABA 问题及解决"></a><strong>16. ABA 问题及解决</strong></h2><ul><li><strong>问题</strong>：值先 A → B → A，CAS 无法判断变化</li><li><strong>解决</strong>：<ul><li>版本号机制（AtomicStampedReference）</li><li>双重检查</li></ul></li></ul><hr><h2 id="17-Atomic-原子类原理"><a href="#17-Atomic-原子类原理" class="headerlink" title="17. Atomic 原子类原理"></a><strong>17. Atomic 原子类原理</strong></h2><ul><li>基于 <strong>CAS + Unsafe + volatile</strong></li><li>实现非阻塞线程安全</li><li>示例：<code>AtomicInteger</code> 使用 <code>compareAndSwapInt</code></li></ul><hr><h2 id="18-BlockingQueue-实现原理"><a href="#18-BlockingQueue-实现原理" class="headerlink" title="18. BlockingQueue 实现原理"></a><strong>18. BlockingQueue 实现原理</strong></h2><ul><li>内部维护 <strong>锁 + 条件队列</strong></li><li>put 阻塞满队列，take 阻塞空队列</li><li>常用实现：<ul><li>ArrayBlockingQueue（数组 + ReentrantLock）</li><li>LinkedBlockingQueue（链表 + ReentrantLock）</li></ul></li></ul><hr><h2 id="19-ConcurrentHashMap-的分段锁机制"><a href="#19-ConcurrentHashMap-的分段锁机制" class="headerlink" title="19. ConcurrentHashMap 的分段锁机制"></a><strong>19. ConcurrentHashMap 的分段锁机制</strong></h2><ul><li>JDK 1.7：<ul><li><strong>Segment[] + synchronized</strong></li></ul></li><li>JDK 1.8：<ul><li><strong>CAS + synchronized 链表 + 红黑树 + Node</strong></li></ul></li><li>支持高并发读写</li></ul><hr><h2 id="20-ConcurrentHashMap-扩容机制"><a href="#20-ConcurrentHashMap-扩容机制" class="headerlink" title="20. ConcurrentHashMap 扩容机制"></a><strong>20. ConcurrentHashMap 扩容机制</strong></h2><ul><li>采用 <strong>分段扩容 + CAS</strong></li><li>链表转红黑树提高查找性能</li><li>扩容过程中使用 <strong>迁移节点</strong></li></ul><hr><h2 id="21-CopyOnWriteArrayList-原理"><a href="#21-CopyOnWriteArrayList-原理" class="headerlink" title="21. CopyOnWriteArrayList 原理"></a><strong>21. CopyOnWriteArrayList 原理</strong></h2><ul><li>写时复制：<ol><li>写操作复制数组</li><li>修改后替换引用</li></ol></li><li>适合读多写少场景</li></ul><hr><h2 id="22-线程池核心参数"><a href="#22-线程池核心参数" class="headerlink" title="22. 线程池核心参数"></a><strong>22. 线程池核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程存活时间</td></tr><tr><td>workQueue</td><td>任务队列</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="23-线程池拒绝策略"><a href="#23-线程池拒绝策略" class="headerlink" title="23. 线程池拒绝策略"></a><strong>23. 线程池拒绝策略</strong></h2><ol><li>AbortPolicy（默认，抛异常）</li><li>CallerRunsPolicy（调用线程执行）</li><li>DiscardPolicy（丢弃任务）</li><li>DiscardOldestPolicy（丢弃队列最老任务）</li></ol><hr><h2 id="24-线程池工作流程"><a href="#24-线程池工作流程" class="headerlink" title="24. 线程池工作流程"></a><strong>24. 线程池工作流程</strong></h2><ol><li>提交任务 → 放入队列</li><li>核心线程未满 → 创建线程</li><li>队列满 → 创建非核心线程</li><li>达到最大线程 → 触发拒绝策略</li></ol><hr><h2 id="25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor"><a href="#25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor" class="headerlink" title="25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor"></a><strong>25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor</strong></h2><table><thead><tr><th>特性</th><th>ThreadPoolExecutor</th><th>ScheduledThreadPoolExecutor</th></tr></thead><tbody><tr><td>功能</td><td>通用线程池</td><td>支持定时 &#x2F; 周期任务</td></tr><tr><td>队列</td><td>BlockingQueue</td><td>DelayQueue</td></tr><tr><td>场景</td><td>并发任务</td><td>定时任务</td></tr></tbody></table><hr><h2 id="26-为什么不建议使用-Executors-创建线程池"><a href="#26-为什么不建议使用-Executors-创建线程池" class="headerlink" title="26. 为什么不建议使用 Executors 创建线程池"></a><strong>26. 为什么不建议使用 Executors 创建线程池</strong></h2><ul><li>Executors 会产生 <strong>无限队列</strong>（如 newCachedThreadPool）</li><li>容易 <strong>OOM &#x2F; 线程数过多</strong></li><li>推荐：手动使用 <strong>ThreadPoolExecutor</strong> 配置核心参数</li></ul><hr><h2 id="27-JMM-内存可见性问题"><a href="#27-JMM-内存可见性问题" class="headerlink" title="27. JMM 内存可见性问题"></a><strong>27. JMM 内存可见性问题</strong></h2><ul><li>多线程访问共享变量，修改不立即可见</li><li><strong>解决方法</strong>：<ul><li><code>volatile</code></li><li><code>synchronized</code> &#x2F; Lock</li></ul></li></ul><hr><h2 id="28-happens-before-规则"><a href="#28-happens-before-规则" class="headerlink" title="28. happens-before 规则"></a><strong>28. happens-before 规则</strong></h2><ul><li><strong>保证操作顺序与可见性</strong></li><li>常见规则：<ol><li><strong>锁的解锁 → 加锁</strong></li><li><strong>volatile 写 → 读</strong></li><li><strong>线程 start() → run()</strong></li><li><strong>线程 join() → 结束</strong></li></ol></li></ul><hr><h2 id="29-死锁产生条件及避免"><a href="#29-死锁产生条件及避免" class="headerlink" title="29. 死锁产生条件及避免"></a><strong>29. 死锁产生条件及避免</strong></h2><ul><li><strong>四个必要条件</strong>：<ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol></li><li><strong>避免方法</strong>：<ul><li>避免循环等待，按顺序加锁</li><li>使用 tryLock + 超时</li><li>使用单一锁</li></ul></li></ul><hr><h2 id="30-常见并发容器及区别"><a href="#30-常见并发容器及区别" class="headerlink" title="30. 常见并发容器及区别"></a><strong>30. 常见并发容器及区别</strong></h2><table><thead><tr><th>容器</th><th>特性</th></tr></thead><tbody><tr><td>ConcurrentHashMap</td><td>高并发读写，分段&#x2F;链表+红黑树</td></tr><tr><td>CopyOnWriteArrayList</td><td>写时复制，读多写少</td></tr><tr><td>ConcurrentLinkedQueue</td><td>非阻塞</td></tr></tbody></table><p>队列，基于 CAS |<br> | BlockingQueue（Array&#x2F;Linked） | 支持阻塞 put&#x2F;take |<br> | ConcurrentSkipListMap | 有序，基于跳表，线程安全 |</p><hr><h2 id="三、JVM-与性能优化（30题）"><a href="#三、JVM-与性能优化（30题）" class="headerlink" title="三、JVM 与性能优化（30题）"></a>三、JVM 与性能优化（30题）</h2><hr><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a><strong>1. JVM 内存结构</strong></h2><ul><li><strong>方法区 &#x2F; 元空间（Metaspace）</strong>：存放类信息、常量、静态变量</li><li><strong>堆（Heap）</strong>：对象实例、GC 管理区</li><li><strong>栈（Stack）</strong>：方法调用、局部变量</li><li><strong>程序计数器（PC）</strong>：记录线程执行地址</li><li><strong>本地方法栈（Native Stack）</strong>：执行 native 方法</li><li><strong>直接内存（Direct Memory）</strong>：堆外内存，用于 NIO</li></ul><hr><h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a><strong>2. 堆和栈的区别</strong></h2><table><thead><tr><th>特性</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>存储内容</td><td>对象实例</td><td>方法调用帧、局部变量</td></tr><tr><td>生命周期</td><td>GC 管理</td><td>随方法结束释放</td></tr><tr><td>线程共享</td><td>是</td><td>否（线程私有）</td></tr><tr><td>访问速度</td><td>较慢</td><td>快</td></tr><tr><td>内存大小</td><td>大</td><td>小</td></tr></tbody></table><hr><h2 id="3-新生代、老年代、永久代（元空间）的区别"><a href="#3-新生代、老年代、永久代（元空间）的区别" class="headerlink" title="3. 新生代、老年代、永久代（元空间）的区别"></a><strong>3. 新生代、老年代、永久代（元空间）的区别</strong></h2><ul><li><strong>新生代</strong>（Young Generation）：<ul><li>存放新创建对象</li><li>分为 Eden + 2 个 Survivor 区</li><li>Minor GC 主要发生在此</li></ul></li><li><strong>老年代</strong>（Old&#x2F;Tenured Generation）：<ul><li>长寿命对象</li><li>Full GC 主要作用区域</li></ul></li><li><strong>永久代 &#x2F; 元空间</strong>：<ul><li>存放类元数据</li><li>Java 8+ 使用 Metaspace（Native 内存）</li></ul></li></ul><hr><h2 id="4-对象的创建过程"><a href="#4-对象的创建过程" class="headerlink" title="4. 对象的创建过程"></a><strong>4. 对象的创建过程</strong></h2><ol><li><strong>类加载检查</strong></li><li><strong>分配内存</strong>：<ul><li>堆上分配对象空间（TLAB&#x2F;大对象直接分配）</li></ul></li><li><strong>初始化零值</strong></li><li><strong>构造器初始化</strong></li><li><strong>引用赋值</strong></li></ol><hr><h2 id="5-对象的内存分配策略"><a href="#5-对象的内存分配策略" class="headerlink" title="5. 对象的内存分配策略"></a><strong>5. 对象的内存分配策略</strong></h2><ul><li><strong>年轻代分配</strong>：TLAB（Thread Local Allocation Buffer）</li><li><strong>大对象直接进入老年代</strong>（如数组 &gt; 1MB）</li><li><strong>长期存活对象晋升到老年代</strong></li><li><strong>栈上分配</strong>：通过逃逸分析优化</li></ul><hr><h2 id="6-GC-Roots"><a href="#6-GC-Roots" class="headerlink" title="6. GC Roots"></a><strong>6. GC Roots</strong></h2><ul><li><strong>常见类型</strong>：<ul><li>栈帧中的引用变量</li><li>方法区静态变量</li><li>常量引用</li><li>本地方法栈引用</li></ul></li></ul><hr><h2 id="7-垃圾回收算法"><a href="#7-垃圾回收算法" class="headerlink" title="7. 垃圾回收算法"></a><strong>7. 垃圾回收算法</strong></h2><ul><li><strong>引用计数</strong>（不可解决循环引用）</li><li><strong>可达性分析</strong>（GC Roots）</li><li><strong>具体回收算法</strong>：<ul><li>标记-清除</li><li>标记-整理</li><li>复制算法</li><li>分代回收</li></ul></li></ul><hr><h2 id="8-CMS-垃圾回收器流程"><a href="#8-CMS-垃圾回收器流程" class="headerlink" title="8. CMS 垃圾回收器流程"></a><strong>8. CMS 垃圾回收器流程</strong></h2><ol><li>初始标记（Stop-The-World）</li><li>并发标记（标记可回收对象）</li><li>并发预清理</li><li>重新标记（Stop-The-World）</li><li>并发清理（回收老年代）</li></ol><ul><li><strong>特点</strong>：低停顿，但有浮动垃圾和内存碎片问题</li></ul><hr><h2 id="9-G1-垃圾回收器原理"><a href="#9-G1-垃圾回收器原理" class="headerlink" title="9. G1 垃圾回收器原理"></a><strong>9. G1 垃圾回收器原理</strong></h2><ul><li><strong>Region（分区）管理堆</strong></li><li><strong>分代+并行+增量收集</strong></li><li><strong>垃圾回收策略</strong>：<ul><li>优先回收回收成本低的 Region</li><li>并发标记 + 并行清理</li></ul></li><li><strong>目标</strong>：控制停顿时间</li><li><strong>优势</strong>：无碎片、可预测停顿</li></ul><hr><h2 id="10-ZGC-和-Shenandoah-特点"><a href="#10-ZGC-和-Shenandoah-特点" class="headerlink" title="10. ZGC 和 Shenandoah 特点"></a><strong>10. ZGC 和 Shenandoah 特点</strong></h2><ul><li><strong>低延迟 GC</strong>，停顿时间 &lt; 10ms</li><li><strong>并发标记 + 并发压缩</strong></li><li><strong>内存可扩展性好</strong></li><li>支持大内存 (&gt;100GB)</li><li>面试常问区别：ZGC 使用 <strong>Load Barrier</strong>，Shenandoah 使用 <strong>Region Pinning</strong></li></ul><hr><h2 id="11-Minor-GC-与-Full-GC-区别"><a href="#11-Minor-GC-与-Full-GC-区别" class="headerlink" title="11. Minor GC 与 Full GC 区别"></a><strong>11. Minor GC 与 Full GC 区别</strong></h2><table><thead><tr><th>特性</th><th>Minor GC</th><th>Full GC</th></tr></thead><tbody><tr><td>触发区域</td><td>新生代</td><td>整个堆（包括老年代）</td></tr><tr><td>停顿时间</td><td>短</td><td>长</td></tr><tr><td>频率</td><td>高</td><td>低</td></tr><tr><td>GC 类型</td><td>复制算法</td><td>标记-整理 &#x2F; CMS &#x2F; G1</td></tr></tbody></table><hr><h2 id="12-OOM-常见类型及排查"><a href="#12-OOM-常见类型及排查" class="headerlink" title="12. OOM 常见类型及排查"></a><strong>12. OOM 常见类型及排查</strong></h2><ul><li><strong>Java Heap Space</strong>：堆内存不足</li><li><strong>GC Overhead Limit</strong>：GC 花费过多时间</li><li><strong>Metaspace</strong>：类元信息过多</li><li><strong>Direct Memory</strong>：堆外内存溢出</li><li><strong>排查工具</strong>：<ul><li>jmap、jstack、VisualVM、MAT</li></ul></li></ul><hr><h2 id="13-类加载器分类"><a href="#13-类加载器分类" class="headerlink" title="13. 类加载器分类"></a><strong>13. 类加载器分类</strong></h2><ul><li>Bootstrap（根类加载器）</li><li>Extension（扩展类加载器）</li><li>Application（系统类加载器）</li><li>自定义 ClassLoader</li></ul><hr><h2 id="14-双亲委派模型破坏场景"><a href="#14-双亲委派模型破坏场景" class="headerlink" title="14. 双亲委派模型破坏场景"></a><strong>14. 双亲委派模型破坏场景</strong></h2><ul><li>动态加载不同版本类</li><li>热部署、插件化框架（Tomcat、OSGi）</li></ul><hr><h2 id="15-JVM-常见参数调优"><a href="#15-JVM-常见参数调优" class="headerlink" title="15. JVM 常见参数调优"></a><strong>15. JVM 常见参数调优</strong></h2><ul><li><strong>堆大小</strong>：<code>-Xms -Xmx</code></li><li><strong>新生代比例</strong>：<code>-XX:NewRatio</code></li><li><strong>GC 类型</strong>：<code>-XX:+UseG1GC</code></li><li><strong>线程栈大小</strong>：<code>-Xss</code></li><li><strong>Metaspace</strong>：<code>-XX:MetaspaceSize</code></li></ul><hr><h2 id="16-内存泄漏-vs-内存溢出"><a href="#16-内存泄漏-vs-内存溢出" class="headerlink" title="16. 内存泄漏 vs 内存溢出"></a><strong>16. 内存泄漏 vs 内存溢出</strong></h2><ul><li><strong>内存泄漏</strong>：对象不再使用，但仍有引用</li><li><strong>内存溢出（OOM）</strong>：申请内存失败</li></ul><hr><h2 id="17-逃逸分析"><a href="#17-逃逸分析" class="headerlink" title="17. 逃逸分析"></a><strong>17. 逃逸分析</strong></h2><ul><li><strong>作用</strong>：<ul><li>分析对象作用域</li><li>栈上分配、锁消除、同步优化</li></ul></li><li><strong>JVM 优化</strong>：<ul><li>栈上分配（不入堆）</li><li>去掉无用锁（锁消除）</li></ul></li></ul><hr><h2 id="18-方法内联"><a href="#18-方法内联" class="headerlink" title="18. 方法内联"></a><strong>18. 方法内联</strong></h2><ul><li>JIT 优化</li><li>小方法直接替换调用，减少方法调用开销</li><li>增加 CPU 指令局部性，提高性能</li></ul><hr><h2 id="19-JIT-编译器优化"><a href="#19-JIT-编译器优化" class="headerlink" title="19. JIT 编译器优化"></a><strong>19. JIT 编译器优化</strong></h2><ul><li>方法内联</li><li>循环展开</li><li>逃逸分析</li><li>常量折叠</li><li>逃逸分析 + 栈上分配</li></ul><hr><h2 id="20-Safepoint-机制"><a href="#20-Safepoint-机制" class="headerlink" title="20. Safepoint 机制"></a><strong>20. Safepoint 机制</strong></h2><ul><li>所有线程暂停，进行 GC 或其他全局操作</li><li>JVM 可安全修改线程状态</li></ul><hr><h2 id="21-Stop-The-World-STW"><a href="#21-Stop-The-World-STW" class="headerlink" title="21. Stop The World (STW)"></a><strong>21. Stop The World (STW)</strong></h2><ul><li><strong>定义</strong>：暂停所有用户线程进行 GC 或其他 JVM 内部操作</li><li><strong>影响</strong>：应用停顿，低延迟场景需控制 STW 时间</li></ul><hr><h2 id="22-Finalize-方法问题"><a href="#22-Finalize-方法问题" class="headerlink" title="22. Finalize 方法问题"></a><strong>22. Finalize 方法问题</strong></h2><ul><li>不确定执行时间</li><li>性能开销大</li><li>可导致对象“复活”，增加内存压力</li><li><strong>替代方案</strong>：try-with-resources &#x2F; Cleaner</li></ul><hr><h2 id="23-JVM-如何判断对象可回收"><a href="#23-JVM-如何判断对象可回收" class="headerlink" title="23. JVM 如何判断对象可回收"></a><strong>23. JVM 如何判断对象可回收</strong></h2><ul><li><strong>可达性分析</strong>：从 GC Roots 出发，未被可达的对象可回收</li></ul><hr><h2 id="24-TLAB（Thread-Local-Allocation-Buffer）作用"><a href="#24-TLAB（Thread-Local-Allocation-Buffer）作用" class="headerlink" title="24. TLAB（Thread Local Allocation Buffer）作用"></a><strong>24. TLAB（Thread Local Allocation Buffer）作用</strong></h2><ul><li>每个线程独享一块 Eden 内存</li><li><strong>作用</strong>：<ul><li>减少多线程竞争</li><li>提高对象分配效率</li></ul></li></ul><hr><h2 id="25-Direct-Memory-为什么会-OOM"><a href="#25-Direct-Memory-为什么会-OOM" class="headerlink" title="25. Direct Memory 为什么会 OOM"></a><strong>25. Direct Memory 为什么会 OOM</strong></h2><ul><li>堆外内存不足</li><li>NIO Buffer 使用 <code>Unsafe</code> 分配</li><li>不受堆内存限制，但 JVM 无法直接管理</li></ul><hr><h2 id="26-Metaspace-作用"><a href="#26-Metaspace-作用" class="headerlink" title="26. Metaspace 作用"></a><strong>26. Metaspace 作用</strong></h2><ul><li>存放类元数据</li><li>Java 8+ 替代永久代</li><li>可以通过 <code>-XX:MetaspaceSize</code> 限制</li></ul><hr><h2 id="27-Full-GC-触发条件"><a href="#27-Full-GC-触发条件" class="headerlink" title="27. Full GC 触发条件"></a><strong>27. Full GC 触发条件</strong></h2><ul><li>老年代空间不足</li><li>永久代 &#x2F; 元空间不足</li><li>System.gc() 调用</li><li>内存分配失败</li></ul><hr><h2 id="28-查看-JVM-内存使用情况"><a href="#28-查看-JVM-内存使用情况" class="headerlink" title="28. 查看 JVM 内存使用情况"></a><strong>28. 查看 JVM 内存使用情况</strong></h2><ul><li><code>jstat -gc &lt;pid&gt;</code></li><li><code>jmap -heap &lt;pid&gt;</code></li><li><code>VisualVM</code> &#x2F; <code>JConsole</code></li><li><code>MAT</code> 分析 heap dump</li></ul><hr><h2 id="29-Arthas-常用命令"><a href="#29-Arthas-常用命令" class="headerlink" title="29. Arthas 常用命令"></a><strong>29. Arthas 常用命令</strong></h2><ul><li><code>dashboard</code>：系统指标</li><li><code>thread</code>：线程状态</li><li><code>heapdump</code>：堆转储</li><li><code>monitor</code>：方法耗时</li><li><code>watch</code>：方法参数&#x2F;返回值</li><li><code>jad</code>：反编译类</li></ul><hr><h2 id="30-JVM-调优常见面试题"><a href="#30-JVM-调优常见面试题" class="headerlink" title="30. JVM 调优常见面试题"></a><strong>30. JVM 调优常见面试题</strong></h2><ul><li>堆大小设置策略</li><li>新生代&#x2F;老年代比例</li><li>GC 选择（G1 &#x2F; CMS &#x2F; Parallel）</li><li>TLAB 与对象分配优化</li><li>Full GC 触发条件</li><li>内存泄漏排查与 MAT 使用</li></ul><hr><h2 id="四、Spring-Spring-Boot（30题）"><a href="#四、Spring-Spring-Boot（30题）" class="headerlink" title="四、Spring &amp; Spring Boot（30题）"></a>四、Spring &amp; Spring Boot（30题）</h2><h3 id="1-Spring-的-IoC-容器原理？"><a href="#1-Spring-的-IoC-容器原理？" class="headerlink" title="1. Spring 的 IoC 容器原理？"></a>1. Spring 的 IoC 容器原理？</h3><p><strong>核心回答：</strong><br> IoC（控制反转）是通过容器管理对象创建和依赖注入，开发者不需要手动 new 对象，而是由 Spring 容器统一管理。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器的核心是 <strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</li><li>工作流程：<ol><li><strong>配置解析</strong>：读取 XML &#x2F; 注解 &#x2F; JavaConfig；</li><li><strong>BeanDefinition</strong>：将配置转成 BeanDefinition；</li><li><strong>Bean 实例化</strong>：通过反射或 CGLIB 创建对象；</li><li><strong>依赖注入</strong>：根据构造方法 &#x2F; Setter &#x2F; @Autowired 注入依赖；</li><li><strong>初始化回调</strong>：执行 BeanPostProcessor &#x2F; InitializingBean；</li><li><strong>放入单例池</strong>：容器保存对象供全局使用。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>IoC 是 <strong>依赖查找（DL）</strong> 和 <strong>依赖注入（DI）</strong> 的结合。</li><li>面试可能追问：Spring 如何实现延迟加载？（@Lazy + 单例池管理）</li><li>实战：配置文件少时用 XML，大项目推荐 <strong>JavaConfig + 注解</strong>。</li></ul><hr><h3 id="2-Bean-的生命周期？"><a href="#2-Bean-的生命周期？" class="headerlink" title="2. Bean 的生命周期？"></a>2. Bean 的生命周期？</h3><p><strong>核心回答：</strong><br> 创建 → 属性注入 → 初始化 → 使用 → 销毁。</p><p><strong>深入解析：</strong></p><ol><li><strong>实例化</strong>：通过反射创建对象；</li><li><strong>依赖注入</strong>：注入属性；</li><li><strong>Aware 接口回调</strong>：如 BeanNameAware、ApplicationContextAware；</li><li><strong>BeanPostProcessor 前置处理</strong>：比如 @Autowired 的处理；</li><li><strong>初始化方法</strong>：@PostConstruct &#x2F; InitializingBean.afterPropertiesSet() &#x2F; init-method；</li><li><strong>BeanPostProcessor 后置处理</strong>；</li><li><strong>就绪使用</strong>；</li><li><strong>销毁回调</strong>：@PreDestroy &#x2F; DisposableBean.destroy() &#x2F; destroy-method。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常追问：Spring 容器关闭时，单例 Bean 会被销毁吗？（会，调用 destroy 回调）。</li><li>原型作用域 Bean 不会被销毁，需要开发者手动管理。</li></ul><hr><h3 id="3-BeanFactory-和-ApplicationContext-的区别？"><a href="#3-BeanFactory-和-ApplicationContext-的区别？" class="headerlink" title="3. BeanFactory 和 ApplicationContext 的区别？"></a>3. BeanFactory 和 ApplicationContext 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><strong>BeanFactory</strong>：最基础 IoC 容器，懒加载，轻量级；</li><li><strong>ApplicationContext</strong>：继承 BeanFactory，支持 AOP、国际化、事件机制、自动装配，默认预实例化。</li></ul><p><strong>深入解析：</strong></p><ul><li>BeanFactory：面向低资源环境，功能有限；</li><li>ApplicationContext：常用实现有 ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试常问：为什么 ApplicationContext 默认是预加载？（减少运行时性能开销，启动时完成依赖检查）。</li></ul><hr><h3 id="4-单例-Bean-如何保证线程安全？"><a href="#4-单例-Bean-如何保证线程安全？" class="headerlink" title="4. 单例 Bean 如何保证线程安全？"></a>4. 单例 Bean 如何保证线程安全？</h3><p><strong>核心回答：</strong><br> Spring <strong>不保证单例 Bean 的线程安全</strong>，需要开发者在代码中保证。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器中的单例 Bean 是 <strong>多线程共享的</strong>；</li><li>常见的线程安全措施：<ol><li><strong>无状态设计</strong>（推荐）；</li><li><strong>使用 ThreadLocal 保存状态</strong>；</li><li><strong>方法内部使用局部变量</strong>；</li><li><strong>必要时加锁（synchronized &#x2F; Lock）</strong>。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：Spring 单例 Bean 是不是线程安全的？答：不是。</li><li>例子：Controller、Service 通常是无状态的，可以安全单例。</li></ul><hr><h3 id="5-Spring-AOP-的实现原理？"><a href="#5-Spring-AOP-的实现原理？" class="headerlink" title="5. Spring AOP 的实现原理？"></a>5. Spring AOP 的实现原理？</h3><p><strong>核心回答：</strong><br> AOP（面向切面编程）通过 <strong>动态代理</strong> 实现，在方法执行前后插入增强逻辑。</p><p><strong>深入解析：</strong></p><ul><li>实现方式：<ol><li><strong>JDK 动态代理</strong>：基于接口；</li><li><strong>CGLIB 代理</strong>：基于子类字节码增强。</li></ol></li><li>AOP 核心组件：<ul><li>JoinPoint（连接点）、Pointcut（切点）、Advice（通知）、Weaving（织入）、Proxy（代理对象）。</li></ul></li><li>AOP 流程：调用目标方法 → 代理对象拦截 → 执行切面逻辑 → 继续执行原方法。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：Spring 默认用哪种代理？<ul><li>如果有接口 → JDK 动态代理；</li><li>没有接口 → CGLIB。</li></ul></li><li>JDK 代理只能基于接口，CGLIB 可以基于类。</li></ul><hr><h3 id="6-JDK-动态代理和-CGLIB-的区别？"><a href="#6-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="6. JDK 动态代理和 CGLIB 的区别？"></a>6. JDK 动态代理和 CGLIB 的区别？</h3><p><strong>核心回答：</strong></p><ul><li>JDK：基于接口，生成实现类；</li><li>CGLIB：基于继承，生成子类字节码。</li></ul><p><strong>深入解析：</strong></p><ul><li>JDK 动态代理：利用 <code>Proxy.newProxyInstance</code>，性能较高；</li><li>CGLIB：利用 ASM 字节码操作生成子类，性能稍慢，但支持类代理；</li><li>Spring 默认优先使用 JDK，如果没有接口再用 CGLIB。</li></ul><p><strong>延伸思考：</strong></p><ul><li>限制：CGLIB 无法代理 <code>final</code> 类 &#x2F; <code>final</code> 方法；</li><li>Spring Boot 可通过 <code>spring.aop.proxy-target-class=true</code> 强制使用 CGLIB。</li></ul><hr><h3 id="7-Spring-事务的传播机制？"><a href="#7-Spring-事务的传播机制？" class="headerlink" title="7. Spring 事务的传播机制？"></a>7. Spring 事务的传播机制？</h3><p><strong>核心回答：</strong><br> 事务传播机制定义了方法在调用时事务的边界，常见类型：</p><ul><li>REQUIRED（默认）、REQUIRES_NEW、NESTED、SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER。</li></ul><p><strong>深入解析：</strong></p><ul><li><strong>REQUIRED</strong>：有事务就加入，没有就新建；</li><li><strong>REQUIRES_NEW</strong>：挂起当前事务，新建一个；</li><li><strong>NESTED</strong>：嵌套事务（依赖保存点 rollback）；</li><li><strong>SUPPORTS</strong>：有就用，没有就不用；</li><li><strong>NOT_SUPPORTED</strong>：挂起事务，以非事务运行；</li><li><strong>MANDATORY</strong>：必须在事务中调用；</li><li><strong>NEVER</strong>：必须在非事务中运行。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：嵌套事务和新事务的区别？<ul><li>嵌套事务依赖外层事务回滚；</li><li>新事务互相独立。</li></ul></li></ul><hr><h3 id="8-Spring-事务的隔离级别？"><a href="#8-Spring-事务的隔离级别？" class="headerlink" title="8. Spring 事务的隔离级别？"></a>8. Spring 事务的隔离级别？</h3><p><strong>核心回答：</strong><br> 事务隔离级别解决并发问题，Spring 支持数据库的 5 种隔离级别：</p><ul><li>DEFAULT（数据库默认）</li><li>READ_UNCOMMITTED（可能脏读）</li><li>READ_COMMITTED（防脏读）</li><li>REPEATABLE_READ（防脏读、不可重复读）</li><li>SERIALIZABLE（防脏读、不可重复读、幻读）</li></ul><p><strong>深入解析：</strong></p><ul><li>InnoDB 默认是 <strong>REPEATABLE_READ</strong>；</li><li>Oracle 默认是 <strong>READ_COMMITTED</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试可能追问：MySQL 的 REPEATABLE_READ 如何避免幻读？（MVCC + 间隙锁）。</li></ul><hr><h3 id="9-Transactional-的实现原理？"><a href="#9-Transactional-的实现原理？" class="headerlink" title="9. @Transactional 的实现原理？"></a>9. @Transactional 的实现原理？</h3><p><strong>核心回答：</strong><br> @Transactional 通过 <strong>AOP 代理</strong>，在方法执行前后控制事务。</p><p><strong>深入解析：</strong></p><ul><li>Spring 容器解析 @Transactional → 生成代理 → 在代理方法里执行事务增强逻辑：<ol><li>获取事务管理器；</li><li>开启事务；</li><li>执行目标方法；</li><li>异常回滚 &#x2F; 正常提交；</li><li>清理资源。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>默认只回滚 RuntimeException 和 Error，检查异常需要 <code>rollbackFor</code>。</li><li>面试常问：为什么 @Transactional 方法用 <code>private</code> 修饰无效？<br> → 因为 AOP 代理无法拦截 private 方法。</li></ul><hr><h3 id="10-循环依赖如何解决？"><a href="#10-循环依赖如何解决？" class="headerlink" title="10. 循环依赖如何解决？"></a>10. 循环依赖如何解决？</h3><p><strong>核心回答：</strong><br> Spring 通过 <strong>三级缓存</strong> 解决单例 Bean 的循环依赖。</p><p><strong>深入解析：</strong></p><ul><li>三级缓存：<ol><li>singletonObjects（成品对象）</li><li>earlySingletonObjects（提前暴露的对象，半成品）</li><li>singletonFactories（对象工厂，提供代理对象）</li></ol></li><li>流程：A → 依赖 B → B 依赖 A → 提前暴露 A 的引用给 B → 依赖注入成功。</li></ul><p><strong>延伸思考：</strong></p><ul><li>只能解决 <strong>单例 + setter 注入</strong> 的循环依赖；</li><li><strong>构造器注入循环依赖</strong> 无法解决，会抛出异常。</li></ul><h3 id="11-Spring-的三级缓存解决了什么问题？"><a href="#11-Spring-的三级缓存解决了什么问题？" class="headerlink" title="11. Spring 的三级缓存解决了什么问题？"></a>11. Spring 的三级缓存解决了什么问题？</h3><p><strong>核心回答：</strong><br> 解决 <strong>单例 Bean 的循环依赖</strong>，保证在创建过程中能提前暴露代理对象。</p><p><strong>深入解析：</strong></p><ul><li>Spring 单例池维护了 <strong>三级缓存</strong>：<ol><li><code>singletonObjects</code> → 一级缓存（完全初始化的单例）；</li><li><code>earlySingletonObjects</code> → 二级缓存（提前暴露的半成品对象）；</li><li><code>singletonFactories</code> → 三级缓存（对象工厂，通常生成代理对象）。</li></ol></li><li>流程：<ul><li>当 A 依赖 B，B 又依赖 A 时：<ol><li>创建 A → 放入三级缓存；</li><li>B 依赖 A 时，先从三级缓存拿到 A 的工厂，暴露提前代理对象 → 放入二级缓存；</li><li>等 A 完成初始化后，替换为一级缓存。</li></ol></li></ul></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：为什么要三级缓存，不是二级就够了吗？<br> → 因为 AOP 代理对象需要通过工厂提前暴露，不能只放半成品对象。</li><li>只支持 <strong>setter 注入的循环依赖</strong>，不支持 <strong>构造函数循环依赖</strong>。</li></ul><hr><h3 id="12-Spring-MVC-的工作流程？"><a href="#12-Spring-MVC-的工作流程？" class="headerlink" title="12. Spring MVC 的工作流程？"></a>12. Spring MVC 的工作流程？</h3><p><strong>核心回答：</strong><br> 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → 响应。</p><p><strong>深入解析：</strong></p><ol><li>用户请求到达 DispatcherServlet；</li><li>DispatcherServlet 调用 HandlerMapping 寻找处理器；</li><li>通过 HandlerAdapter 调用具体 Controller；</li><li>Controller 执行业务逻辑，返回 ModelAndView；</li><li>ViewResolver 解析视图；</li><li>DispatcherServlet 渲染并返回响应给客户端。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官常问：DispatcherServlet 是单例还是多例？（单例，线程安全依赖于无状态设计）。</li><li>实战：可以用 <code>@RestController</code> 直接返回 JSON，省略 ViewResolver。</li></ul><hr><h3 id="13-DispatcherServlet-的作用？"><a href="#13-DispatcherServlet-的作用？" class="headerlink" title="13. DispatcherServlet 的作用？"></a>13. DispatcherServlet 的作用？</h3><p><strong>核心回答：</strong><br> Spring MVC 的 <strong>前端控制器</strong>，负责请求分发和响应渲染。</p><p><strong>深入解析：</strong></p><ul><li>职责：<ol><li>拦截请求；</li><li>调用 HandlerMapping 找到 Controller；</li><li>调用 HandlerAdapter 执行 Controller；</li><li>调用 ViewResolver 渲染视图；</li><li>返回响应。</li></ol></li><li>核心思想：<strong>统一入口，集中控制</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：DispatcherServlet 在 Spring Boot 中怎么注册的？<br> → 自动配置类 <code>DispatcherServletAutoConfiguration</code> 注册。</li></ul><hr><h3 id="14-Spring-Boot-的自动装配原理？"><a href="#14-Spring-Boot-的自动装配原理？" class="headerlink" title="14. Spring Boot 的自动装配原理？"></a>14. Spring Boot 的自动装配原理？</h3><p><strong>核心回答：</strong><br> 基于 <code>@EnableAutoConfiguration</code> + <code>SpringFactoriesLoader</code> 实现，根据 classpath 条件加载配置类。</p><p><strong>深入解析：</strong></p><ol><li><code>@SpringBootApplication</code> → 启用 <code>@EnableAutoConfiguration</code>；</li><li><code>SpringFactoriesLoader</code> 读取 <code>META-INF/spring.factories</code> 文件；</li><li>根据 <code>@Conditional</code> 注解判断是否加载；</li><li>把匹配的 Bean 注册到容器。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：怎么禁用某个自动配置？<br> → <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></li><li>或者在 <code>application.yml</code> 中配置 <code>spring.autoconfigure.exclude</code>。</li></ul><hr><h3 id="15-Spring-Boot-Starter-的机制？"><a href="#15-Spring-Boot-Starter-的机制？" class="headerlink" title="15. Spring Boot Starter 的机制？"></a>15. Spring Boot Starter 的机制？</h3><p><strong>核心回答：</strong><br> Starter 是一组 <strong>依赖封装 + 自动配置</strong>，简化第三方库集成。</p><p><strong>深入解析：</strong></p><ul><li>命名规范：<code>spring-boot-starter-xxx</code>；</li><li>依赖 Starter → 自动引入必要依赖 + 自动装配类；</li><li>例子：<code>spring-boot-starter-web</code> → 引入 Spring MVC + Tomcat + Jackson，并自动配置 DispatcherServlet。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官常问：怎么写一个自定义 Starter？<ol><li>提供 <code>AutoConfiguration</code> 类；</li><li>在 <code>META-INF/spring.factories</code> 注册；</li><li>打包发布。</li></ol></li></ul><hr><h3 id="16-ConfigurationProperties-和-Value-的区别？"><a href="#16-ConfigurationProperties-和-Value-的区别？" class="headerlink" title="16. @ConfigurationProperties 和 @Value 的区别？"></a>16. @ConfigurationProperties 和 @Value 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><code>@Value</code>：单个属性注入；</li><li><code>@ConfigurationProperties</code>：批量绑定配置，支持类型安全。</li></ul><p><strong>深入解析：</strong></p><ul><li><code>@Value(&quot;$&#123;key&#125;&quot;)</code>：只能注入单个值；</li><li><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>：把配置文件中 <code>xxx.*</code> 映射到 JavaBean。</li><li><code>@ConfigurationProperties</code> 更适合复杂配置对象。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：推荐用哪个？<br> → <code>@ConfigurationProperties</code>，因为支持校验（<code>@Validated</code>）、IDE 提示。</li><li>实战：数据库配置常用 <code>@ConfigurationProperties</code>。</li></ul><hr><h3 id="17-Spring-Boot-如何实现热部署？"><a href="#17-Spring-Boot-如何实现热部署？" class="headerlink" title="17. Spring Boot 如何实现热部署？"></a>17. Spring Boot 如何实现热部署？</h3><p><strong>核心回答：</strong><br> 主要通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong>。</p><p><strong>深入解析：</strong></p><ul><li>DevTools：监控 classpath 文件变化，触发 SpringContext 重启；</li><li>JRebel：字节码增强，做到无感知热替换；</li><li>IDE（IntelliJ IDEA &#x2F; Eclipse）也支持 Build 自动 reload。</li></ul><p><strong>延伸思考：</strong></p><ul><li>DevTools 适合开发，JRebel 更强大但收费。</li><li>生产环境不建议热部署，而是灰度发布&#x2F;滚动更新。</li></ul><hr><h3 id="18-Spring-Boot-如何处理配置文件？"><a href="#18-Spring-Boot-如何处理配置文件？" class="headerlink" title="18. Spring Boot 如何处理配置文件？"></a>18. Spring Boot 如何处理配置文件？</h3><p><strong>核心回答：</strong><br> Spring Boot 读取 <code>application.yml/properties</code>，并支持多环境和优先级加载。</p><p><strong>深入解析：</strong></p><ul><li>默认加载顺序：<ol><li>命令行参数；</li><li><code>application.properties</code> &#x2F; <code>application.yml</code>；</li><li>外部配置文件（config 目录）；</li><li>默认配置。</li></ol></li><li>支持多环境：<code>application-dev.yml</code>、<code>application-prod.yml</code>，通过 <code>spring.profiles.active=dev</code> 切换。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：优先级谁最高？<br> → 命令行参数。</li><li>实战：生产环境常用外部化配置（如 <code>--spring.config.location</code>）。</li></ul><hr><h3 id="19-Conditional-注解的作用？"><a href="#19-Conditional-注解的作用？" class="headerlink" title="19. @Conditional 注解的作用？"></a>19. @Conditional 注解的作用？</h3><p><strong>核心回答：</strong><br> 用于 <strong>条件装配</strong>，根据环境 &#x2F; 配置 &#x2F; Bean 是否存在决定是否加载 Bean。</p><p><strong>深入解析：</strong></p><ul><li>常见实现：<ul><li><code>@ConditionalOnClass</code>（类存在时装配）；</li><li><code>@ConditionalOnMissingBean</code>（没有 Bean 时装配）；</li><li><code>@ConditionalOnProperty</code>（配置项满足条件时装配）；</li><li><code>@ConditionalOnWebApplication</code>。</li></ul></li><li>广泛用于自动配置。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：怎么写自定义条件？<br> → 实现 <code>Condition</code> 接口，重写 <code>matches()</code> 方法。</li></ul><hr><h3 id="20-Spring-Boot-常见的优化点？"><a href="#20-Spring-Boot-常见的优化点？" class="headerlink" title="20. Spring Boot 常见的优化点？"></a>20. Spring Boot 常见的优化点？</h3><p><strong>核心回答：</strong></p><ul><li>启动优化：懒加载、裁剪 Starter；</li><li>内存优化：减小 Bean 数量、引入轻量组件；</li><li>数据库优化：连接池、批量操作；</li><li>生产优化：Actuator 监控、外部化配置。</li></ul><p><strong>深入解析：</strong></p><ol><li><strong>启动性能</strong>：<code>spring.main.lazy-initialization=true</code>；</li><li><strong>数据库性能</strong>：HikariCP 连接池、批处理 SQL；</li><li><strong>缓存优化</strong>：整合 Redis、Caffeine；</li><li><strong>日志优化</strong>：异步日志（Logback AsyncAppender）；</li><li><strong>部署优化</strong>：分层构建（Layered Jar）、Docker 镜像加速。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常问：Spring Boot 为什么启动比 Spring 慢？<br> → 因为要做自动装配和环境扫描。</li><li>实战：生产中可用 <code>spring-context-indexer</code> 加快启动。</li></ul><hr><h3 id="21-Spring-Boot-的自动配置原理"><a href="#21-Spring-Boot-的自动配置原理" class="headerlink" title="21. Spring Boot 的自动配置原理"></a><strong>21. Spring Boot 的自动配置原理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的自动配置基于 <strong>SpringFactoriesLoader + @EnableAutoConfiguration + 条件注解（@ConditionalXXX）</strong>。<br> 它会根据 classpath 中依赖的 jar 包和已有 Bean 自动装配所需的配置。</p><p><strong>深入解析</strong></p><ol><li><strong>关键入口</strong>：<ul><li><code>@SpringBootApplication</code> → <code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code>。</li></ul></li><li><strong>配置来源</strong>：<ul><li><code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。</li></ul></li><li><strong>条件装配</strong>：<ul><li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等来避免重复配置。</li></ul></li><li><strong>运行时流程</strong>：<ul><li>启动时加载所有候选配置类 → 根据条件筛选 → 注册 BeanDefinition → 实例化 Bean。</li></ul></li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何排查“为什么某个 Bean 没有生效”？<br> → 使用 <code>--debug</code> 参数查看 <strong>自动配置报告</strong>。</li><li>实战：如果不想加载某个自动配置，可以用 <code>@SpringBootApplication(exclude=XXXAutoConfiguration.class)</code>。</li></ul><hr><h3 id="22-Spring-Boot-的启动流程"><a href="#22-Spring-Boot-的启动流程" class="headerlink" title="22. Spring Boot 的启动流程"></a><strong>22. Spring Boot 的启动流程</strong></h3><p><strong>核心回答</strong><br> 启动流程：</p><ol><li>创建 <code>SpringApplication</code> 对象。</li><li>准备环境（Environment）。</li><li>加载 ApplicationContext。</li><li>调用自动配置。</li><li>启动内嵌容器（Tomcat&#x2F;Jetty&#x2F;Netty）。</li><li>执行 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code>。</li></ol><p><strong>深入解析</strong></p><ul><li><strong>源码入口</strong>：<code>SpringApplication.run()</code>。</li><li><strong>事件监听</strong>：<ul><li><code>ApplicationStartingEvent</code>（最早事件），</li><li><code>ApplicationReadyEvent</code>（启动完成）。</li></ul></li><li><strong>Bean 加载</strong>：<ul><li>先加载主类所在包及子包的组件（<code>@ComponentScan</code>）。</li><li>再结合自动配置。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试官可能问：<strong>Spring Boot 如何支持外部配置？</strong><br> → 通过 <code>ConfigFileApplicationListener</code> 解析 <code>application.properties</code> &#x2F; <code>application.yml</code> 并注入 Environment。</li></ul><hr><h3 id="23-Spring-Boot-的配置文件加载顺序"><a href="#23-Spring-Boot-的配置文件加载顺序" class="headerlink" title="23. Spring Boot 的配置文件加载顺序"></a><strong>23. Spring Boot 的配置文件加载顺序</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的配置优先级（从高到低）：</p><ol><li>命令行参数</li><li><code>application.properties/yml</code>（在 <code>config/</code> &gt; 当前目录 &gt; classpath 下）</li><li>外部系统环境变量</li><li>JNDI、系统属性</li><li>默认配置</li></ol><p><strong>深入解析</strong></p><ul><li><strong>多 profile</strong>：<code>application-dev.yml</code> 会在 <code>--spring.profiles.active=dev</code> 时覆盖默认配置。</li><li><strong>优先级控制</strong>：同一属性多次定义时，高优先级覆盖低优先级。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如果配置冲突，如何快速定位？<br> → 启动时加参数 <code>--debug</code>，查看配置源和优先级。</li></ul><hr><h3 id="24-Spring-Boot-如何实现热部署"><a href="#24-Spring-Boot-如何实现热部署" class="headerlink" title="24. Spring Boot 如何实现热部署"></a><strong>24. Spring Boot 如何实现热部署</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong> 实现热部署。</p><p><strong>深入解析</strong></p><ul><li><strong>DevTools 原理</strong>：<ul><li>使用两个 ClassLoader：<ul><li>Base ClassLoader（第三方依赖不会变），</li><li>Restart ClassLoader（自己代码，改动后只重新加载）。</li></ul></li></ul></li><li><strong>局限性</strong>：修改依赖库不会触发热部署，只能重启。</li></ul><p><strong>延伸思考</strong></p><ul><li>实际开发中推荐用 <strong>DevTools + IDEA 自动构建</strong>。</li><li>面试追问：生产环境如何实现热更新？<br> → 使用 Spring Cloud Config + 动态刷新（<code>/actuator/refresh</code>）。</li></ul><hr><h3 id="25-Spring-Boot-中的监控和健康检查"><a href="#25-Spring-Boot-中的监控和健康检查" class="headerlink" title="25. Spring Boot 中的监控和健康检查"></a><strong>25. Spring Boot 中的监控和健康检查</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <strong>Actuator 模块</strong>，可监控应用运行状态。</p><p><strong>深入解析</strong></p><ul><li>常见端点：<ul><li><code>/actuator/health</code>（健康检查）</li><li><code>/actuator/metrics</code>（性能指标）</li><li><code>/actuator/env</code>（环境变量）</li><li><code>/actuator/beans</code>（已加载 Bean）</li></ul></li><li>健康检查可扩展：实现 <code>HealthIndicator</code> 接口，自定义检查逻辑（如 Redis、MQ）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Kubernetes 中结合健康检查？<br> → 配置 <strong>livenessProbe</strong> 和 <strong>readinessProbe</strong> 调用 <code>/actuator/health</code>。</li></ul><hr><h3 id="26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）"><a href="#26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）" class="headerlink" title="26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）"></a><strong>26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <code>spring-boot-starter-jdbc</code>、<code>spring-boot-starter-data-jpa</code> 等 starter，支持开箱即用。</p><p><strong>深入解析</strong></p><ul><li><strong>JDBC</strong>：直接操作数据库，结合 <code>JdbcTemplate</code>。</li><li><strong>JPA</strong>：基于 Hibernate，支持声明式 ORM（<code>@Entity</code>）。</li><li><strong>MyBatis</strong>：需引入第三方 starter（<code>mybatis-spring-boot-starter</code>），用 <code>@MapperScan</code>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：<strong>Spring Data JPA 与 MyBatis 区别？</strong><ul><li>JPA → ORM 自动化，适合快速开发。</li><li>MyBatis → SQL 手写，灵活可控，适合复杂业务。</li></ul></li></ul><hr><h3 id="27-Spring-Boot-如何实现日志管理"><a href="#27-Spring-Boot-如何实现日志管理" class="headerlink" title="27. Spring Boot 如何实现日志管理"></a><strong>27. Spring Boot 如何实现日志管理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 默认使用 <strong>SLF4J + Logback</strong>，可支持 Log4j2。</p><p><strong>深入解析</strong></p><ul><li><strong>配置方式</strong>：<ul><li><code>application.yml</code> 或 <code>logback-spring.xml</code>。</li></ul></li><li><strong>日志级别</strong>：<code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code>。</li><li><strong>多环境日志</strong>：<ul><li><code>logback-spring.xml</code> + <code>springProfile</code> 标签可区分 dev &#x2F; prod。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何将日志输出到 ELK（ElasticSearch + Logstash + Kibana）？<br> → 使用 <code>logstash-logback-encoder</code>。</li></ul><hr><h3 id="28-Spring-Boot-如何处理跨域问题（CORS）"><a href="#28-Spring-Boot-如何处理跨域问题（CORS）" class="headerlink" title="28. Spring Boot 如何处理跨域问题（CORS）"></a><strong>28. Spring Boot 如何处理跨域问题（CORS）</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>@CrossOrigin</strong> 或全局配置 <code>CorsFilter</code>。</p><p><strong>深入解析</strong></p><ul><li><p><strong>方式1：注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins=&quot;http://example.com&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方式2：全局配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：CORS 和 Nginx 反向代理跨域的区别？<ul><li>CORS → Spring Boot 处理，适合单应用。</li><li>Nginx → 网关层处理，适合微服务架构。</li></ul></li></ul><hr><h3 id="29-Spring-Boot-中的安全机制（Spring-Security）"><a href="#29-Spring-Boot-中的安全机制（Spring-Security）" class="headerlink" title="29. Spring Boot 中的安全机制（Spring Security）"></a><strong>29. Spring Boot 中的安全机制（Spring Security）</strong></h3><p><strong>核心回答</strong><br> Spring Security 提供认证（Authentication）+ 授权（Authorization）。</p><p><strong>深入解析</strong></p><ol><li><strong>认证流程</strong>：<ul><li>用户请求 → <code>UsernamePasswordAuthenticationFilter</code> → AuthenticationManager → UserDetailsService → 认证成功 → SecurityContext 保存信息。</li></ul></li><li><strong>授权机制</strong>：<ul><li>基于 URL（拦截路径）、方法级（<code>@PreAuthorize</code>）、表达式。</li></ul></li><li><strong>默认用户</strong>：Spring Boot 2.x 默认生成随机密码（日志中输出）。</li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Spring Security 中集成 JWT？<ul><li>自定义过滤器，解析 JWT 并注入 SecurityContext。</li></ul></li></ul><hr><h3 id="30-如何优化-Spring-Boot-启动速度"><a href="#30-如何优化-Spring-Boot-启动速度" class="headerlink" title="30. 如何优化 Spring Boot 启动速度"></a><strong>30. 如何优化 Spring Boot 启动速度</strong></h3><p><strong>核心回答</strong><br> 优化手段：减少自动配置、延迟初始化、引入轻量依赖。</p><p><strong>深入解析</strong></p><ul><li><strong>延迟加载</strong>：<code>spring.main.lazy-initialization=true</code>。</li><li><strong>移除不必要的 starter</strong>。</li><li><strong>本地调试时跳过安全&#x2F;监控配置</strong>。</li><li><strong>使用 GraalVM Native Image 加速启动</strong>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：Spring Boot 启动慢，如何排查？<ul><li>使用 <code>--debug</code> 和 <code>ApplicationStartup</code> 查看 Bean 加载耗时。</li></ul></li></ul><hr><h2 id="五、Spring-Cloud（30题）"><a href="#五、Spring-Cloud（30题）" class="headerlink" title="五、Spring Cloud（30题）"></a>五、Spring Cloud（30题）</h2><hr><h2 id="1-Spring-Cloud-是什么？"><a href="#1-Spring-Cloud-是什么？" class="headerlink" title="1. Spring Cloud 是什么？"></a><strong>1. Spring Cloud 是什么？</strong></h2><p><strong>核心回答</strong><br> Spring Cloud 是基于 Spring Boot 的微服务治理框架，提供了分布式系统所需的全套组件：服务注册发现、负载均衡、配置中心、网关、熔断限流、链路追踪等。</p><p><strong>深入原理</strong></p><ul><li><strong>定位</strong>：微服务的 “生态整合者”，不是单一技术，而是一套解决方案。</li><li><strong>核心组件</strong>：<ul><li>Eureka（注册中心）</li><li>Ribbon &#x2F; LoadBalancer（客户端负载均衡）</li><li>Feign（声明式远程调用）</li><li>Hystrix &#x2F; Resilience4j &#x2F; Sentinel（熔断限流）</li><li>Config Server（配置中心）</li><li>Gateway（网关）</li><li>Sleuth + Zipkin（链路追踪）</li></ul></li><li><strong>本质</strong>：解决分布式复杂性，降低开发门槛。</li></ul><p><strong>面试延伸</strong></p><ul><li>Spring Cloud 与 Kubernetes Service Mesh 的区别：前者 SDK 模式，后者 Sidecar 模式。</li></ul><hr><h2 id="2-Spring-Cloud-和-Dubbo-的区别？"><a href="#2-Spring-Cloud-和-Dubbo-的区别？" class="headerlink" title="2. Spring Cloud 和 Dubbo 的区别？"></a><strong>2. Spring Cloud 和 Dubbo 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Dubbo：高性能 RPC 框架，核心是远程调用。</li><li>Spring Cloud：全家桶式微服务生态，功能更全面。</li></ul><p><strong>深入原理</strong></p><ul><li>协议层：Dubbo 用 TCP&#x2F;自定义协议，性能高；Spring Cloud 多用 REST&#x2F;HTTP。</li><li>功能覆盖：Dubbo 主要做服务调用，Spring Cloud 包含注册、配置、熔断、网关等。</li><li>演进：Dubbo3.0 开始支持 gRPC&#x2F;Triple 协议，与 Spring Cloud 越来越接近。</li></ul><p><strong>面试延伸</strong></p><ul><li>公司内网场景（追求性能） → Dubbo；</li><li>大规模分布式互联网场景（追求生态） → Spring Cloud。</li></ul><hr><h2 id="3-Eureka-的工作原理？"><a href="#3-Eureka-的工作原理？" class="headerlink" title="3. Eureka 的工作原理？"></a><strong>3. Eureka 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Eureka 是 Netflix 开源的注册中心，负责 <strong>服务注册与发现</strong>，遵循 <strong>AP</strong> 原则。</p><p><strong>深入原理</strong></p><ul><li><strong>注册</strong>：服务启动后将自身信息（IP、端口、状态）注册到 Eureka Server。</li><li><strong>续约</strong>：服务定期发送心跳（默认 30s）。</li><li><strong>下线</strong>：服务关闭时发送下线请求。</li><li><strong>拉取</strong>：客户端定期从 Server 拉取注册表（默认 30s），本地缓存，提高可用性。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官可能问：Eureka 与 Zookeeper 区别？<ul><li>Eureka AP → 保证可用性（即使部分节点挂了仍能服务）；</li><li>Zookeeper CP → 强一致性（选举可能导致服务不可用）。</li></ul></li></ul><hr><h2 id="4-Eureka-的自我保护机制？"><a href="#4-Eureka-的自我保护机制？" class="headerlink" title="4. Eureka 的自我保护机制？"></a><strong>4. Eureka 的自我保护机制？</strong></h2><p><strong>核心回答</strong><br> Eureka 会在网络分区或心跳丢失时，<strong>不立即移除服务实例</strong>，保证可用性。</p><p><strong>深入原理</strong></p><ul><li>触发条件：在 15 分钟内心跳失败比例 &gt; 85%。</li><li>行为：<ul><li>暂停剔除失效服务。</li><li>保留已有注册表，允许客户端继续获取服务。</li></ul></li><li>好处：防止因网络抖动导致“服务雪崩”。</li></ul><p><strong>面试延伸</strong></p><ul><li>缺点：可能把已经宕机的实例继续暴露出去。</li><li>可配置 <code>eureka.server.enable-self-preservation=false</code> 来关闭。</li></ul><hr><h2 id="5-Ribbon-的负载均衡策略？"><a href="#5-Ribbon-的负载均衡策略？" class="headerlink" title="5. Ribbon 的负载均衡策略？"></a><strong>5. Ribbon 的负载均衡策略？</strong></h2><p><strong>核心回答</strong><br> Ribbon 是客户端负载均衡组件，常见策略有：</p><ul><li>轮询（RoundRobin）</li><li>随机（Random）</li><li>权重（WeightedResponseTimeRule）</li><li>最小并发（BestAvailableRule）</li></ul><p><strong>深入原理</strong><br> Ribbon 在客户端维护服务列表，从注册中心拉取后，根据策略选择目标服务发起请求。</p><p><strong>面试延伸</strong></p><ul><li>与 Nginx 的区别：Ribbon 是 <strong>客户端负载均衡</strong>（调用方决定），Nginx 是 <strong>服务端负载均衡</strong>（请求先到代理）。</li></ul><hr><h2 id="6-Ribbon-和-Nginx-的区别？"><a href="#6-Ribbon-和-Nginx-的区别？" class="headerlink" title="6. Ribbon 和 Nginx 的区别？"></a><strong>6. Ribbon 和 Nginx 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Ribbon：客户端负载均衡，本地决定调用哪台服务。</li><li>Nginx：服务端负载均衡，所有流量先经过代理。</li></ul><p><strong>深入原理</strong></p><ul><li><strong>部署位置</strong>：Ribbon 在调用方应用中，Nginx 独立部署。</li><li><strong>扩展性</strong>：Ribbon 与 Eureka 配合，支持动态上下线；Nginx 需手动改配置或借助 Consul&#x2F;Keepalived。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：为什么微服务更倾向于 Ribbon？<ul><li>因为客户端模式更灵活，可以无感知扩容&#x2F;缩容。</li></ul></li></ul><hr><h2 id="7-Feign-的工作原理？"><a href="#7-Feign-的工作原理？" class="headerlink" title="7. Feign 的工作原理？"></a><strong>7. Feign 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Feign 是声明式 HTTP 客户端，通过接口 + 注解的方式调用远程服务。</p><p><strong>深入原理</strong></p><ul><li>运行时基于 <strong>动态代理</strong>（JDK Proxy）。</li><li>结合 Ribbon 负载均衡，自动选择服务实例。</li><li>可集成 Hystrix&#x2F;Sentinel，支持熔断。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官问：Feign 和 RestTemplate 的区别？<ul><li>RestTemplate → 代码侵入性强，需要手动拼接请求。</li><li>Feign → 声明式，更优雅。</li></ul></li></ul><hr><h2 id="8-Feign-如何支持熔断？"><a href="#8-Feign-如何支持熔断？" class="headerlink" title="8. Feign 如何支持熔断？"></a><strong>8. Feign 如何支持熔断？</strong></h2><p><strong>核心回答</strong><br> Feign 可集成 Hystrix 或 Sentinel，通过 <strong>Fallback</strong> 提供降级逻辑。</p><p><strong>深入原理</strong></p><ul><li>Hystrix：在请求失败&#x2F;超时时调用 fallback 方法。</li><li>Sentinel：通过注解 @SentinelResource + fallback 实现。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：熔断和降级区别？<ul><li>熔断：保护系统不被拖垮。</li><li>降级：提供兜底逻辑，保证用户体验。</li></ul></li></ul><hr><h2 id="9-Hystrix-的工作原理？"><a href="#9-Hystrix-的工作原理？" class="headerlink" title="9. Hystrix 的工作原理？"></a><strong>9. Hystrix 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Hystrix 通过 <strong>线程池隔离 + 熔断器机制</strong> 保护服务，防止雪崩效应。</p><p><strong>深入原理</strong></p><ul><li><strong>线程池隔离</strong>：不同服务调用用不同线程池，避免相互影响。</li><li><strong>熔断机制</strong>：<ul><li>统计请求失败率。</li><li>达到阈值 → 熔断打开，直接走 fallback。</li><li>一段时间后 → 尝试半开，成功则恢复。</li></ul></li></ul><p><strong>面试延伸</strong></p><ul><li>Hystrix 已停止维护，推荐用 Resilience4j 或 Sentinel。</li></ul><hr><h2 id="10-Hystrix-的线程池隔离和信号量隔离？"><a href="#10-Hystrix-的线程池隔离和信号量隔离？" class="headerlink" title="10. Hystrix 的线程池隔离和信号量隔离？"></a><strong>10. Hystrix 的线程池隔离和信号量隔离？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>线程池隔离</strong>：每个依赖用独立线程池，适合耗时操作。</li><li><strong>信号量隔离</strong>：限制并发数，不开线程池，适合低延迟操作。</li></ul><p><strong>深入原理</strong></p><ul><li>线程池隔离：开销大，但最安全。</li><li>信号量隔离：轻量，但不能防止调用阻塞线程。</li></ul><p><strong>面试延伸</strong></p><ul><li>实战经验：大多数 IO 调用用线程池隔离，本地计算或轻量调用用信号量隔离。</li></ul><hr><h2 id="11-Resilience4j-和-Hystrix-区别？"><a href="#11-Resilience4j-和-Hystrix-区别？" class="headerlink" title="11. Resilience4j 和 Hystrix 区别？"></a><strong>11. Resilience4j 和 Hystrix 区别？</strong></h2><ul><li>Resilience4j 基于 Java 8 函数式接口，更轻量，支持熔断、限流、重试、隔离等；</li><li>Hystrix 已停止维护，功能单一（熔断+线程隔离）。</li><li>Resilience4j 模块化，可按需引入。</li></ul><hr><h2 id="12-Gateway-的核心功能？"><a href="#12-Gateway-的核心功能？" class="headerlink" title="12. Gateway 的核心功能？"></a><strong>12. Gateway 的核心功能？</strong></h2><ul><li><strong>路由转发</strong>（根据路径、Header、参数转发请求）。</li><li><strong>过滤器机制</strong>（统一鉴权、日志、限流）。</li><li><strong>负载均衡</strong>（结合注册中心）。</li><li><strong>协议支持</strong>（WebSocket、HTTPS）。</li></ul><hr><h2 id="13-Gateway-和-Zuul-的区别？"><a href="#13-Gateway-和-Zuul-的区别？" class="headerlink" title="13. Gateway 和 Zuul 的区别？"></a><strong>13. Gateway 和 Zuul 的区别？</strong></h2><ul><li>Zuul1 基于 Servlet，阻塞 IO，性能差。</li><li>Gateway 基于 Netty + Reactor，支持响应式，性能高。</li><li>Zuul2 虽然改为异步，但生态上 Gateway 更推荐。</li></ul><hr><h2 id="14-Config-Server-的作用？"><a href="#14-Config-Server-的作用？" class="headerlink" title="14. Config Server 的作用？"></a><strong>14. Config Server 的作用？</strong></h2><ul><li>统一管理微服务配置，支持 Git、SVN 等存储。</li><li>动态刷新配置，保证环境一致性。</li><li>与 Bus 结合可广播刷新。</li></ul><hr><h2 id="15-Config-Server-如何保证配置实时刷新？"><a href="#15-Config-Server-如何保证配置实时刷新？" class="headerlink" title="15. Config Server 如何保证配置实时刷新？"></a><strong>15. Config Server 如何保证配置实时刷新？</strong></h2><ul><li>客户端通过 <code>@RefreshScope</code> 实现动态刷新。</li><li>手动触发 <code>/actuator/refresh</code>。</li><li>结合 Spring Cloud Bus，可用消息队列广播刷新。</li></ul><hr><h2 id="16-Spring-Cloud-Bus-的原理？"><a href="#16-Spring-Cloud-Bus-的原理？" class="headerlink" title="16. Spring Cloud Bus 的原理？"></a><strong>16. Spring Cloud Bus 的原理？</strong></h2><ul><li>底层基于消息队列（Kafka、RabbitMQ）。</li><li>当配置变更时，Bus 广播事件，所有服务接收并刷新配置。</li></ul><hr><h2 id="17-Sleuth-的作用？"><a href="#17-Sleuth-的作用？" class="headerlink" title="17. Sleuth 的作用？"></a><strong>17. Sleuth 的作用？</strong></h2><ul><li>在微服务调用链路中，自动生成 <strong>TraceId &#x2F; SpanId</strong>。</li><li>实现请求链路追踪，定位性能瓶颈。</li></ul><hr><h2 id="18-Sleuth-与-Zipkin-的关系？"><a href="#18-Sleuth-与-Zipkin-的关系？" class="headerlink" title="18. Sleuth 与 Zipkin 的关系？"></a><strong>18. Sleuth 与 Zipkin 的关系？</strong></h2><ul><li>Sleuth：负责埋点、生成日志。</li><li>Zipkin：负责收集、存储、展示调用链数据。</li></ul><hr><h2 id="19-分布式链路追踪的原理？"><a href="#19-分布式链路追踪的原理？" class="headerlink" title="19. 分布式链路追踪的原理？"></a><strong>19. 分布式链路追踪的原理？</strong></h2><ul><li>通过唯一 TraceId 贯穿整个调用链。</li><li>每次远程调用生成新的 SpanId。</li><li>数据上报到集中式系统（Zipkin&#x2F;Jaeger）。</li></ul><hr><h2 id="20-Spring-Cloud-Stream-的作用？"><a href="#20-Spring-Cloud-Stream-的作用？" class="headerlink" title="20. Spring Cloud Stream 的作用？"></a><strong>20. Spring Cloud Stream 的作用？</strong></h2><ul><li>封装消息中间件（Kafka&#x2F;RabbitMQ）。</li><li>提供统一编程模型，屏蔽底层差异。</li><li>支持消息驱动架构。</li></ul><hr><h2 id="21-消息驱动模型和事件驱动模型区别？"><a href="#21-消息驱动模型和事件驱动模型区别？" class="headerlink" title="21. 消息驱动模型和事件驱动模型区别？"></a><strong>21. 消息驱动模型和事件驱动模型区别？</strong></h2><ul><li>消息驱动：强调解耦，消息可靠投递。</li><li>事件驱动：强调系统对事件的响应。</li><li>Spring Cloud Stream 更偏消息驱动，但也支持事件模式。</li></ul><hr><h2 id="22-Nacos-和-Eureka-的区别？"><a href="#22-Nacos-和-Eureka-的区别？" class="headerlink" title="22. Nacos 和 Eureka 的区别？"></a><strong>22. Nacos 和 Eureka 的区别？</strong></h2><ul><li>Nacos 除了服务注册发现，还提供配置中心功能。</li><li>Nacos 支持 <strong>AP&#x2F;CP 模式切换</strong>；Eureka 固定 AP。</li><li>Nacos 提供 UI，更易运维。</li></ul><hr><h2 id="23-Nacos-配置中心和注册中心的实现原理？"><a href="#23-Nacos-配置中心和注册中心的实现原理？" class="headerlink" title="23. Nacos 配置中心和注册中心的实现原理？"></a><strong>23. Nacos 配置中心和注册中心的实现原理？</strong></h2><ul><li>配置中心：基于推拉结合（长轮询 + Server 推送）。</li><li>注册中心：基于心跳机制维护服务健康状态。</li></ul><hr><h2 id="24-Sentinel-的工作原理？"><a href="#24-Sentinel-的工作原理？" class="headerlink" title="24. Sentinel 的工作原理？"></a><strong>24. Sentinel 的工作原理？</strong></h2><ul><li>基于 <strong>滑动窗口统计</strong> 请求 QPS、响应时间。</li><li>支持多种限流、熔断、降级规则。</li><li>与 Dubbo&#x2F;Spring Cloud&#x2F;Feign 无缝集成。</li></ul><hr><h2 id="25-限流的常见算法（令牌桶、漏桶）？"><a href="#25-限流的常见算法（令牌桶、漏桶）？" class="headerlink" title="25. 限流的常见算法（令牌桶、漏桶）？"></a><strong>25. 限流的常见算法（令牌桶、漏桶）？</strong></h2><ul><li><strong>令牌桶</strong>：系统以固定速率生成令牌，请求需拿到令牌才执行。</li><li><strong>漏桶</strong>：请求先进入桶，系统以固定速率处理，超出则丢弃。</li><li>区别：令牌桶允许突发流量，漏桶更平滑。</li></ul><hr><h2 id="26-熔断和降级的区别？"><a href="#26-熔断和降级的区别？" class="headerlink" title="26. 熔断和降级的区别？"></a><strong>26. 熔断和降级的区别？</strong></h2><ul><li>熔断：系统保护机制，拒绝调用，防止雪崩。</li><li>降级：业务兜底方案，返回备用结果。</li><li>熔断是“硬防护”，降级是“软兜底”。</li></ul><hr><h2 id="27-CAP-定理和-Spring-Cloud-的关系？"><a href="#27-CAP-定理和-Spring-Cloud-的关系？" class="headerlink" title="27. CAP 定理和 Spring Cloud 的关系？"></a><strong>27. CAP 定理和 Spring Cloud 的关系？</strong></h2><ul><li>CAP：一致性（C）、可用性（A）、分区容错性（P）。</li><li>Eureka → AP；Consul → CP；Nacos → AP&#x2F;CP 切换。</li></ul><hr><h2 id="28-Spring-Cloud-与-Kubernetes-的关系？"><a href="#28-Spring-Cloud-与-Kubernetes-的关系？" class="headerlink" title="28. Spring Cloud 与 Kubernetes 的关系？"></a><strong>28. Spring Cloud 与 Kubernetes 的关系？</strong></h2><ul><li>Spring Cloud：偏应用层，开发框架。</li><li>Kubernetes：偏基础设施，容器编排。</li><li>可结合使用：Spring Cloud 负责应用治理，K8s 负责资源调度。</li></ul><hr><h2 id="29-微服务中的灰度发布？"><a href="#29-微服务中的灰度发布？" class="headerlink" title="29. 微服务中的灰度发布？"></a><strong>29. 微服务中的灰度发布？</strong></h2><ul><li>指新版本只对部分用户开放。</li><li>实现方式：<ul><li>Nginx&#x2F;Gateway 按用户 ID 或流量比例路由。</li><li>Service Mesh（Istio）支持更灵活的流量控制。</li></ul></li></ul><hr><h2 id="30-Spring-Cloud-如何实现服务网格？"><a href="#30-Spring-Cloud-如何实现服务网格？" class="headerlink" title="30. Spring Cloud 如何实现服务网格？"></a><strong>30. Spring Cloud 如何实现服务网格？</strong></h2><ul><li>原生 Spring Cloud 偏 SDK 模式，缺乏服务网格能力。</li><li>可结合 <strong>Spring Cloud + Istio&#x2F;Envoy</strong>，实现流量治理、观测、熔断、灰度。</li><li>越来越多团队采用 <strong>Spring Cloud Alibaba + Service Mesh</strong> 的混合方案。</li></ul><hr><h2 id="六、微服务架构-分布式系统（30题）"><a href="#六、微服务架构-分布式系统（30题）" class="headerlink" title="六、微服务架构 &amp; 分布式系统（30题）"></a>六、微服务架构 &amp; 分布式系统（30题）</h2><hr><h2 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a><strong>1. 什么是微服务？</strong></h2><p><strong>核心回答</strong><br> 微服务是一种架构风格，将单体应用拆分为一组小型、独立部署的服务，每个服务聚焦某个业务能力，通过 API（HTTP&#x2F;gRPC&#x2F;MQ）通信。</p><p><strong>深入原理</strong></p><ul><li>每个服务独立开发、部署、扩容。</li><li>服务自治：有自己的数据库、缓存、逻辑。</li><li>通常结合容器化、CI&#x2F;CD、服务治理框架（如 Spring Cloud、Dubbo、K8s）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：和单体应用区别？ → 单体耦合度高，微服务解耦但更复杂。</li></ul><hr><h2 id="2-微服务与-SOA-的区别？"><a href="#2-微服务与-SOA-的区别？" class="headerlink" title="2. 微服务与 SOA 的区别？"></a><strong>2. 微服务与 SOA 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>SOA</strong>：面向服务的架构，通常依赖 ESB（企业服务总线）。</li><li><strong>微服务</strong>：轻量级、去中心化，强调小而独立，常用 REST&#x2F;gRPC。</li></ul><p><strong>深入原理</strong></p><ul><li>SOA → 偏企业内部，服务较大，依赖统一中间件（如 ESB）。</li><li>微服务 → 服务更小，避免单点中心，强调去中心化自治。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：为什么微服务比 SOA 更流行？ → 云原生背景下，微服务更适应敏捷开发和快速迭代。</li></ul><hr><h2 id="3-微服务的优缺点？"><a href="#3-微服务的优缺点？" class="headerlink" title="3. 微服务的优缺点？"></a><strong>3. 微服务的优缺点？</strong></h2><p><strong>核心回答</strong></p><ul><li>优点：独立部署、技术多样性、弹性伸缩、快速迭代。</li><li>缺点：分布式复杂性、运维难度高、数据一致性挑战、服务治理成本高。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官常问：什么时候不适合微服务？ → 业务小、团队小、系统简单时。</li></ul><hr><h2 id="4-微服务的拆分原则？"><a href="#4-微服务的拆分原则？" class="headerlink" title="4. 微服务的拆分原则？"></a><strong>4. 微服务的拆分原则？</strong></h2><p><strong>核心回答</strong></p><ul><li>按业务边界（DDD 的领域驱动设计）。</li><li>高内聚、低耦合。</li><li>一个服务只聚焦一个核心业务能力。</li></ul><p><strong>深入原理</strong></p><ul><li>拆分方式：按业务（订单、用户、支付）、按场景（核心 vs 辅助）、按非功能需求（性能瓶颈点）。</li></ul><p><strong>延伸思考</strong></p><ul><li>常见错误：按数据库表拆分，导致过度依赖跨服务调用。</li></ul><hr><h2 id="5-如何保证微服务之间的数据一致性？"><a href="#5-如何保证微服务之间的数据一致性？" class="headerlink" title="5. 如何保证微服务之间的数据一致性？"></a><strong>5. 如何保证微服务之间的数据一致性？</strong></h2><p><strong>核心回答</strong></p><ul><li>避免强一致，采用 <strong>最终一致性</strong>。</li><li>方案：分布式事务、消息驱动、补偿机制。</li></ul><p><strong>深入原理</strong></p><ul><li>同步方案：XA（两阶段提交）。</li><li>异步方案：TCC、SAGA、可靠消息。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官追问：你在项目中怎么做？ → 消息队列（事务消息&#x2F;本地消息表）。</li></ul><hr><h2 id="6-分布式事务有哪些解决方案？"><a href="#6-分布式事务有哪些解决方案？" class="headerlink" title="6. 分布式事务有哪些解决方案？"></a><strong>6. 分布式事务有哪些解决方案？</strong></h2><p><strong>核心回答</strong></p><ul><li>XA（两阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>SAGA（长事务补偿）</li><li>本地消息表 &#x2F; 事务消息</li></ul><p><strong>深入原理</strong></p><ul><li>XA：强一致性，但性能差。</li><li>TCC：业务入侵高，但灵活。</li><li>SAGA：长事务场景，失败时用补偿。</li><li>本地消息表：保证最终一致性。</li></ul><hr><h2 id="7-TCC、SAGA、XA-的区别？"><a href="#7-TCC、SAGA、XA-的区别？" class="headerlink" title="7. TCC、SAGA、XA 的区别？"></a><strong>7. TCC、SAGA、XA 的区别？</strong></h2><ul><li><strong>XA</strong>：数据库层两阶段提交，强一致，性能差。</li><li><strong>TCC</strong>：应用层三步（预留资源、确认、回滚），侵入性高。</li><li><strong>SAGA</strong>：长事务，每步都有补偿动作，保证最终一致性。</li></ul><hr><h2 id="8-本地消息表和可靠消息最终一致性？"><a href="#8-本地消息表和可靠消息最终一致性？" class="headerlink" title="8. 本地消息表和可靠消息最终一致性？"></a><strong>8. 本地消息表和可靠消息最终一致性？</strong></h2><ul><li>本地消息表：在本地事务中写业务表 + 消息表 → MQ 异步投递 → 消费端确认。</li><li>可靠消息：MQ 支持事务（如 RocketMQ 半消息），确保消息必达，保证最终一致性。</li></ul><hr><h2 id="9-分布式锁的实现方式？"><a href="#9-分布式锁的实现方式？" class="headerlink" title="9. 分布式锁的实现方式？"></a><strong>9. 分布式锁的实现方式？</strong></h2><ul><li>数据库锁（悲观锁&#x2F;唯一索引）。</li><li>Redis 分布式锁（setnx + expire）。</li><li>Zookeeper 分布式锁（临时顺序节点）。</li></ul><hr><h2 id="10-Redis-分布式锁的缺陷？"><a href="#10-Redis-分布式锁的缺陷？" class="headerlink" title="10. Redis 分布式锁的缺陷？"></a><strong>10. Redis 分布式锁的缺陷？</strong></h2><ul><li>单点问题（需 Redis Cluster 或 Redlock）。</li><li>锁过期可能导致误释放。</li><li>不能保证严格公平。</li></ul><hr><h2 id="11-Zookeeper-分布式锁的实现？"><a href="#11-Zookeeper-分布式锁的实现？" class="headerlink" title="11. Zookeeper 分布式锁的实现？"></a><strong>11. Zookeeper 分布式锁的实现？</strong></h2><ul><li>利用 <strong>临时顺序节点</strong>：<ul><li>客户端创建顺序节点。</li><li>判断自己是否是最小节点 → 获取锁。</li><li>不是则监听前一个节点的删除事件。</li></ul></li></ul><hr><h2 id="12-数据库分库分表策略？"><a href="#12-数据库分库分表策略？" class="headerlink" title="12. 数据库分库分表策略？"></a><strong>12. 数据库分库分表策略？</strong></h2><ul><li>垂直分库（按业务拆分）。</li><li>水平分表（按用户 ID、时间做分片）。</li><li>常见路由方式：哈希取模、范围、时间。</li></ul><hr><h2 id="13-水平拆分与垂直拆分区别？"><a href="#13-水平拆分与垂直拆分区别？" class="headerlink" title="13. 水平拆分与垂直拆分区别？"></a><strong>13. 水平拆分与垂直拆分区别？</strong></h2><ul><li><strong>水平拆分</strong>：同一张表的数据分到多个库表（按范围&#x2F;哈希）。</li><li><strong>垂直拆分</strong>：不同业务表放到不同库（用户库、订单库）。</li></ul><hr><h2 id="14-分布式-ID-生成方案？"><a href="#14-分布式-ID-生成方案？" class="headerlink" title="14. 分布式 ID 生成方案？"></a><strong>14. 分布式 ID 生成方案？</strong></h2><ul><li>UUID（无序，不适合数据库）。</li><li>数据库自增 ID（单点瓶颈）。</li><li>Redis 自增。</li><li>雪花算法（Snowflake）。</li><li>Leaf（美团开源）。</li></ul><hr><h2 id="15-雪花算法的原理？"><a href="#15-雪花算法的原理？" class="headerlink" title="15. 雪花算法的原理？"></a><strong>15. 雪花算法的原理？</strong></h2><ul><li>64 位长整型：<ul><li>时间戳（41 位）</li><li>机器 ID（10 位）</li><li>序列号（12 位）</li></ul></li><li>保证全局唯一、有序。</li></ul><hr><h2 id="16-API-网关的作用？"><a href="#16-API-网关的作用？" class="headerlink" title="16. API 网关的作用？"></a><strong>16. API 网关的作用？</strong></h2><ul><li>统一入口，做路由转发。</li><li>鉴权、安全控制。</li><li>流量控制、熔断、降级。</li><li>日志监控。</li></ul><hr><h2 id="17-服务注册与发现机制？"><a href="#17-服务注册与发现机制？" class="headerlink" title="17. 服务注册与发现机制？"></a><strong>17. 服务注册与发现机制？</strong></h2><ul><li>服务启动 → 注册中心注册（IP&#x2F;端口&#x2F;状态）。</li><li>调用方 → 从注册中心获取地址列表。</li><li>注册中心 → 通过心跳维持健康状态。</li></ul><hr><h2 id="18-微服务如何保证高可用？"><a href="#18-微服务如何保证高可用？" class="headerlink" title="18. 微服务如何保证高可用？"></a><strong>18. 微服务如何保证高可用？</strong></h2><ul><li>服务冗余（多实例部署）。</li><li>负载均衡。</li><li>熔断、降级、限流。</li><li>自动故障转移（K8s + 服务治理框架）。</li></ul><hr><h2 id="19-微服务中的限流和熔断？"><a href="#19-微服务中的限流和熔断？" class="headerlink" title="19. 微服务中的限流和熔断？"></a><strong>19. 微服务中的限流和熔断？</strong></h2><ul><li>限流：控制流量，保护系统（令牌桶&#x2F;漏桶）。</li><li>熔断：当下游服务异常时，直接失败并快速返回。</li></ul><hr><h2 id="20-微服务如何保证安全性？"><a href="#20-微服务如何保证安全性？" class="headerlink" title="20. 微服务如何保证安全性？"></a><strong>20. 微服务如何保证安全性？</strong></h2><ul><li>认证授权（OAuth2、JWT）。</li><li>HTTPS、加密通信。</li><li>API 网关统一鉴权。</li><li>数据脱敏。</li></ul><hr><h2 id="21-OAuth2-的原理？"><a href="#21-OAuth2-的原理？" class="headerlink" title="21. OAuth2 的原理？"></a><strong>21. OAuth2 的原理？</strong></h2><ul><li>基于令牌的认证授权协议。</li><li>四种模式：授权码、密码、客户端凭证、简化模式。</li><li>典型流程：用户 → 授权服务器 → 获取 Token → 调用资源服务器。</li></ul><hr><h2 id="22-JWT-的作用？"><a href="#22-JWT-的作用？" class="headerlink" title="22. JWT 的作用？"></a><strong>22. JWT 的作用？</strong></h2><ul><li>JSON Web Token，一种无状态令牌。</li><li>内容包含三部分：Header、Payload、Signature。</li><li>适合分布式系统做认证，无需存储 Session。</li></ul><hr><h2 id="23-单点登录-SSO-的实现？"><a href="#23-单点登录-SSO-的实现？" class="headerlink" title="23. 单点登录 SSO 的实现？"></a><strong>23. 单点登录 SSO 的实现？</strong></h2><ul><li>用户只需登录一次，获取全局 Token&#x2F;Session。</li><li>常见实现：CAS、OAuth2、JWT。</li><li>核心：统一认证中心。</li></ul><hr><h2 id="24-配置中心的作用？"><a href="#24-配置中心的作用？" class="headerlink" title="24. 配置中心的作用？"></a><strong>24. 配置中心的作用？</strong></h2><ul><li>集中化配置管理。</li><li>支持动态刷新。</li><li>环境隔离（dev&#x2F;test&#x2F;prod）。</li></ul><hr><h2 id="25-微服务中的监控体系？"><a href="#25-微服务中的监控体系？" class="headerlink" title="25. 微服务中的监控体系？"></a><strong>25. 微服务中的监控体系？</strong></h2><ul><li>指标监控：Prometheus + Grafana。</li><li>日志监控：ELK（Elasticsearch + Logstash + Kibana）。</li><li>链路追踪：Sleuth + Zipkin&#x2F;Jaeger。</li></ul><hr><h2 id="26-Prometheus-的原理？"><a href="#26-Prometheus-的原理？" class="headerlink" title="26. Prometheus 的原理？"></a><strong>26. Prometheus 的原理？</strong></h2><ul><li>基于 Pull 模型，定期从应用&#x2F;Exporter 拉取指标。</li><li>TSDB（时间序列数据库）存储数据。</li><li>结合 Grafana 做可视化。</li></ul><hr><h2 id="27-ELK-在微服务中的应用？"><a href="#27-ELK-在微服务中的应用？" class="headerlink" title="27. ELK 在微服务中的应用？"></a><strong>27. ELK 在微服务中的应用？</strong></h2><ul><li>Logstash：日志采集。</li><li>Elasticsearch：日志存储、搜索。</li><li>Kibana：日志分析、可视化。</li><li>用于统一日志平台。</li></ul><hr><h2 id="28-服务调用链路追踪的意义？"><a href="#28-服务调用链路追踪的意义？" class="headerlink" title="28. 服务调用链路追踪的意义？"></a><strong>28. 服务调用链路追踪的意义？</strong></h2><ul><li>解决“调用链不清楚”的问题。</li><li>快速定位性能瓶颈、错误位置。</li><li>提升运维可观测性。</li></ul><hr><h2 id="29-服务雪崩效应是什么？"><a href="#29-服务雪崩效应是什么？" class="headerlink" title="29. 服务雪崩效应是什么？"></a><strong>29. 服务雪崩效应是什么？</strong></h2><ul><li>一个服务故障 → 引发调用它的服务故障 → 最终导致整个系统崩溃。</li><li>原因：依赖调用无保护（无熔断&#x2F;限流）。</li></ul><hr><h2 id="30-如何设计一个高并发的微服务系统？"><a href="#30-如何设计一个高并发的微服务系统？" class="headerlink" title="30. 如何设计一个高并发的微服务系统？"></a><strong>30. 如何设计一个高并发的微服务系统？</strong></h2><p><strong>核心思路</strong></p><ul><li>架构：微服务 + API 网关 + 服务治理。</li><li>高可用：负载均衡、多副本、自动故障转移。</li><li>高性能：缓存（Redis）、异步化、限流、降级。</li><li>数据层：分库分表、读写分离。</li><li>安全：OAuth2&#x2F;JWT。</li><li>可观测性：监控 + 日志 + 链路追踪。</li></ul><hr><h2 id="七、数据库-缓存（30题）"><a href="#七、数据库-缓存（30题）" class="headerlink" title="七、数据库 &amp; 缓存（30题）"></a>七、数据库 &amp; 缓存（30题）</h2><hr><h2 id="1-MySQL-的存储引擎区别"><a href="#1-MySQL-的存储引擎区别" class="headerlink" title="1. MySQL 的存储引擎区别"></a><strong>1. MySQL 的存储引擎区别</strong></h2><ul><li><strong>存储引擎</strong>是 MySQL 管理数据的底层组件，决定了数据存储方式、事务支持、锁机制、索引支持等。</li><li><strong>主要存储引擎</strong>：<ul><li><strong>InnoDB</strong>：事务型，支持行级锁、外键、MVCC、崩溃恢复。适合高并发、事务要求高的场景。</li><li><strong>MyISAM</strong>：非事务型，表级锁，支持全文索引。适合读多写少、日志或统计类表。</li><li><strong>Memory</strong>：数据存储在内存中，访问速度快，但断电数据丢失。适合临时表。</li><li><strong>Archive</strong>：归档引擎，只支持插入和查询，不支持更新，压缩存储。</li></ul></li><li><strong>面试重点</strong>：<ul><li>选择存储引擎需根据业务需求：事务要求、并发量、数据量和恢复策略。</li></ul></li></ul><hr><h2 id="2-InnoDB-和-MyISAM-的区别"><a href="#2-InnoDB-和-MyISAM-的区别" class="headerlink" title="2. InnoDB 和 MyISAM 的区别"></a><strong>2. InnoDB 和 MyISAM 的区别</strong></h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持 ACID</td><td>不支持</td></tr><tr><td>锁类型</td><td>行级锁+表锁</td><td>表级锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>崩溃恢复</td><td>自动恢复</td><td>需手动修复</td></tr><tr><td>全文索引</td><td>5.6+ 支持</td><td>支持</td></tr><tr><td>并发场景</td><td>高并发写+读</td><td>读多写少</td></tr><tr><td>适用案例</td><td>金融、电商订单</td><td>日志分析、统计表</td></tr></tbody></table><hr><h2 id="3-MySQL-事务特性"><a href="#3-MySQL-事务特性" class="headerlink" title="3. MySQL 事务特性"></a><strong>3. MySQL 事务特性</strong></h2><ul><li><strong>ACID 原则</strong>：<ol><li><strong>原子性（Atomic）</strong>：事务全部执行或全部回滚。</li><li><strong>一致性（Consistency）</strong>：事务执行前后数据库状态合法。</li><li><strong>隔离性（Isolation）</strong>：事务互不干扰。</li><li><strong>持久性（Durability）</strong>：提交后数据不会丢失。</li></ol></li><li><strong>隔离级别</strong>：<ul><li><strong>Read Uncommitted</strong>：允许脏读。</li><li><strong>Read Committed</strong>：防止脏读，但可能不可重复读。</li><li><strong>Repeatable Read（默认 InnoDB）</strong>：防止不可重复读，间隙锁解决幻读。</li><li><strong>Serializable</strong>：完全串行执行，性能最低，但完全隔离。</li></ul></li><li><strong>面试追问</strong>：隔离级别与死锁、性能的权衡。</li></ul><hr><h2 id="4-MVCC-的实现原理"><a href="#4-MVCC-的实现原理" class="headerlink" title="4. MVCC 的实现原理"></a><strong>4. MVCC 的实现原理</strong></h2><ul><li><strong>原理</strong>：<ul><li>InnoDB 为每行增加隐藏列 <code>trx_id</code> 和 <code>roll_pointer</code>。</li><li>查询时根据事务 ID 判断哪一版本可见。</li><li>读操作不阻塞写操作，实现 <strong>非阻塞读</strong>。</li></ul></li><li><strong>应用</strong>：提高并发性能，避免读写互相阻塞。</li><li><strong>面试追问</strong>：MVCC 如何实现 Repeatable Read，为什么不锁表。</li></ul><hr><h2 id="5-MySQL-的索引类型"><a href="#5-MySQL-的索引类型" class="headerlink" title="5. MySQL 的索引类型"></a><strong>5. MySQL 的索引类型</strong></h2><ul><li><strong>B+ 树索引</strong>：范围查询、排序，叶子节点按顺序连接。</li><li><strong>哈希索引</strong>：精确查找快（Memory 引擎）。</li><li><strong>全文索引</strong>：文本搜索。</li><li><strong>空间索引</strong>：地理信息查询（R-Tree）。</li><li><strong>面试追问</strong>：什么时候选择组合索引，覆盖索引优化查询。</li></ul><hr><h2 id="6-聚簇索引-vs-非聚簇索引"><a href="#6-聚簇索引-vs-非聚簇索引" class="headerlink" title="6. 聚簇索引 vs 非聚簇索引"></a><strong>6. 聚簇索引 vs 非聚簇索引</strong></h2><ul><li><strong>聚簇索引</strong>：<ul><li>数据行存储顺序与主键顺序一致。</li><li>查询范围、排序效率高。</li></ul></li><li><strong>非聚簇索引</strong>：<ul><li>索引存 key + 主键，回表获取其他字段。</li></ul></li><li><strong>面试追问</strong>：聚簇索引插入顺序对性能影响，回表成本。</li></ul><hr><h2 id="7-B-树索引原理"><a href="#7-B-树索引原理" class="headerlink" title="7. B+ 树索引原理"></a><strong>7. B+ 树索引原理</strong></h2><ul><li>内节点：存 key + 子节点指针</li><li>叶子节点：存完整记录或指针，并链表连接</li><li><strong>特点</strong>：<ul><li>支持范围查询</li><li>磁盘 IO 高效</li></ul></li><li><strong>面试追问</strong>：为什么 MySQL 选择 B+ 树而不是 B 树或 Hash。</li></ul><hr><h2 id="8-覆盖索引-vs-回表"><a href="#8-覆盖索引-vs-回表" class="headerlink" title="8. 覆盖索引 vs 回表"></a><strong>8. 覆盖索引 vs 回表</strong></h2><ul><li><strong>覆盖索引</strong>：索引包含所有查询字段，无需访问表。</li><li><strong>回表</strong>：索引只包含部分字段，需要通过主键查表。</li><li><strong>优化方法</strong>：尽量让热点查询使用覆盖索引，减少 IO。</li></ul><hr><h2 id="9-索引下推优化"><a href="#9-索引下推优化" class="headerlink" title="9. 索引下推优化"></a><strong>9. 索引下推优化</strong></h2><ul><li>WHERE 条件在存储引擎层过滤，减少返回上层的数据量。</li><li>特别在组合索引或函数查询时有效。</li><li><strong>面试追问</strong>：索引下推能否应用于非 InnoDB 存储引擎。</li></ul><hr><h2 id="10-MySQL-锁机制"><a href="#10-MySQL-锁机制" class="headerlink" title="10. MySQL 锁机制"></a><strong>10. MySQL 锁机制</strong></h2><ul><li><strong>表锁</strong>：锁整张表，低并发。</li><li><strong>行锁</strong>：锁单行，InnoDB 默认。</li><li><strong>意向锁</strong>：表级锁意图，避免死锁。</li><li><strong>间隙锁</strong>：防止幻读。</li><li><strong>面试追问</strong>：行锁、表锁的实现原理，锁冲突如何处理。</li></ul><hr><h2 id="11-行锁-vs-表锁"><a href="#11-行锁-vs-表锁" class="headerlink" title="11. 行锁 vs 表锁"></a><strong>11. 行锁 vs 表锁</strong></h2><ul><li>行锁：粒度小，高并发，事务安全。</li><li>表锁：粒度大，适合批量操作。</li><li><strong>应用场景</strong>：高并发写用行锁，批量更新可用表锁。</li></ul><hr><h2 id="12-间隙锁"><a href="#12-间隙锁" class="headerlink" title="12. 间隙锁"></a><strong>12. 间隙锁</strong></h2><ul><li>锁定索引间隙，防止其他事务插入幻读。</li><li>与记录锁结合形成 <strong>Next-Key Lock</strong>。</li><li>默认在 Repeatable Read 下使用。</li></ul><hr><h2 id="13-死锁排查"><a href="#13-死锁排查" class="headerlink" title="13. 死锁排查"></a><strong>13. 死锁排查</strong></h2><ul><li><code>SHOW ENGINE INNODB STATUS\G</code> 查看最新死锁。</li><li>优化：<ol><li>统一访问表顺序。</li><li>尽量缩短事务时间。</li><li>加索引减少扫描行数。</li></ol></li></ul><hr><h2 id="14-SQL-执行计划"><a href="#14-SQL-执行计划" class="headerlink" title="14. SQL 执行计划"></a><strong>14. SQL 执行计划</strong></h2><ul><li>使用 <code>EXPLAIN</code> 分析：<ul><li>type：访问类型（ALL &lt; INDEX &lt; REF &lt; CONST）</li><li>key：使用的索引</li><li>rows：扫描行数</li><li>Extra：如 Using index, Using temporary</li></ul></li></ul><hr><h2 id="15-慢查询优化"><a href="#15-慢查询优化" class="headerlink" title="15. 慢查询优化"></a><strong>15. 慢查询优化</strong></h2><ul><li>建索引（覆盖索引、组合索引）</li><li>避免 SELECT *</li><li>避免在列上函数操作</li><li>分库分表</li><li>缓存（Redis&#x2F;Caffeine）</li></ul><hr><h2 id="16-分库分表难点"><a href="#16-分库分表难点" class="headerlink" title="16. 分库分表难点"></a><strong>16. 分库分表难点</strong></h2><ul><li>跨库 join、分页</li><li>分布式事务</li><li>全局唯一 ID</li><li>数据路由、迁移</li></ul><hr><h2 id="17-分布式事务"><a href="#17-分布式事务" class="headerlink" title="17. 分布式事务"></a><strong>17. 分布式事务</strong></h2><ul><li><strong>XA</strong>：两阶段提交，保证强一致性。</li><li><strong>TCC</strong>：Try → Confirm → Cancel，业务补偿操作。</li><li><strong>SAGA</strong>：长事务补偿。</li><li><strong>本地消息表 + MQ</strong>：最终一致性。</li></ul><hr><h2 id="18-Redis-数据结构"><a href="#18-Redis-数据结构" class="headerlink" title="18. Redis 数据结构"></a><strong>18. Redis 数据结构</strong></h2><ul><li><strong>String</strong>、<strong>Hash</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Sorted Set</strong></li><li>Bitmap、HyperLogLog、Geo</li><li>应用：排行榜、计数、集合操作、地理位置、布隆过滤器</li></ul><hr><h2 id="19-Redis-为什么快"><a href="#19-Redis-为什么快" class="headerlink" title="19. Redis 为什么快"></a><strong>19. Redis 为什么快</strong></h2><ul><li>全内存存储</li><li>单线程 + epoll</li><li>高效数据结构</li><li>避免锁竞争</li></ul><hr><h2 id="20-Redis-持久化"><a href="#20-Redis-持久化" class="headerlink" title="20. Redis 持久化"></a><strong>20. Redis 持久化</strong></h2><ul><li><strong>RDB</strong>：定期快照</li><li><strong>AOF</strong>：写命令日志，append only</li><li><strong>混合持久化</strong>：RDB + AOF，提高安全性与效率</li></ul><hr><h2 id="21-Redis-过期策略"><a href="#21-Redis-过期策略" class="headerlink" title="21. Redis 过期策略"></a><strong>21. Redis 过期策略</strong></h2><ul><li><strong>惰性删除</strong>：访问时检查 TTL</li><li><strong>定期删除</strong>：周期性扫描</li><li><strong>定时删除</strong>：每个 key 单独定时器</li></ul><hr><h2 id="22-Redis-内存淘汰策略"><a href="#22-Redis-内存淘汰策略" class="headerlink" title="22. Redis 内存淘汰策略"></a><strong>22. Redis 内存淘汰策略</strong></h2><ul><li>noeviction、allkeys-lru、volatile-lru、allkeys-lfu、volatile-ttl</li><li>LRU：最近最少使用</li><li>LFU：使用频率最低</li><li>TTL：临期优先淘汰</li></ul><hr><h2 id="23-Redis-主从复制"><a href="#23-Redis-主从复制" class="headerlink" title="23. Redis 主从复制"></a><strong>23. Redis 主从复制</strong></h2><ul><li>异步复制</li><li>全量复制 + 增量复制</li><li>读写分离，提升扩展性</li></ul><hr><h2 id="24-Redis-哨兵机制"><a href="#24-Redis-哨兵机制" class="headerlink" title="24. Redis 哨兵机制"></a><strong>24. Redis 哨兵机制</strong></h2><ul><li>监控、通知、故障转移</li><li>Sentinel 投票机制切换主节点</li><li>高可用架构核心组件</li></ul><hr><h2 id="25-Redis-集群模式"><a href="#25-Redis-集群模式" class="headerlink" title="25. Redis 集群模式"></a><strong>25. Redis 集群模式</strong></h2><ul><li>16384 个哈希槽分片</li><li>Master + Slave</li><li>跨槽操作有限制</li><li>高可用 + 水平扩展</li></ul><hr><h2 id="26-Redis-分布式锁"><a href="#26-Redis-分布式锁" class="headerlink" title="26. Redis 分布式锁"></a><strong>26. Redis 分布式锁</strong></h2><ul><li><strong>单机</strong>：SETNX + EXPIRE</li><li><strong>Redisson</strong>：<ul><li>自动续期（看门狗机制）</li><li>可重入锁</li><li>公平锁</li></ul></li><li><strong>RedLock</strong>：多节点强一致性</li></ul><hr><h2 id="27-Redis-常见问题"><a href="#27-Redis-常见问题" class="headerlink" title="27. Redis 常见问题"></a><strong>27. Redis 常见问题</strong></h2><ul><li>内存不足 &#x2F; OOM</li><li>热点 key</li><li>bigkey 导致阻塞</li><li>RDB fork 阻塞</li><li>主从延迟</li></ul><hr><h2 id="28-缓存穿透、击穿、雪崩"><a href="#28-缓存穿透、击穿、雪崩" class="headerlink" title="28. 缓存穿透、击穿、雪崩"></a><strong>28. 缓存穿透、击穿、雪崩</strong></h2><ul><li><strong>穿透</strong>：不存在数据频繁访问 → 布隆过滤器</li><li><strong>击穿</strong>：热点 key 瞬间失效 → 互斥锁&#x2F;永不过期缓存</li><li><strong>雪崩</strong>：大量 key 同时过期 → TTL + 随机值</li></ul><hr><h2 id="29-缓存与数据库一致性"><a href="#29-缓存与数据库一致性" class="headerlink" title="29. 缓存与数据库一致性"></a><strong>29. 缓存与数据库一致性</strong></h2><ul><li><strong>Cache Aside</strong>：先 DB，再删缓存</li><li><strong>双写</strong>：DB + 缓存同步更新</li><li><strong>异步消息</strong>：MQ + 延时队列，实现最终一致性</li></ul><hr><h2 id="30-Redis-vs-Caffeine"><a href="#30-Redis-vs-Caffeine" class="headerlink" title="30. Redis vs Caffeine"></a><strong>30. Redis vs Caffeine</strong></h2><table><thead><tr><th>特性</th><th>Redis</th><th>Caffeine</th></tr></thead><tbody><tr><td>类型</td><td>分布式缓存</td><td>本地缓存</td></tr><tr><td>持久化</td><td>RDB &#x2F; AOF</td><td>不支持</td></tr><tr><td>集群</td><td>支持</td><td>不支持</td></tr><tr><td>访问速度</td><td>毫秒级</td><td>纳秒级</td></tr><tr><td>场景</td><td>分布式共享，高并发</td><td>本地热点缓存</td></tr></tbody></table><p><strong>最佳实践</strong>：Caffeine（本地缓存）+ Redis（分布式缓存）+ DB → 多级缓存结构。</p><hr><h2 id="八、消息队列（30题）"><a href="#八、消息队列（30题）" class="headerlink" title="八、消息队列（30题）"></a>八、消息队列（30题）</h2><hr><h2 id="1-为什么要使用消息队列？"><a href="#1-为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用消息队列？"></a><strong>1. 为什么要使用消息队列？</strong></h2><ul><li><strong>解耦系统</strong>：生产者与消费者不直接调用，通过队列传递消息。</li><li><strong>异步处理</strong>：用户请求不等待后端业务完成，提高响应速度。</li><li><strong>削峰填谷</strong>：缓冲高峰流量，避免数据库或服务压力过大。</li><li><strong>可靠传输</strong>：通过持久化、ACK 机制保证消息不丢失。</li><li><strong>可扩展性</strong>：增加消费者可水平扩展，提高系统吞吐量。</li><li><strong>面试追问</strong>：为什么 MQ 可以解决微服务间耦合问题？</li></ul><hr><h2 id="2-消息队列的优缺点"><a href="#2-消息队列的优缺点" class="headerlink" title="2. 消息队列的优缺点"></a><strong>2. 消息队列的优缺点</strong></h2><ul><li><strong>优点</strong>：<ul><li>异步处理提升吞吐量</li><li>系统解耦</li><li>支持削峰填谷</li><li>消息可靠性可控</li></ul></li><li><strong>缺点</strong>：<ul><li>系统复杂度增加</li><li>消息延迟</li><li>顺序和重复消费需要额外处理</li></ul></li><li><strong>优化点</strong>：结合幂等设计、延迟队列和批量处理</li></ul><hr><h2 id="3-RabbitMQ-核心组件"><a href="#3-RabbitMQ-核心组件" class="headerlink" title="3. RabbitMQ 核心组件"></a><strong>3. RabbitMQ 核心组件</strong></h2><ul><li><strong>Producer</strong>：发送消息</li><li><strong>Exchange</strong>：路由消息（Direct、Fanout、Topic、Headers）</li><li><strong>Queue</strong>：存储消息</li><li><strong>Binding</strong>：绑定 Exchange 和 Queue</li><li><strong>Consumer</strong>：接收消息</li><li><strong>原理</strong>：Exchange 决定路由规则，Queue 负责缓冲和投递</li></ul><hr><h2 id="4-RabbitMQ-消息确认机制"><a href="#4-RabbitMQ-消息确认机制" class="headerlink" title="4. RabbitMQ 消息确认机制"></a><strong>4. RabbitMQ 消息确认机制</strong></h2><ul><li><strong>生产者端</strong>：<ul><li>Publisher Confirm，确保消息写入 Broker</li></ul></li><li><strong>消费者端</strong>：<ul><li>自动 ack：消费即确认</li><li>手动 ack：成功处理后确认</li></ul></li><li><strong>应用实践</strong>：手动 ack 可处理异常重试，保证消息不丢失</li></ul><hr><h2 id="5-Kafka-核心概念"><a href="#5-Kafka-核心概念" class="headerlink" title="5. Kafka 核心概念"></a><strong>5. Kafka 核心概念</strong></h2><ul><li><strong>Producer&#x2F;Consumer</strong>：消息发送和接收</li><li><strong>Topic&#x2F;Partition</strong>：主题和分区</li><li><strong>Broker&#x2F;Cluster</strong>：节点和集群</li><li><strong>Consumer Group</strong>：消费组实现负载均衡</li><li><strong>Offset</strong>：记录消费位置</li><li><strong>原理</strong>：生产者写入 Partition，消费者根据 Offset 消费</li></ul><hr><h2 id="6-Kafka-分区机制"><a href="#6-Kafka-分区机制" class="headerlink" title="6. Kafka 分区机制"></a><strong>6. Kafka 分区机制</strong></h2><ul><li><strong>Partition 提高并行</strong></li><li><strong>分区内顺序保证</strong></li><li><strong>路由策略</strong>：默认轮询，或 Key 哈希分区</li><li><strong>面试点</strong>：如何保证全局顺序？只能保证分区内顺序</li></ul><hr><h2 id="7-Kafka-副本机制"><a href="#7-Kafka-副本机制" class="headerlink" title="7. Kafka 副本机制"></a><strong>7. Kafka 副本机制</strong></h2><ul><li><strong>Leader&#x2F;Follower 结构</strong></li><li><strong>同步机制</strong>：ISR 列表跟随 Leader</li><li><strong>高可用</strong>：Leader 异常自动切换</li><li><strong>面试拓展</strong>：副本同步模式对性能的影响</li></ul><hr><h2 id="8-Kafka-ISR-原理"><a href="#8-Kafka-ISR-原理" class="headerlink" title="8. Kafka ISR 原理"></a><strong>8. Kafka ISR 原理</strong></h2><ul><li><strong>ISR（In-Sync Replicas）</strong>：跟上 Leader 的副本集合</li><li><strong>消息提交规则</strong>：只要 ISR 内副本写入才算成功</li><li><strong>优化</strong>：副本数量与 ACK 策略可调节可靠性与吞吐量</li></ul><hr><h2 id="9-Kafka-消费组原理"><a href="#9-Kafka-消费组原理" class="headerlink" title="9. Kafka 消费组原理"></a><strong>9. Kafka 消费组原理</strong></h2><ul><li>同一组内的每个 Partition 只被一个 Consumer 消费</li><li>多组可重复消费，实现广播</li><li>提高并行消费，减少重复消费</li><li><strong>拓展</strong>：消费组重平衡、再均衡机制</li></ul><hr><h2 id="10-Kafka-Offset-提交方式"><a href="#10-Kafka-Offset-提交方式" class="headerlink" title="10. Kafka Offset 提交方式"></a><strong>10. Kafka Offset 提交方式</strong></h2><ul><li>自动提交：消费完成后自动提交 Offset</li><li>手动提交：<ul><li>同步提交：阻塞等待</li><li>异步提交：性能高，可能丢少量消息</li></ul></li><li><strong>实践</strong>：结合事务实现 Exactly Once</li></ul><hr><h2 id="11-Kafka-高吞吐量原理"><a href="#11-Kafka-高吞吐量原理" class="headerlink" title="11. Kafka 高吞吐量原理"></a><strong>11. Kafka 高吞吐量原理</strong></h2><ul><li>顺序写磁盘，避免随机 IO</li><li>批量发送消息，减少网络开销</li><li>零拷贝机制，减少 CPU 消耗</li><li><strong>面试拓展</strong>：如何调整批量大小提高吞吐量</li></ul><hr><h2 id="12-Kafka-零拷贝机制"><a href="#12-Kafka-零拷贝机制" class="headerlink" title="12. Kafka 零拷贝机制"></a><strong>12. Kafka 零拷贝机制</strong></h2><ul><li>直接从磁盘 buffer 传到网络 buffer，无用户态复制</li><li>利用 sendfile() 提升大流量传输效率</li></ul><hr><h2 id="13-RocketMQ-核心特点"><a href="#13-RocketMQ-核心特点" class="headerlink" title="13. RocketMQ 核心特点"></a><strong>13. RocketMQ 核心特点</strong></h2><ul><li>高可靠，高性能</li><li>顺序消息、事务消息原生支持</li><li>Broker 无状态，易水平扩展</li><li>支持多语言客户端</li><li>消息存储：CommitLog + ConsumeQueue + IndexFile</li></ul><hr><h2 id="14-RocketMQ-顺序消息"><a href="#14-RocketMQ-顺序消息" class="headerlink" title="14. RocketMQ 顺序消息"></a><strong>14. RocketMQ 顺序消息</strong></h2><ul><li>通过 Key 哈希映射到队列</li><li>队列内顺序严格保证</li><li>应用场景：订单支付、流水处理</li></ul><hr><h2 id="15-RocketMQ-事务消息"><a href="#15-RocketMQ-事务消息" class="headerlink" title="15. RocketMQ 事务消息"></a><strong>15. RocketMQ 事务消息</strong></h2><ul><li><strong>半消息机制</strong>：<ol><li>发送半消息到 Broker</li><li>执行本地事务</li><li>提交或回滚消息</li></ol></li><li>保证分布式事务最终一致性</li></ul><hr><h2 id="16-如何保证消息不丢失"><a href="#16-如何保证消息不丢失" class="headerlink" title="16. 如何保证消息不丢失"></a><strong>16. 如何保证消息不丢失</strong></h2><ul><li><strong>生产者端</strong>：确认机制</li><li><strong>Broker端</strong>：消息持久化</li><li><strong>消费者端</strong>：手动 ack + 幂等消费</li></ul><hr><h2 id="17-如何保证消息不重复消费"><a href="#17-如何保证消息不重复消费" class="headerlink" title="17. 如何保证消息不重复消费"></a><strong>17. 如何保证消息不重复消费</strong></h2><ul><li>消息幂等：唯一 ID + 数据库唯一约束 + Redis 去重</li><li>Kafka Exactly Once + 事务处理</li></ul><hr><h2 id="18-如何保证消息有序"><a href="#18-如何保证消息有序" class="headerlink" title="18. 如何保证消息有序"></a><strong>18. 如何保证消息有序</strong></h2><ul><li><strong>Kafka</strong>：Partition 内顺序</li><li><strong>RocketMQ</strong>：队列内顺序</li><li><strong>注意</strong>：多 Partition 并行可能导致整体无序</li></ul><hr><h2 id="19-消息堆积解决办法"><a href="#19-消息堆积解决办法" class="headerlink" title="19. 消息堆积解决办法"></a><strong>19. 消息堆积解决办法</strong></h2><ul><li>增加消费者数量</li><li>扩展队列分区</li><li>流量削峰</li><li>消费端批量处理，提高吞吐量</li></ul><hr><h2 id="20-如何设计延迟队列"><a href="#20-如何设计延迟队列" class="headerlink" title="20. 如何设计延迟队列"></a><strong>20. 如何设计延迟队列</strong></h2><ul><li><strong>RabbitMQ</strong>：TTL + Dead Letter Queue</li><li><strong>Kafka</strong>：延迟消息插件 &#x2F; 时间轮</li><li><strong>Redis</strong>：SortedSet + 轮询</li><li><strong>场景</strong>：订单超时、短信延迟发送</li></ul><hr><h2 id="21-死信队列作用"><a href="#21-死信队列作用" class="headerlink" title="21. 死信队列作用"></a><strong>21. 死信队列作用</strong></h2><ul><li>消费失败消息收集到死信队列</li><li>支持重试、告警和问题排查</li><li>提高系统可靠性</li></ul><hr><h2 id="22-幂等实现方式"><a href="#22-幂等实现方式" class="headerlink" title="22. 幂等实现方式"></a><strong>22. 幂等实现方式</strong></h2><ul><li>消息唯一 ID</li><li>数据库唯一约束</li><li>Redis 去重缓存</li><li>本地事务结合 MQ 保证幂等</li></ul><hr><h2 id="23-消息队列限流方式"><a href="#23-消息队列限流方式" class="headerlink" title="23. 消息队列限流方式"></a><strong>23. 消息队列限流方式</strong></h2><ul><li>消费者限流：处理速率限制</li><li>生产者限流：令牌桶&#x2F;漏桶</li><li>Broker 队列容量限制 + 拒绝策略</li></ul><hr><h2 id="24-消息队列监控"><a href="#24-消息队列监控" class="headerlink" title="24. 消息队列监控"></a><strong>24. 消息队列监控</strong></h2><ul><li>消息堆积量</li><li>消费速率</li><li>Broker 健康状态</li><li>延迟时间</li><li>工具：Prometheus + Grafana、Kafka Manager、RocketMQ Console、RabbitMQ Management</li></ul><hr><h2 id="25-Kafka-vs-RabbitMQ"><a href="#25-Kafka-vs-RabbitMQ" class="headerlink" title="25. Kafka vs RabbitMQ"></a><strong>25. Kafka vs RabbitMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>模型</td><td>Pub&#x2F;Sub + Queue</td><td>AMQP</td></tr><tr><td>消息存储</td><td>持久化日志</td><td>队列存储</td></tr><tr><td>顺序保证</td><td>Partition 内顺序</td><td>队列顺序</td></tr><tr><td>高吞吐</td><td>高（批量 + 零拷贝）</td><td>中等</td></tr><tr><td>消费模式</td><td>Pull &#x2F; Push</td><td>Push</td></tr><tr><td>使用场景</td><td>大数据流、日志、事件驱动</td><td>任务队列、异步处理、可靠投递</td></tr></tbody></table><hr><h2 id="26-Kafka-vs-RocketMQ"><a href="#26-Kafka-vs-RocketMQ" class="headerlink" title="26. Kafka vs RocketMQ"></a><strong>26. Kafka vs RocketMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>顺序消息</td><td>Partition 内顺序</td><td>队列内顺序全局可控</td></tr><tr><td>事务消息</td><td>限制较多</td><td>原生支持</td></tr><tr><td>存储方式</td><td>CommitLog</td><td>CommitLog + ConsumeQueue + IndexFile</td></tr><tr><td>高可用</td><td>ISR + 副本</td><td>Master-Slave + HA</td></tr><tr><td>生态</td><td>Flink、Spark 集成</td><td>分布式事务、支付系统应用</td></tr></tbody></table><hr><h2 id="27-Pulsar-特点"><a href="#27-Pulsar-特点" class="headerlink" title="27. Pulsar 特点"></a><strong>27. Pulsar 特点</strong></h2><ul><li>多租户支持</li><li>持久化使用 BookKeeper</li><li>Topic 可分 Partition</li><li>支持事务、延迟消息</li><li>Push&#x2F;Pull 消费模式灵活</li></ul><hr><h2 id="28-消息中间件如何保证高可用"><a href="#28-消息中间件如何保证高可用" class="headerlink" title="28. 消息中间件如何保证高可用"></a><strong>28. 消息中间件如何保证高可用</strong></h2><ul><li>多副本 + 自动切换</li><li>Broker 集群</li><li>消息持久化</li><li>客户端重试</li><li>Zookeeper&#x2F;Controller 管理元数据</li></ul><hr><h2 id="29-消息队列水平扩展"><a href="#29-消息队列水平扩展" class="headerlink" title="29. 消息队列水平扩展"></a><strong>29. 消息队列水平扩展</strong></h2><ul><li>Kafka：增加 Partition &#x2F; Broker</li><li>RabbitMQ：集群 + Shovel&#x2F;Federation</li><li>RocketMQ：增加 Broker + Topic 分区</li><li><strong>注意</strong>：分区扩展可能影响顺序，需要 Key 路由</li></ul><hr><h2 id="30-消息队列-vs-事件总线"><a href="#30-消息队列-vs-事件总线" class="headerlink" title="30. 消息队列 vs 事件总线"></a><strong>30. 消息队列 vs 事件总线</strong></h2><ul><li>MQ：关注消息可靠性、顺序、确认</li><li>EventBus：关注解耦、广播、轻量级</li><li>MQ 偏向可靠持久化，EventBus 偏向系统内部事件触发</li></ul><hr><h2 id="九、DevOps-容器化（30题）"><a href="#九、DevOps-容器化（30题）" class="headerlink" title="九、DevOps &amp; 容器化（30题）"></a>九、DevOps &amp; 容器化（30题）</h2><hr><h2 id="1-CI-CD-的流程"><a href="#1-CI-CD-的流程" class="headerlink" title="1. CI&#x2F;CD 的流程"></a><strong>1. CI&#x2F;CD 的流程</strong></h2><ul><li><strong>CI（Continuous Integration，持续集成）</strong>：<ul><li>开发者提交代码 → 自动构建 → 自动单元测试 → 自动生成构建产物</li></ul></li><li><strong>CD（Continuous Delivery&#x2F;Deployment，持续交付&#x2F;部署）</strong>：<ul><li>自动部署到测试&#x2F;生产环境 → 自动化验证 → 生产发布</li></ul></li><li><strong>工具链</strong>：<ul><li>Jenkins、GitLab CI、Argo CD</li></ul></li><li><strong>实践要点</strong>：<ul><li>流程自动化</li><li>保证构建产物可回滚</li></ul></li><li><strong>面试拓展</strong>：CI&#x2F;CD 与 DevOps 的关系</li></ul><hr><h2 id="2-Jenkins-的作用"><a href="#2-Jenkins-的作用" class="headerlink" title="2. Jenkins 的作用"></a><strong>2. Jenkins 的作用</strong></h2><ul><li>自动化构建、测试、部署工具</li><li><strong>核心功能</strong>：<ul><li>支持多种 SCM（Git、SVN）</li><li>Pipeline 管理</li><li>插件生态丰富（Docker、K8s 集成）</li></ul></li><li><strong>面试追问</strong>：Pipeline 如何保证构建可重复、可回滚</li></ul><hr><h2 id="3-Docker-核心原理"><a href="#3-Docker-核心原理" class="headerlink" title="3. Docker 核心原理"></a><strong>3. Docker 核心原理</strong></h2><ul><li><strong>容器化技术</strong>：<ul><li>Linux <strong>namespace</strong> 隔离（进程、网络、文件系统）</li><li>Linux <strong>cgroups</strong> 限制资源（CPU、内存）</li><li>**联合文件系统（UnionFS）**实现镜像分层</li></ul></li><li><strong>容器 ≈ 轻量级虚拟机</strong>，共享宿主 OS 内核</li></ul><hr><h2 id="4-Docker-镜像-vs-容器"><a href="#4-Docker-镜像-vs-容器" class="headerlink" title="4. Docker 镜像 vs 容器"></a><strong>4. Docker 镜像 vs 容器</strong></h2><table><thead><tr><th>区别</th><th>镜像</th><th>容器</th></tr></thead><tbody><tr><td>定义</td><td>只读模板</td><td>镜像运行实例</td></tr><tr><td>存储</td><td>分层只读文件系统</td><td>读写层 + 镜像</td></tr><tr><td>生命周期</td><td>永久</td><td>临时，可停止&#x2F;删除</td></tr><tr><td>用途</td><td>构建应用</td><td>运行应用</td></tr></tbody></table><hr><h2 id="5-Dockerfile-常用指令"><a href="#5-Dockerfile-常用指令" class="headerlink" title="5. Dockerfile 常用指令"></a><strong>5. Dockerfile 常用指令</strong></h2><ul><li><code>FROM</code>：基础镜像</li><li><code>RUN</code>：执行命令构建镜像</li><li><code>COPY</code>&#x2F;<code>ADD</code>：复制文件到镜像</li><li><code>CMD</code>&#x2F;<code>ENTRYPOINT</code>：容器启动命令</li><li><code>EXPOSE</code>：声明端口</li><li><code>ENV</code>：环境变量</li><li><strong>优化</strong>：减少镜像层，顺序合理缓存</li></ul><hr><h2 id="6-镜像分层机制"><a href="#6-镜像分层机制" class="headerlink" title="6. 镜像分层机制"></a><strong>6. 镜像分层机制</strong></h2><ul><li>镜像每条指令生成一个只读层</li><li>联合文件系统（UnionFS）叠加这些层</li><li>容器启动时增加读写层</li><li><strong>优势</strong>：<ul><li>共享公共层，节省空间</li><li>支持增量构建</li></ul></li></ul><hr><h2 id="7-容器-vs-虚拟机"><a href="#7-容器-vs-虚拟机" class="headerlink" title="7. 容器 vs 虚拟机"></a><strong>7. 容器 vs 虚拟机</strong></h2><table><thead><tr><th>区别</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>内核</td><td>共享宿主 OS 内核</td><td>独立 OS</td></tr><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>资源占用</td><td>轻量</td><td>重量</td></tr><tr><td>隔离</td><td>进程级</td><td>硬件级</td></tr></tbody></table><hr><h2 id="8-Kubernetes-核心组件"><a href="#8-Kubernetes-核心组件" class="headerlink" title="8. Kubernetes 核心组件"></a><strong>8. Kubernetes 核心组件</strong></h2><ul><li><strong>Master</strong>：<ul><li>API Server：接收用户请求</li><li>Scheduler：Pod 调度</li><li>Controller Manager：状态管理</li><li>etcd：分布式配置存储</li></ul></li><li><strong>Node</strong>：<ul><li>Kubelet：Pod 生命周期管理</li><li>Kube-proxy：服务网络代理</li><li>Container Runtime（Docker&#x2F;CRI-O）</li></ul></li></ul><hr><h2 id="9-Pod-生命周期"><a href="#9-Pod-生命周期" class="headerlink" title="9. Pod 生命周期"></a><strong>9. Pod 生命周期</strong></h2><ul><li><strong>Pending</strong> → <strong>Running</strong> → <strong>Succeeded&#x2F;Failed</strong></li><li><strong>状态管理</strong>：<ul><li>initContainer → main container → postStop Hook</li></ul></li><li><strong>面试点</strong>：Pod 重启策略（Always&#x2F;OnFailure&#x2F;Never）</li></ul><hr><h2 id="10-Deployment-vs-StatefulSet"><a href="#10-Deployment-vs-StatefulSet" class="headerlink" title="10. Deployment vs StatefulSet"></a><strong>10. Deployment vs StatefulSet</strong></h2><table><thead><tr><th>特性</th><th>Deployment</th><th>StatefulSet</th></tr></thead><tbody><tr><td>Pod 标识</td><td>无固定名字</td><td>有固定名字</td></tr><tr><td>顺序更新</td><td>可并行更新</td><td>严格顺序更新</td></tr><tr><td>持久化存储</td><td>共享卷</td><td>独立持久卷</td></tr><tr><td>应用场景</td><td>无状态服务</td><td>数据库、Kafka Broker 等状态服务</td></tr></tbody></table><hr><h2 id="11-K8s-服务发现机制"><a href="#11-K8s-服务发现机制" class="headerlink" title="11. K8s 服务发现机制"></a><strong>11. K8s 服务发现机制</strong></h2><ul><li><strong>ClusterIP</strong>：集群内部访问</li><li><strong>NodePort</strong>：节点端口访问</li><li><strong>LoadBalancer</strong>：外部访问</li><li><strong>DNS + kube-proxy</strong>：Pod 名称解析 + iptables 转发</li></ul><hr><h2 id="12-ConfigMap-和-Secret"><a href="#12-ConfigMap-和-Secret" class="headerlink" title="12. ConfigMap 和 Secret"></a><strong>12. ConfigMap 和 Secret</strong></h2><table><thead><tr><th>特性</th><th>ConfigMap</th><th>Secret</th></tr></thead><tbody><tr><td>数据类型</td><td>明文配置</td><td>Base64 编码敏感信息</td></tr><tr><td>使用方式</td><td>Env&#x2F;Volume</td><td>Env&#x2F;Volume</td></tr><tr><td>安全性</td><td>不加密</td><td>加密可集成 KMS</td></tr></tbody></table><hr><h2 id="13-Ingress-的作用"><a href="#13-Ingress-的作用" class="headerlink" title="13. Ingress 的作用"></a><strong>13. Ingress 的作用</strong></h2><ul><li>集群外部访问 Pod 的入口</li><li>功能：<ul><li>路由到不同服务</li><li>TLS 终端</li><li>负载均衡</li></ul></li><li><strong>面试点</strong>：Ingress Controller vs Service LB</li></ul><hr><h2 id="14-K8s-水平扩缩容机制"><a href="#14-K8s-水平扩缩容机制" class="headerlink" title="14. K8s 水平扩缩容机制"></a><strong>14. K8s 水平扩缩容机制</strong></h2><ul><li><strong>HPA（Horizontal Pod Autoscaler）</strong>：根据 CPU、内存或自定义指标调整 Pod 数量</li><li><strong>VPA（Vertical Pod Autoscaler）</strong>：自动调整 Pod 资源配置</li><li><strong>Cluster Autoscaler</strong>：节点自动扩缩容</li></ul><hr><h2 id="15-K8s-滚动更新机制"><a href="#15-K8s-滚动更新机制" class="headerlink" title="15. K8s 滚动更新机制"></a><strong>15. K8s 滚动更新机制</strong></h2><ul><li><strong>Deployment</strong> 滚动更新策略：<ul><li><code>maxUnavailable</code>：最大不可用 Pod</li><li><code>maxSurge</code>：最大新增 Pod</li></ul></li><li><strong>保证无中断升级</strong></li></ul><hr><h2 id="16-K8s-灰度发布"><a href="#16-K8s-灰度发布" class="headerlink" title="16. K8s 灰度发布"></a><strong>16. K8s 灰度发布</strong></h2><ul><li><strong>方法</strong>：<ul><li>分流流量（Ingress&#x2F;Service Mesh）</li><li>多版本 Deployment</li><li>Canary Pod + 路由权重</li></ul></li></ul><hr><h2 id="17-K8s-调度策略"><a href="#17-K8s-调度策略" class="headerlink" title="17. K8s 调度策略"></a><strong>17. K8s 调度策略</strong></h2><ul><li><strong>默认调度</strong>：基于资源（CPU&#x2F;Memory）</li><li><strong>亲和性&#x2F;反亲和性</strong>：<ul><li>NodeAffinity</li><li>PodAffinity &#x2F; PodAntiAffinity</li></ul></li><li><strong>Taints &amp; Tolerations</strong>：节点污点控制 Pod 调度</li></ul><hr><h2 id="18-K8s-网络模型"><a href="#18-K8s-网络模型" class="headerlink" title="18. K8s 网络模型"></a><strong>18. K8s 网络模型</strong></h2><ul><li><strong>要求</strong>：<ul><li>Pod 可以直接互相通信</li><li>Pod 与 Node 通信</li></ul></li><li><strong>方案</strong>：<ul><li>Flannel、Calico、Cilium 等</li></ul></li><li><strong>面试点</strong>：Overlay 网络 vs Underlay 网络</li></ul><hr><h2 id="19-Service-Mesh-作用"><a href="#19-Service-Mesh-作用" class="headerlink" title="19. Service Mesh 作用"></a><strong>19. Service Mesh 作用</strong></h2><ul><li>透明通信管理</li><li>流量控制、熔断、限流</li><li>可观察性（Tracing、Metrics）</li><li>安全（mTLS）</li></ul><hr><h2 id="20-Istio-工作原理"><a href="#20-Istio-工作原理" class="headerlink" title="20. Istio 工作原理"></a><strong>20. Istio 工作原理</strong></h2><ul><li><strong>Sidecar Proxy</strong>：每个 Pod 注入 Envoy</li><li><strong>控制平面（Pilot）</strong>：下发路由规则</li><li><strong>Mixer &#x2F; Telemetry</strong>：采集指标和日志</li><li><strong>应用</strong>：<ul><li>灰度发布、流量镜像、故障注入、服务间安全通信</li></ul></li></ul><hr><h2 id="21-Helm-的作用"><a href="#21-Helm-的作用" class="headerlink" title="21. Helm 的作用"></a><strong>21. Helm 的作用</strong></h2><ul><li>Kubernetes 包管理工具</li><li><strong>功能</strong>：<ul><li>Chart 模板化部署</li><li>版本管理</li><li>一键升级&#x2F;回滚</li></ul></li><li><strong>面试拓展</strong>：Helm 与 Kustomize 区别</li></ul><hr><h2 id="22-K8s-存储方案"><a href="#22-K8s-存储方案" class="headerlink" title="22. K8s 存储方案"></a><strong>22. K8s 存储方案</strong></h2><ul><li><strong>临时存储</strong>：emptyDir</li><li><strong>持久卷</strong>：PersistentVolume + PersistentVolumeClaim</li><li><strong>存储类型</strong>：<ul><li>本地存储</li><li>NFS</li><li>Ceph &#x2F; GlusterFS</li><li>云存储（EBS、OSS）</li></ul></li></ul><hr><h2 id="23-Prometheus-监控体系"><a href="#23-Prometheus-监控体系" class="headerlink" title="23. Prometheus 监控体系"></a><strong>23. Prometheus 监控体系</strong></h2><ul><li>Pull 模型采集指标</li><li>TSDB 存储时间序列数据</li><li>AlertManager 告警</li><li>可监控 K8s 组件、Pod、应用指标</li></ul><hr><h2 id="24-Grafana-的作用"><a href="#24-Grafana-的作用" class="headerlink" title="24. Grafana 的作用"></a><strong>24. Grafana 的作用</strong></h2><ul><li>可视化 Prometheus 数据</li><li>仪表盘定制</li><li>支持多数据源（InfluxDB、ElasticSearch）</li><li>面试点：报警可视化和多租户支持</li></ul><hr><h2 id="25-K8s-安全机制"><a href="#25-K8s-安全机制" class="headerlink" title="25. K8s 安全机制"></a><strong>25. K8s 安全机制</strong></h2><ul><li><strong>认证（Authentication）</strong>：Token &#x2F; X.509 &#x2F; OIDC</li><li><strong>授权（Authorization）</strong>：RBAC</li><li><strong>网络策略（NetworkPolicy）</strong></li><li><strong>Secret 加密</strong></li></ul><hr><h2 id="26-容器资源限制"><a href="#26-容器资源限制" class="headerlink" title="26. 容器资源限制"></a><strong>26. 容器资源限制</strong></h2><ul><li><strong>CPU &#x2F; Memory</strong>：requests &#x2F; limits</li><li><strong>QoS 分类</strong>：<ul><li>Guaranteed、Burstable、BestEffort</li></ul></li><li><strong>面试点</strong>：容器 OOM 及限流策略</li></ul><hr><h2 id="27-Docker-Compose-作用"><a href="#27-Docker-Compose-作用" class="headerlink" title="27. Docker Compose 作用"></a><strong>27. Docker Compose 作用</strong></h2><ul><li>多容器应用管理</li><li>本地开发、测试</li><li>声明式配置网络、依赖关系</li></ul><hr><h2 id="28-DevOps-最佳实践"><a href="#28-DevOps-最佳实践" class="headerlink" title="28. DevOps 最佳实践"></a><strong>28. DevOps 最佳实践</strong></h2><ul><li>持续集成&#x2F;持续交付</li><li>基础设施即代码（IaC）</li><li>自动化测试与部署</li><li>微服务 + 容器化 + 云原生</li></ul><hr><h2 id="29-GitOps-理念"><a href="#29-GitOps-理念" class="headerlink" title="29. GitOps 理念"></a><strong>29. GitOps 理念</strong></h2><ul><li>将 Git 作为单一真源</li><li>K8s 自动同步 Git 状态</li><li>优点：<ul><li>可追踪、可回滚</li><li>流程统一、可审计</li></ul></li></ul><hr><h2 id="30-K8s-如何保证高可用"><a href="#30-K8s-如何保证高可用" class="headerlink" title="30. K8s 如何保证高可用"></a><strong>30. K8s 如何保证高可用</strong></h2><ul><li>Master 节点多副本（HA）</li><li>ETCD 集群存储</li><li>Pod 多副本 + Deployment&#x2F;StatefulSet</li><li>Service + LoadBalancer 提供稳定访问</li><li>Cluster Autoscaler 支持节点弹性扩展</li></ul><hr><h2 id="十、场景设计题（30题）"><a href="#十、场景设计题（30题）" class="headerlink" title="十、场景设计题（30题）"></a>十、场景设计题（30题）</h2><ol><li>如何设计一个秒杀系统？</li><li>如何设计一个短链系统？</li><li>如何设计一个分布式 ID 生成系统？</li><li>如何设计一个高可用缓存系统？</li><li>如何设计一个订单系统？</li><li>如何设计一个支付系统？</li><li>如何设计一个消息推送系统？</li><li>如何设计一个日志收集系统？</li><li>如何设计一个搜索引擎？</li><li>如何设计一个推荐系统？</li><li>如何设计一个分布式锁？</li><li>如何设计一个统一鉴权系统？</li><li>如何设计一个限流系统？</li><li>如何设计一个灰度发布系统？</li><li>如何设计一个电商购物车？</li><li>如何设计一个库存系统？</li><li>如何设计一个分布式文件存储系统？</li><li>如何设计一个微服务网关？</li><li>如何设计一个分布式任务调度系统？</li><li>如何设计一个监控报警系统？</li><li>如何设计一个高并发聊天室？</li><li>如何设计一个排行榜系统？</li><li>如何设计一个评论系统？</li><li>如何设计一个分布式事务系统？</li><li>如何设计一个高可用注册中心？</li><li>如何设计一个数据同步系统？</li><li>如何设计一个 API 限速系统？</li><li>如何设计一个高可用的支付网关？</li><li>如何设计一个跨境电商架构？</li><li>如何设计一个金融级别的微服务系统？</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Java-基础语法-关键字&quot;&gt;&lt;a href=&quot;#一、Java-基础语法-关键字&quot; class=&quot;headerlink&quot; title=&quot;一、Java 基础语法 &amp;amp; 关键字&quot;&gt;&lt;/a&gt;一、Java 基础语法 &amp;amp; 关键字&lt;/h2&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="题目" scheme="http://example.com/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2025/09/11/hello-world/"/>
    <id>http://example.com/2025/09/11/hello-world/</id>
    <published>2025-09-11T10:19:47.428Z</published>
    <updated>2025-09-11T10:19:47.428Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
